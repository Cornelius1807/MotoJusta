
/**
 * Client
**/

import * as runtime from './runtime/client.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model UserProfile
 * 
 */
export type UserProfile = $Result.DefaultSelection<Prisma.$UserProfilePayload>
/**
 * Model Motorcycle
 * 
 */
export type Motorcycle = $Result.DefaultSelection<Prisma.$MotorcyclePayload>
/**
 * Model Category
 * 
 */
export type Category = $Result.DefaultSelection<Prisma.$CategoryPayload>
/**
 * Model GuideQuestion
 * 
 */
export type GuideQuestion = $Result.DefaultSelection<Prisma.$GuideQuestionPayload>
/**
 * Model GuideAnswer
 * 
 */
export type GuideAnswer = $Result.DefaultSelection<Prisma.$GuideAnswerPayload>
/**
 * Model ServiceRequest
 * 
 */
export type ServiceRequest = $Result.DefaultSelection<Prisma.$ServiceRequestPayload>
/**
 * Model RequestMedia
 * 
 */
export type RequestMedia = $Result.DefaultSelection<Prisma.$RequestMediaPayload>
/**
 * Model RequestStatusHistory
 * 
 */
export type RequestStatusHistory = $Result.DefaultSelection<Prisma.$RequestStatusHistoryPayload>
/**
 * Model Workshop
 * 
 */
export type Workshop = $Result.DefaultSelection<Prisma.$WorkshopPayload>
/**
 * Model WorkshopCategory
 * 
 */
export type WorkshopCategory = $Result.DefaultSelection<Prisma.$WorkshopCategoryPayload>
/**
 * Model WorkshopVerification
 * 
 */
export type WorkshopVerification = $Result.DefaultSelection<Prisma.$WorkshopVerificationPayload>
/**
 * Model Quote
 * 
 */
export type Quote = $Result.DefaultSelection<Prisma.$QuotePayload>
/**
 * Model QuotePartItem
 * 
 */
export type QuotePartItem = $Result.DefaultSelection<Prisma.$QuotePartItemPayload>
/**
 * Model WorkOrder
 * 
 */
export type WorkOrder = $Result.DefaultSelection<Prisma.$WorkOrderPayload>
/**
 * Model ChangeRequest
 * 
 */
export type ChangeRequest = $Result.DefaultSelection<Prisma.$ChangeRequestPayload>
/**
 * Model Evidence
 * 
 */
export type Evidence = $Result.DefaultSelection<Prisma.$EvidencePayload>
/**
 * Model Review
 * 
 */
export type Review = $Result.DefaultSelection<Prisma.$ReviewPayload>
/**
 * Model Receipt
 * 
 */
export type Receipt = $Result.DefaultSelection<Prisma.$ReceiptPayload>
/**
 * Model IncidentReport
 * 
 */
export type IncidentReport = $Result.DefaultSelection<Prisma.$IncidentReportPayload>
/**
 * Model ChatMessage
 * 
 */
export type ChatMessage = $Result.DefaultSelection<Prisma.$ChatMessagePayload>
/**
 * Model Notification
 * 
 */
export type Notification = $Result.DefaultSelection<Prisma.$NotificationPayload>
/**
 * Model AuditLog
 * 
 */
export type AuditLog = $Result.DefaultSelection<Prisma.$AuditLogPayload>
/**
 * Model FeatureFlag
 * 
 */
export type FeatureFlag = $Result.DefaultSelection<Prisma.$FeatureFlagPayload>
/**
 * Model AiSuggestion
 * 
 */
export type AiSuggestion = $Result.DefaultSelection<Prisma.$AiSuggestionPayload>
/**
 * Model AiQuoteAnalysis
 * 
 */
export type AiQuoteAnalysis = $Result.DefaultSelection<Prisma.$AiQuoteAnalysisPayload>
/**
 * Model AppConfig
 * 
 */
export type AppConfig = $Result.DefaultSelection<Prisma.$AppConfigPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const UserRole: {
  MOTOCICLISTA: 'MOTOCICLISTA',
  TALLER: 'TALLER',
  ADMIN: 'ADMIN'
};

export type UserRole = (typeof UserRole)[keyof typeof UserRole]


export const NotificationChannel: {
  PUSH: 'PUSH',
  EMAIL: 'EMAIL',
  WHATSAPP: 'WHATSAPP',
  IN_APP: 'IN_APP'
};

export type NotificationChannel = (typeof NotificationChannel)[keyof typeof NotificationChannel]


export const WorkshopStatus: {
  PENDIENTE: 'PENDIENTE',
  VERIFICADO: 'VERIFICADO',
  RECHAZADO: 'RECHAZADO',
  SUSPENDIDO: 'SUSPENDIDO'
};

export type WorkshopStatus = (typeof WorkshopStatus)[keyof typeof WorkshopStatus]


export const ServiceRequestStatus: {
  BORRADOR: 'BORRADOR',
  PUBLICADA: 'PUBLICADA',
  EN_COTIZACION: 'EN_COTIZACION',
  SELECCIONADA: 'SELECCIONADA',
  EN_SERVICIO: 'EN_SERVICIO',
  CERRADA: 'CERRADA',
  CANCELADA: 'CANCELADA'
};

export type ServiceRequestStatus = (typeof ServiceRequestStatus)[keyof typeof ServiceRequestStatus]


export const UrgencyLevel: {
  BAJA: 'BAJA',
  MEDIA: 'MEDIA',
  ALTA: 'ALTA',
  URGENTE: 'URGENTE'
};

export type UrgencyLevel = (typeof UrgencyLevel)[keyof typeof UrgencyLevel]


export const QuoteStatus: {
  BORRADOR: 'BORRADOR',
  ENVIADA: 'ENVIADA',
  ACEPTADA: 'ACEPTADA',
  RECHAZADA: 'RECHAZADA',
  EXPIRADA: 'EXPIRADA'
};

export type QuoteStatus = (typeof QuoteStatus)[keyof typeof QuoteStatus]


export const PartType: {
  ORIGINAL: 'ORIGINAL',
  ALTERNATIVO: 'ALTERNATIVO'
};

export type PartType = (typeof PartType)[keyof typeof PartType]


export const WorkOrderStatus: {
  PENDIENTE: 'PENDIENTE',
  EN_SERVICIO: 'EN_SERVICIO',
  COMPLETADA: 'COMPLETADA',
  CERRADA: 'CERRADA'
};

export type WorkOrderStatus = (typeof WorkOrderStatus)[keyof typeof WorkOrderStatus]


export const ChangeRequestStatus: {
  PENDIENTE: 'PENDIENTE',
  APROBADO: 'APROBADO',
  RECHAZADO: 'RECHAZADO'
};

export type ChangeRequestStatus = (typeof ChangeRequestStatus)[keyof typeof ChangeRequestStatus]


export const EvidenceStage: {
  DIAGNOSTICO: 'DIAGNOSTICO',
  REPUESTO_CAMBIADO: 'REPUESTO_CAMBIADO',
  FINALIZACION: 'FINALIZACION'
};

export type EvidenceStage = (typeof EvidenceStage)[keyof typeof EvidenceStage]


export const IncidentType: {
  SOBRECOSTO: 'SOBRECOSTO',
  FALTA_EVIDENCIA: 'FALTA_EVIDENCIA',
  TRATO_INDEBIDO: 'TRATO_INDEBIDO',
  OTRO: 'OTRO'
};

export type IncidentType = (typeof IncidentType)[keyof typeof IncidentType]


export const IncidentStatus: {
  RECIBIDO: 'RECIBIDO',
  EN_REVISION: 'EN_REVISION',
  RESUELTO: 'RESUELTO'
};

export type IncidentStatus = (typeof IncidentStatus)[keyof typeof IncidentStatus]


export const AdminActionType: {
  VERIFICAR_TALLER: 'VERIFICAR_TALLER',
  RECHAZAR_TALLER: 'RECHAZAR_TALLER',
  SUSPENDER_TALLER: 'SUSPENDER_TALLER',
  REACTIVAR_TALLER: 'REACTIVAR_TALLER',
  ADVERTENCIA: 'ADVERTENCIA',
  SOLICITAR_DESCARGO: 'SOLICITAR_DESCARGO',
  EXPULSAR: 'EXPULSAR',
  RESOLVER_INCIDENTE: 'RESOLVER_INCIDENTE',
  CAMBIAR_CONFIG: 'CAMBIAR_CONFIG'
};

export type AdminActionType = (typeof AdminActionType)[keyof typeof AdminActionType]


export const MediaType: {
  IMAGE: 'IMAGE',
  VIDEO: 'VIDEO'
};

export type MediaType = (typeof MediaType)[keyof typeof MediaType]


export const MotorcycleUse: {
  TRABAJO: 'TRABAJO',
  DIARIO: 'DIARIO',
  MIXTO: 'MIXTO'
};

export type MotorcycleUse = (typeof MotorcycleUse)[keyof typeof MotorcycleUse]

}

export type UserRole = $Enums.UserRole

export const UserRole: typeof $Enums.UserRole

export type NotificationChannel = $Enums.NotificationChannel

export const NotificationChannel: typeof $Enums.NotificationChannel

export type WorkshopStatus = $Enums.WorkshopStatus

export const WorkshopStatus: typeof $Enums.WorkshopStatus

export type ServiceRequestStatus = $Enums.ServiceRequestStatus

export const ServiceRequestStatus: typeof $Enums.ServiceRequestStatus

export type UrgencyLevel = $Enums.UrgencyLevel

export const UrgencyLevel: typeof $Enums.UrgencyLevel

export type QuoteStatus = $Enums.QuoteStatus

export const QuoteStatus: typeof $Enums.QuoteStatus

export type PartType = $Enums.PartType

export const PartType: typeof $Enums.PartType

export type WorkOrderStatus = $Enums.WorkOrderStatus

export const WorkOrderStatus: typeof $Enums.WorkOrderStatus

export type ChangeRequestStatus = $Enums.ChangeRequestStatus

export const ChangeRequestStatus: typeof $Enums.ChangeRequestStatus

export type EvidenceStage = $Enums.EvidenceStage

export const EvidenceStage: typeof $Enums.EvidenceStage

export type IncidentType = $Enums.IncidentType

export const IncidentType: typeof $Enums.IncidentType

export type IncidentStatus = $Enums.IncidentStatus

export const IncidentStatus: typeof $Enums.IncidentStatus

export type AdminActionType = $Enums.AdminActionType

export const AdminActionType: typeof $Enums.AdminActionType

export type MediaType = $Enums.MediaType

export const MediaType: typeof $Enums.MediaType

export type MotorcycleUse = $Enums.MotorcycleUse

export const MotorcycleUse: typeof $Enums.MotorcycleUse

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more UserProfiles
 * const userProfiles = await prisma.userProfile.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://pris.ly/d/client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more UserProfiles
   * const userProfiles = await prisma.userProfile.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://pris.ly/d/client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/orm/prisma-client/queries/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>

  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.userProfile`: Exposes CRUD operations for the **UserProfile** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserProfiles
    * const userProfiles = await prisma.userProfile.findMany()
    * ```
    */
  get userProfile(): Prisma.UserProfileDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.motorcycle`: Exposes CRUD operations for the **Motorcycle** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Motorcycles
    * const motorcycles = await prisma.motorcycle.findMany()
    * ```
    */
  get motorcycle(): Prisma.MotorcycleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.category`: Exposes CRUD operations for the **Category** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Categories
    * const categories = await prisma.category.findMany()
    * ```
    */
  get category(): Prisma.CategoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.guideQuestion`: Exposes CRUD operations for the **GuideQuestion** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GuideQuestions
    * const guideQuestions = await prisma.guideQuestion.findMany()
    * ```
    */
  get guideQuestion(): Prisma.GuideQuestionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.guideAnswer`: Exposes CRUD operations for the **GuideAnswer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GuideAnswers
    * const guideAnswers = await prisma.guideAnswer.findMany()
    * ```
    */
  get guideAnswer(): Prisma.GuideAnswerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.serviceRequest`: Exposes CRUD operations for the **ServiceRequest** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ServiceRequests
    * const serviceRequests = await prisma.serviceRequest.findMany()
    * ```
    */
  get serviceRequest(): Prisma.ServiceRequestDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.requestMedia`: Exposes CRUD operations for the **RequestMedia** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RequestMedias
    * const requestMedias = await prisma.requestMedia.findMany()
    * ```
    */
  get requestMedia(): Prisma.RequestMediaDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.requestStatusHistory`: Exposes CRUD operations for the **RequestStatusHistory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RequestStatusHistories
    * const requestStatusHistories = await prisma.requestStatusHistory.findMany()
    * ```
    */
  get requestStatusHistory(): Prisma.RequestStatusHistoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.workshop`: Exposes CRUD operations for the **Workshop** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Workshops
    * const workshops = await prisma.workshop.findMany()
    * ```
    */
  get workshop(): Prisma.WorkshopDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.workshopCategory`: Exposes CRUD operations for the **WorkshopCategory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WorkshopCategories
    * const workshopCategories = await prisma.workshopCategory.findMany()
    * ```
    */
  get workshopCategory(): Prisma.WorkshopCategoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.workshopVerification`: Exposes CRUD operations for the **WorkshopVerification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WorkshopVerifications
    * const workshopVerifications = await prisma.workshopVerification.findMany()
    * ```
    */
  get workshopVerification(): Prisma.WorkshopVerificationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.quote`: Exposes CRUD operations for the **Quote** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Quotes
    * const quotes = await prisma.quote.findMany()
    * ```
    */
  get quote(): Prisma.QuoteDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.quotePartItem`: Exposes CRUD operations for the **QuotePartItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more QuotePartItems
    * const quotePartItems = await prisma.quotePartItem.findMany()
    * ```
    */
  get quotePartItem(): Prisma.QuotePartItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.workOrder`: Exposes CRUD operations for the **WorkOrder** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WorkOrders
    * const workOrders = await prisma.workOrder.findMany()
    * ```
    */
  get workOrder(): Prisma.WorkOrderDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.changeRequest`: Exposes CRUD operations for the **ChangeRequest** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ChangeRequests
    * const changeRequests = await prisma.changeRequest.findMany()
    * ```
    */
  get changeRequest(): Prisma.ChangeRequestDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.evidence`: Exposes CRUD operations for the **Evidence** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Evidences
    * const evidences = await prisma.evidence.findMany()
    * ```
    */
  get evidence(): Prisma.EvidenceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.review`: Exposes CRUD operations for the **Review** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Reviews
    * const reviews = await prisma.review.findMany()
    * ```
    */
  get review(): Prisma.ReviewDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.receipt`: Exposes CRUD operations for the **Receipt** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Receipts
    * const receipts = await prisma.receipt.findMany()
    * ```
    */
  get receipt(): Prisma.ReceiptDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.incidentReport`: Exposes CRUD operations for the **IncidentReport** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more IncidentReports
    * const incidentReports = await prisma.incidentReport.findMany()
    * ```
    */
  get incidentReport(): Prisma.IncidentReportDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.chatMessage`: Exposes CRUD operations for the **ChatMessage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ChatMessages
    * const chatMessages = await prisma.chatMessage.findMany()
    * ```
    */
  get chatMessage(): Prisma.ChatMessageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.notification`: Exposes CRUD operations for the **Notification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notification.findMany()
    * ```
    */
  get notification(): Prisma.NotificationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.auditLog`: Exposes CRUD operations for the **AuditLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AuditLogs
    * const auditLogs = await prisma.auditLog.findMany()
    * ```
    */
  get auditLog(): Prisma.AuditLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.featureFlag`: Exposes CRUD operations for the **FeatureFlag** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FeatureFlags
    * const featureFlags = await prisma.featureFlag.findMany()
    * ```
    */
  get featureFlag(): Prisma.FeatureFlagDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.aiSuggestion`: Exposes CRUD operations for the **AiSuggestion** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AiSuggestions
    * const aiSuggestions = await prisma.aiSuggestion.findMany()
    * ```
    */
  get aiSuggestion(): Prisma.AiSuggestionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.aiQuoteAnalysis`: Exposes CRUD operations for the **AiQuoteAnalysis** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AiQuoteAnalyses
    * const aiQuoteAnalyses = await prisma.aiQuoteAnalysis.findMany()
    * ```
    */
  get aiQuoteAnalysis(): Prisma.AiQuoteAnalysisDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.appConfig`: Exposes CRUD operations for the **AppConfig** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AppConfigs
    * const appConfigs = await prisma.appConfig.findMany()
    * ```
    */
  get appConfig(): Prisma.AppConfigDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 7.4.1
   * Query Engine version: 55ae170b1ced7fc6ed07a15f110549408c501bb3
   */
  export type PrismaVersion = {
    client: string
    engine: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import Bytes = runtime.Bytes
  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    UserProfile: 'UserProfile',
    Motorcycle: 'Motorcycle',
    Category: 'Category',
    GuideQuestion: 'GuideQuestion',
    GuideAnswer: 'GuideAnswer',
    ServiceRequest: 'ServiceRequest',
    RequestMedia: 'RequestMedia',
    RequestStatusHistory: 'RequestStatusHistory',
    Workshop: 'Workshop',
    WorkshopCategory: 'WorkshopCategory',
    WorkshopVerification: 'WorkshopVerification',
    Quote: 'Quote',
    QuotePartItem: 'QuotePartItem',
    WorkOrder: 'WorkOrder',
    ChangeRequest: 'ChangeRequest',
    Evidence: 'Evidence',
    Review: 'Review',
    Receipt: 'Receipt',
    IncidentReport: 'IncidentReport',
    ChatMessage: 'ChatMessage',
    Notification: 'Notification',
    AuditLog: 'AuditLog',
    FeatureFlag: 'FeatureFlag',
    AiSuggestion: 'AiSuggestion',
    AiQuoteAnalysis: 'AiQuoteAnalysis',
    AppConfig: 'AppConfig'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]



  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "userProfile" | "motorcycle" | "category" | "guideQuestion" | "guideAnswer" | "serviceRequest" | "requestMedia" | "requestStatusHistory" | "workshop" | "workshopCategory" | "workshopVerification" | "quote" | "quotePartItem" | "workOrder" | "changeRequest" | "evidence" | "review" | "receipt" | "incidentReport" | "chatMessage" | "notification" | "auditLog" | "featureFlag" | "aiSuggestion" | "aiQuoteAnalysis" | "appConfig"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      UserProfile: {
        payload: Prisma.$UserProfilePayload<ExtArgs>
        fields: Prisma.UserProfileFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserProfileFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProfilePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserProfileFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProfilePayload>
          }
          findFirst: {
            args: Prisma.UserProfileFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProfilePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserProfileFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProfilePayload>
          }
          findMany: {
            args: Prisma.UserProfileFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProfilePayload>[]
          }
          create: {
            args: Prisma.UserProfileCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProfilePayload>
          }
          createMany: {
            args: Prisma.UserProfileCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserProfileCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProfilePayload>[]
          }
          delete: {
            args: Prisma.UserProfileDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProfilePayload>
          }
          update: {
            args: Prisma.UserProfileUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProfilePayload>
          }
          deleteMany: {
            args: Prisma.UserProfileDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserProfileUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserProfileUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProfilePayload>[]
          }
          upsert: {
            args: Prisma.UserProfileUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProfilePayload>
          }
          aggregate: {
            args: Prisma.UserProfileAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserProfile>
          }
          groupBy: {
            args: Prisma.UserProfileGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserProfileGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserProfileCountArgs<ExtArgs>
            result: $Utils.Optional<UserProfileCountAggregateOutputType> | number
          }
        }
      }
      Motorcycle: {
        payload: Prisma.$MotorcyclePayload<ExtArgs>
        fields: Prisma.MotorcycleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MotorcycleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MotorcyclePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MotorcycleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MotorcyclePayload>
          }
          findFirst: {
            args: Prisma.MotorcycleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MotorcyclePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MotorcycleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MotorcyclePayload>
          }
          findMany: {
            args: Prisma.MotorcycleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MotorcyclePayload>[]
          }
          create: {
            args: Prisma.MotorcycleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MotorcyclePayload>
          }
          createMany: {
            args: Prisma.MotorcycleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MotorcycleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MotorcyclePayload>[]
          }
          delete: {
            args: Prisma.MotorcycleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MotorcyclePayload>
          }
          update: {
            args: Prisma.MotorcycleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MotorcyclePayload>
          }
          deleteMany: {
            args: Prisma.MotorcycleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MotorcycleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MotorcycleUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MotorcyclePayload>[]
          }
          upsert: {
            args: Prisma.MotorcycleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MotorcyclePayload>
          }
          aggregate: {
            args: Prisma.MotorcycleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMotorcycle>
          }
          groupBy: {
            args: Prisma.MotorcycleGroupByArgs<ExtArgs>
            result: $Utils.Optional<MotorcycleGroupByOutputType>[]
          }
          count: {
            args: Prisma.MotorcycleCountArgs<ExtArgs>
            result: $Utils.Optional<MotorcycleCountAggregateOutputType> | number
          }
        }
      }
      Category: {
        payload: Prisma.$CategoryPayload<ExtArgs>
        fields: Prisma.CategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CategoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CategoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          findFirst: {
            args: Prisma.CategoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CategoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          findMany: {
            args: Prisma.CategoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>[]
          }
          create: {
            args: Prisma.CategoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          createMany: {
            args: Prisma.CategoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CategoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>[]
          }
          delete: {
            args: Prisma.CategoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          update: {
            args: Prisma.CategoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          deleteMany: {
            args: Prisma.CategoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CategoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CategoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>[]
          }
          upsert: {
            args: Prisma.CategoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          aggregate: {
            args: Prisma.CategoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCategory>
          }
          groupBy: {
            args: Prisma.CategoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<CategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.CategoryCountArgs<ExtArgs>
            result: $Utils.Optional<CategoryCountAggregateOutputType> | number
          }
        }
      }
      GuideQuestion: {
        payload: Prisma.$GuideQuestionPayload<ExtArgs>
        fields: Prisma.GuideQuestionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GuideQuestionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuideQuestionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GuideQuestionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuideQuestionPayload>
          }
          findFirst: {
            args: Prisma.GuideQuestionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuideQuestionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GuideQuestionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuideQuestionPayload>
          }
          findMany: {
            args: Prisma.GuideQuestionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuideQuestionPayload>[]
          }
          create: {
            args: Prisma.GuideQuestionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuideQuestionPayload>
          }
          createMany: {
            args: Prisma.GuideQuestionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GuideQuestionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuideQuestionPayload>[]
          }
          delete: {
            args: Prisma.GuideQuestionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuideQuestionPayload>
          }
          update: {
            args: Prisma.GuideQuestionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuideQuestionPayload>
          }
          deleteMany: {
            args: Prisma.GuideQuestionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GuideQuestionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.GuideQuestionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuideQuestionPayload>[]
          }
          upsert: {
            args: Prisma.GuideQuestionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuideQuestionPayload>
          }
          aggregate: {
            args: Prisma.GuideQuestionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGuideQuestion>
          }
          groupBy: {
            args: Prisma.GuideQuestionGroupByArgs<ExtArgs>
            result: $Utils.Optional<GuideQuestionGroupByOutputType>[]
          }
          count: {
            args: Prisma.GuideQuestionCountArgs<ExtArgs>
            result: $Utils.Optional<GuideQuestionCountAggregateOutputType> | number
          }
        }
      }
      GuideAnswer: {
        payload: Prisma.$GuideAnswerPayload<ExtArgs>
        fields: Prisma.GuideAnswerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GuideAnswerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuideAnswerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GuideAnswerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuideAnswerPayload>
          }
          findFirst: {
            args: Prisma.GuideAnswerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuideAnswerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GuideAnswerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuideAnswerPayload>
          }
          findMany: {
            args: Prisma.GuideAnswerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuideAnswerPayload>[]
          }
          create: {
            args: Prisma.GuideAnswerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuideAnswerPayload>
          }
          createMany: {
            args: Prisma.GuideAnswerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GuideAnswerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuideAnswerPayload>[]
          }
          delete: {
            args: Prisma.GuideAnswerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuideAnswerPayload>
          }
          update: {
            args: Prisma.GuideAnswerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuideAnswerPayload>
          }
          deleteMany: {
            args: Prisma.GuideAnswerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GuideAnswerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.GuideAnswerUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuideAnswerPayload>[]
          }
          upsert: {
            args: Prisma.GuideAnswerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuideAnswerPayload>
          }
          aggregate: {
            args: Prisma.GuideAnswerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGuideAnswer>
          }
          groupBy: {
            args: Prisma.GuideAnswerGroupByArgs<ExtArgs>
            result: $Utils.Optional<GuideAnswerGroupByOutputType>[]
          }
          count: {
            args: Prisma.GuideAnswerCountArgs<ExtArgs>
            result: $Utils.Optional<GuideAnswerCountAggregateOutputType> | number
          }
        }
      }
      ServiceRequest: {
        payload: Prisma.$ServiceRequestPayload<ExtArgs>
        fields: Prisma.ServiceRequestFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ServiceRequestFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceRequestPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ServiceRequestFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceRequestPayload>
          }
          findFirst: {
            args: Prisma.ServiceRequestFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceRequestPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ServiceRequestFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceRequestPayload>
          }
          findMany: {
            args: Prisma.ServiceRequestFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceRequestPayload>[]
          }
          create: {
            args: Prisma.ServiceRequestCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceRequestPayload>
          }
          createMany: {
            args: Prisma.ServiceRequestCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ServiceRequestCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceRequestPayload>[]
          }
          delete: {
            args: Prisma.ServiceRequestDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceRequestPayload>
          }
          update: {
            args: Prisma.ServiceRequestUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceRequestPayload>
          }
          deleteMany: {
            args: Prisma.ServiceRequestDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ServiceRequestUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ServiceRequestUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceRequestPayload>[]
          }
          upsert: {
            args: Prisma.ServiceRequestUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceRequestPayload>
          }
          aggregate: {
            args: Prisma.ServiceRequestAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateServiceRequest>
          }
          groupBy: {
            args: Prisma.ServiceRequestGroupByArgs<ExtArgs>
            result: $Utils.Optional<ServiceRequestGroupByOutputType>[]
          }
          count: {
            args: Prisma.ServiceRequestCountArgs<ExtArgs>
            result: $Utils.Optional<ServiceRequestCountAggregateOutputType> | number
          }
        }
      }
      RequestMedia: {
        payload: Prisma.$RequestMediaPayload<ExtArgs>
        fields: Prisma.RequestMediaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RequestMediaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequestMediaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RequestMediaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequestMediaPayload>
          }
          findFirst: {
            args: Prisma.RequestMediaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequestMediaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RequestMediaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequestMediaPayload>
          }
          findMany: {
            args: Prisma.RequestMediaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequestMediaPayload>[]
          }
          create: {
            args: Prisma.RequestMediaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequestMediaPayload>
          }
          createMany: {
            args: Prisma.RequestMediaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RequestMediaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequestMediaPayload>[]
          }
          delete: {
            args: Prisma.RequestMediaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequestMediaPayload>
          }
          update: {
            args: Prisma.RequestMediaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequestMediaPayload>
          }
          deleteMany: {
            args: Prisma.RequestMediaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RequestMediaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RequestMediaUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequestMediaPayload>[]
          }
          upsert: {
            args: Prisma.RequestMediaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequestMediaPayload>
          }
          aggregate: {
            args: Prisma.RequestMediaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRequestMedia>
          }
          groupBy: {
            args: Prisma.RequestMediaGroupByArgs<ExtArgs>
            result: $Utils.Optional<RequestMediaGroupByOutputType>[]
          }
          count: {
            args: Prisma.RequestMediaCountArgs<ExtArgs>
            result: $Utils.Optional<RequestMediaCountAggregateOutputType> | number
          }
        }
      }
      RequestStatusHistory: {
        payload: Prisma.$RequestStatusHistoryPayload<ExtArgs>
        fields: Prisma.RequestStatusHistoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RequestStatusHistoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequestStatusHistoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RequestStatusHistoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequestStatusHistoryPayload>
          }
          findFirst: {
            args: Prisma.RequestStatusHistoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequestStatusHistoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RequestStatusHistoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequestStatusHistoryPayload>
          }
          findMany: {
            args: Prisma.RequestStatusHistoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequestStatusHistoryPayload>[]
          }
          create: {
            args: Prisma.RequestStatusHistoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequestStatusHistoryPayload>
          }
          createMany: {
            args: Prisma.RequestStatusHistoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RequestStatusHistoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequestStatusHistoryPayload>[]
          }
          delete: {
            args: Prisma.RequestStatusHistoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequestStatusHistoryPayload>
          }
          update: {
            args: Prisma.RequestStatusHistoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequestStatusHistoryPayload>
          }
          deleteMany: {
            args: Prisma.RequestStatusHistoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RequestStatusHistoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RequestStatusHistoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequestStatusHistoryPayload>[]
          }
          upsert: {
            args: Prisma.RequestStatusHistoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequestStatusHistoryPayload>
          }
          aggregate: {
            args: Prisma.RequestStatusHistoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRequestStatusHistory>
          }
          groupBy: {
            args: Prisma.RequestStatusHistoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<RequestStatusHistoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.RequestStatusHistoryCountArgs<ExtArgs>
            result: $Utils.Optional<RequestStatusHistoryCountAggregateOutputType> | number
          }
        }
      }
      Workshop: {
        payload: Prisma.$WorkshopPayload<ExtArgs>
        fields: Prisma.WorkshopFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WorkshopFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkshopPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WorkshopFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkshopPayload>
          }
          findFirst: {
            args: Prisma.WorkshopFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkshopPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WorkshopFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkshopPayload>
          }
          findMany: {
            args: Prisma.WorkshopFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkshopPayload>[]
          }
          create: {
            args: Prisma.WorkshopCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkshopPayload>
          }
          createMany: {
            args: Prisma.WorkshopCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WorkshopCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkshopPayload>[]
          }
          delete: {
            args: Prisma.WorkshopDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkshopPayload>
          }
          update: {
            args: Prisma.WorkshopUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkshopPayload>
          }
          deleteMany: {
            args: Prisma.WorkshopDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WorkshopUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.WorkshopUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkshopPayload>[]
          }
          upsert: {
            args: Prisma.WorkshopUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkshopPayload>
          }
          aggregate: {
            args: Prisma.WorkshopAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWorkshop>
          }
          groupBy: {
            args: Prisma.WorkshopGroupByArgs<ExtArgs>
            result: $Utils.Optional<WorkshopGroupByOutputType>[]
          }
          count: {
            args: Prisma.WorkshopCountArgs<ExtArgs>
            result: $Utils.Optional<WorkshopCountAggregateOutputType> | number
          }
        }
      }
      WorkshopCategory: {
        payload: Prisma.$WorkshopCategoryPayload<ExtArgs>
        fields: Prisma.WorkshopCategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WorkshopCategoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkshopCategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WorkshopCategoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkshopCategoryPayload>
          }
          findFirst: {
            args: Prisma.WorkshopCategoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkshopCategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WorkshopCategoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkshopCategoryPayload>
          }
          findMany: {
            args: Prisma.WorkshopCategoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkshopCategoryPayload>[]
          }
          create: {
            args: Prisma.WorkshopCategoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkshopCategoryPayload>
          }
          createMany: {
            args: Prisma.WorkshopCategoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WorkshopCategoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkshopCategoryPayload>[]
          }
          delete: {
            args: Prisma.WorkshopCategoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkshopCategoryPayload>
          }
          update: {
            args: Prisma.WorkshopCategoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkshopCategoryPayload>
          }
          deleteMany: {
            args: Prisma.WorkshopCategoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WorkshopCategoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.WorkshopCategoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkshopCategoryPayload>[]
          }
          upsert: {
            args: Prisma.WorkshopCategoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkshopCategoryPayload>
          }
          aggregate: {
            args: Prisma.WorkshopCategoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWorkshopCategory>
          }
          groupBy: {
            args: Prisma.WorkshopCategoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<WorkshopCategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.WorkshopCategoryCountArgs<ExtArgs>
            result: $Utils.Optional<WorkshopCategoryCountAggregateOutputType> | number
          }
        }
      }
      WorkshopVerification: {
        payload: Prisma.$WorkshopVerificationPayload<ExtArgs>
        fields: Prisma.WorkshopVerificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WorkshopVerificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkshopVerificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WorkshopVerificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkshopVerificationPayload>
          }
          findFirst: {
            args: Prisma.WorkshopVerificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkshopVerificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WorkshopVerificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkshopVerificationPayload>
          }
          findMany: {
            args: Prisma.WorkshopVerificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkshopVerificationPayload>[]
          }
          create: {
            args: Prisma.WorkshopVerificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkshopVerificationPayload>
          }
          createMany: {
            args: Prisma.WorkshopVerificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WorkshopVerificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkshopVerificationPayload>[]
          }
          delete: {
            args: Prisma.WorkshopVerificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkshopVerificationPayload>
          }
          update: {
            args: Prisma.WorkshopVerificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkshopVerificationPayload>
          }
          deleteMany: {
            args: Prisma.WorkshopVerificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WorkshopVerificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.WorkshopVerificationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkshopVerificationPayload>[]
          }
          upsert: {
            args: Prisma.WorkshopVerificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkshopVerificationPayload>
          }
          aggregate: {
            args: Prisma.WorkshopVerificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWorkshopVerification>
          }
          groupBy: {
            args: Prisma.WorkshopVerificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<WorkshopVerificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.WorkshopVerificationCountArgs<ExtArgs>
            result: $Utils.Optional<WorkshopVerificationCountAggregateOutputType> | number
          }
        }
      }
      Quote: {
        payload: Prisma.$QuotePayload<ExtArgs>
        fields: Prisma.QuoteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.QuoteFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.QuoteFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotePayload>
          }
          findFirst: {
            args: Prisma.QuoteFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.QuoteFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotePayload>
          }
          findMany: {
            args: Prisma.QuoteFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotePayload>[]
          }
          create: {
            args: Prisma.QuoteCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotePayload>
          }
          createMany: {
            args: Prisma.QuoteCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.QuoteCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotePayload>[]
          }
          delete: {
            args: Prisma.QuoteDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotePayload>
          }
          update: {
            args: Prisma.QuoteUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotePayload>
          }
          deleteMany: {
            args: Prisma.QuoteDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.QuoteUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.QuoteUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotePayload>[]
          }
          upsert: {
            args: Prisma.QuoteUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotePayload>
          }
          aggregate: {
            args: Prisma.QuoteAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQuote>
          }
          groupBy: {
            args: Prisma.QuoteGroupByArgs<ExtArgs>
            result: $Utils.Optional<QuoteGroupByOutputType>[]
          }
          count: {
            args: Prisma.QuoteCountArgs<ExtArgs>
            result: $Utils.Optional<QuoteCountAggregateOutputType> | number
          }
        }
      }
      QuotePartItem: {
        payload: Prisma.$QuotePartItemPayload<ExtArgs>
        fields: Prisma.QuotePartItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.QuotePartItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotePartItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.QuotePartItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotePartItemPayload>
          }
          findFirst: {
            args: Prisma.QuotePartItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotePartItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.QuotePartItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotePartItemPayload>
          }
          findMany: {
            args: Prisma.QuotePartItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotePartItemPayload>[]
          }
          create: {
            args: Prisma.QuotePartItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotePartItemPayload>
          }
          createMany: {
            args: Prisma.QuotePartItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.QuotePartItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotePartItemPayload>[]
          }
          delete: {
            args: Prisma.QuotePartItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotePartItemPayload>
          }
          update: {
            args: Prisma.QuotePartItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotePartItemPayload>
          }
          deleteMany: {
            args: Prisma.QuotePartItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.QuotePartItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.QuotePartItemUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotePartItemPayload>[]
          }
          upsert: {
            args: Prisma.QuotePartItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotePartItemPayload>
          }
          aggregate: {
            args: Prisma.QuotePartItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQuotePartItem>
          }
          groupBy: {
            args: Prisma.QuotePartItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<QuotePartItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.QuotePartItemCountArgs<ExtArgs>
            result: $Utils.Optional<QuotePartItemCountAggregateOutputType> | number
          }
        }
      }
      WorkOrder: {
        payload: Prisma.$WorkOrderPayload<ExtArgs>
        fields: Prisma.WorkOrderFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WorkOrderFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkOrderPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WorkOrderFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkOrderPayload>
          }
          findFirst: {
            args: Prisma.WorkOrderFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkOrderPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WorkOrderFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkOrderPayload>
          }
          findMany: {
            args: Prisma.WorkOrderFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkOrderPayload>[]
          }
          create: {
            args: Prisma.WorkOrderCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkOrderPayload>
          }
          createMany: {
            args: Prisma.WorkOrderCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WorkOrderCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkOrderPayload>[]
          }
          delete: {
            args: Prisma.WorkOrderDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkOrderPayload>
          }
          update: {
            args: Prisma.WorkOrderUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkOrderPayload>
          }
          deleteMany: {
            args: Prisma.WorkOrderDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WorkOrderUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.WorkOrderUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkOrderPayload>[]
          }
          upsert: {
            args: Prisma.WorkOrderUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkOrderPayload>
          }
          aggregate: {
            args: Prisma.WorkOrderAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWorkOrder>
          }
          groupBy: {
            args: Prisma.WorkOrderGroupByArgs<ExtArgs>
            result: $Utils.Optional<WorkOrderGroupByOutputType>[]
          }
          count: {
            args: Prisma.WorkOrderCountArgs<ExtArgs>
            result: $Utils.Optional<WorkOrderCountAggregateOutputType> | number
          }
        }
      }
      ChangeRequest: {
        payload: Prisma.$ChangeRequestPayload<ExtArgs>
        fields: Prisma.ChangeRequestFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ChangeRequestFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChangeRequestPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ChangeRequestFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChangeRequestPayload>
          }
          findFirst: {
            args: Prisma.ChangeRequestFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChangeRequestPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ChangeRequestFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChangeRequestPayload>
          }
          findMany: {
            args: Prisma.ChangeRequestFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChangeRequestPayload>[]
          }
          create: {
            args: Prisma.ChangeRequestCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChangeRequestPayload>
          }
          createMany: {
            args: Prisma.ChangeRequestCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ChangeRequestCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChangeRequestPayload>[]
          }
          delete: {
            args: Prisma.ChangeRequestDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChangeRequestPayload>
          }
          update: {
            args: Prisma.ChangeRequestUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChangeRequestPayload>
          }
          deleteMany: {
            args: Prisma.ChangeRequestDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ChangeRequestUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ChangeRequestUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChangeRequestPayload>[]
          }
          upsert: {
            args: Prisma.ChangeRequestUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChangeRequestPayload>
          }
          aggregate: {
            args: Prisma.ChangeRequestAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChangeRequest>
          }
          groupBy: {
            args: Prisma.ChangeRequestGroupByArgs<ExtArgs>
            result: $Utils.Optional<ChangeRequestGroupByOutputType>[]
          }
          count: {
            args: Prisma.ChangeRequestCountArgs<ExtArgs>
            result: $Utils.Optional<ChangeRequestCountAggregateOutputType> | number
          }
        }
      }
      Evidence: {
        payload: Prisma.$EvidencePayload<ExtArgs>
        fields: Prisma.EvidenceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EvidenceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvidencePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EvidenceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvidencePayload>
          }
          findFirst: {
            args: Prisma.EvidenceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvidencePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EvidenceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvidencePayload>
          }
          findMany: {
            args: Prisma.EvidenceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvidencePayload>[]
          }
          create: {
            args: Prisma.EvidenceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvidencePayload>
          }
          createMany: {
            args: Prisma.EvidenceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EvidenceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvidencePayload>[]
          }
          delete: {
            args: Prisma.EvidenceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvidencePayload>
          }
          update: {
            args: Prisma.EvidenceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvidencePayload>
          }
          deleteMany: {
            args: Prisma.EvidenceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EvidenceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EvidenceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvidencePayload>[]
          }
          upsert: {
            args: Prisma.EvidenceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvidencePayload>
          }
          aggregate: {
            args: Prisma.EvidenceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEvidence>
          }
          groupBy: {
            args: Prisma.EvidenceGroupByArgs<ExtArgs>
            result: $Utils.Optional<EvidenceGroupByOutputType>[]
          }
          count: {
            args: Prisma.EvidenceCountArgs<ExtArgs>
            result: $Utils.Optional<EvidenceCountAggregateOutputType> | number
          }
        }
      }
      Review: {
        payload: Prisma.$ReviewPayload<ExtArgs>
        fields: Prisma.ReviewFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReviewFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReviewFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          findFirst: {
            args: Prisma.ReviewFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReviewFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          findMany: {
            args: Prisma.ReviewFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>[]
          }
          create: {
            args: Prisma.ReviewCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          createMany: {
            args: Prisma.ReviewCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ReviewCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>[]
          }
          delete: {
            args: Prisma.ReviewDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          update: {
            args: Prisma.ReviewUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          deleteMany: {
            args: Prisma.ReviewDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReviewUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ReviewUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>[]
          }
          upsert: {
            args: Prisma.ReviewUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          aggregate: {
            args: Prisma.ReviewAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReview>
          }
          groupBy: {
            args: Prisma.ReviewGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReviewGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReviewCountArgs<ExtArgs>
            result: $Utils.Optional<ReviewCountAggregateOutputType> | number
          }
        }
      }
      Receipt: {
        payload: Prisma.$ReceiptPayload<ExtArgs>
        fields: Prisma.ReceiptFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReceiptFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReceiptPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReceiptFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReceiptPayload>
          }
          findFirst: {
            args: Prisma.ReceiptFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReceiptPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReceiptFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReceiptPayload>
          }
          findMany: {
            args: Prisma.ReceiptFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReceiptPayload>[]
          }
          create: {
            args: Prisma.ReceiptCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReceiptPayload>
          }
          createMany: {
            args: Prisma.ReceiptCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ReceiptCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReceiptPayload>[]
          }
          delete: {
            args: Prisma.ReceiptDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReceiptPayload>
          }
          update: {
            args: Prisma.ReceiptUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReceiptPayload>
          }
          deleteMany: {
            args: Prisma.ReceiptDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReceiptUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ReceiptUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReceiptPayload>[]
          }
          upsert: {
            args: Prisma.ReceiptUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReceiptPayload>
          }
          aggregate: {
            args: Prisma.ReceiptAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReceipt>
          }
          groupBy: {
            args: Prisma.ReceiptGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReceiptGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReceiptCountArgs<ExtArgs>
            result: $Utils.Optional<ReceiptCountAggregateOutputType> | number
          }
        }
      }
      IncidentReport: {
        payload: Prisma.$IncidentReportPayload<ExtArgs>
        fields: Prisma.IncidentReportFieldRefs
        operations: {
          findUnique: {
            args: Prisma.IncidentReportFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncidentReportPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.IncidentReportFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncidentReportPayload>
          }
          findFirst: {
            args: Prisma.IncidentReportFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncidentReportPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.IncidentReportFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncidentReportPayload>
          }
          findMany: {
            args: Prisma.IncidentReportFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncidentReportPayload>[]
          }
          create: {
            args: Prisma.IncidentReportCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncidentReportPayload>
          }
          createMany: {
            args: Prisma.IncidentReportCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.IncidentReportCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncidentReportPayload>[]
          }
          delete: {
            args: Prisma.IncidentReportDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncidentReportPayload>
          }
          update: {
            args: Prisma.IncidentReportUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncidentReportPayload>
          }
          deleteMany: {
            args: Prisma.IncidentReportDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.IncidentReportUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.IncidentReportUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncidentReportPayload>[]
          }
          upsert: {
            args: Prisma.IncidentReportUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncidentReportPayload>
          }
          aggregate: {
            args: Prisma.IncidentReportAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateIncidentReport>
          }
          groupBy: {
            args: Prisma.IncidentReportGroupByArgs<ExtArgs>
            result: $Utils.Optional<IncidentReportGroupByOutputType>[]
          }
          count: {
            args: Prisma.IncidentReportCountArgs<ExtArgs>
            result: $Utils.Optional<IncidentReportCountAggregateOutputType> | number
          }
        }
      }
      ChatMessage: {
        payload: Prisma.$ChatMessagePayload<ExtArgs>
        fields: Prisma.ChatMessageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ChatMessageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMessagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ChatMessageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMessagePayload>
          }
          findFirst: {
            args: Prisma.ChatMessageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMessagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ChatMessageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMessagePayload>
          }
          findMany: {
            args: Prisma.ChatMessageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMessagePayload>[]
          }
          create: {
            args: Prisma.ChatMessageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMessagePayload>
          }
          createMany: {
            args: Prisma.ChatMessageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ChatMessageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMessagePayload>[]
          }
          delete: {
            args: Prisma.ChatMessageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMessagePayload>
          }
          update: {
            args: Prisma.ChatMessageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMessagePayload>
          }
          deleteMany: {
            args: Prisma.ChatMessageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ChatMessageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ChatMessageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMessagePayload>[]
          }
          upsert: {
            args: Prisma.ChatMessageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMessagePayload>
          }
          aggregate: {
            args: Prisma.ChatMessageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChatMessage>
          }
          groupBy: {
            args: Prisma.ChatMessageGroupByArgs<ExtArgs>
            result: $Utils.Optional<ChatMessageGroupByOutputType>[]
          }
          count: {
            args: Prisma.ChatMessageCountArgs<ExtArgs>
            result: $Utils.Optional<ChatMessageCountAggregateOutputType> | number
          }
        }
      }
      Notification: {
        payload: Prisma.$NotificationPayload<ExtArgs>
        fields: Prisma.NotificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findFirst: {
            args: Prisma.NotificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findMany: {
            args: Prisma.NotificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          create: {
            args: Prisma.NotificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          createMany: {
            args: Prisma.NotificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          delete: {
            args: Prisma.NotificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          update: {
            args: Prisma.NotificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          deleteMany: {
            args: Prisma.NotificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.NotificationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          upsert: {
            args: Prisma.NotificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          aggregate: {
            args: Prisma.NotificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotification>
          }
          groupBy: {
            args: Prisma.NotificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationCountAggregateOutputType> | number
          }
        }
      }
      AuditLog: {
        payload: Prisma.$AuditLogPayload<ExtArgs>
        fields: Prisma.AuditLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AuditLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AuditLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findFirst: {
            args: Prisma.AuditLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AuditLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findMany: {
            args: Prisma.AuditLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          create: {
            args: Prisma.AuditLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          createMany: {
            args: Prisma.AuditLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AuditLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          delete: {
            args: Prisma.AuditLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          update: {
            args: Prisma.AuditLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          deleteMany: {
            args: Prisma.AuditLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AuditLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AuditLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          upsert: {
            args: Prisma.AuditLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          aggregate: {
            args: Prisma.AuditLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAuditLog>
          }
          groupBy: {
            args: Prisma.AuditLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<AuditLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.AuditLogCountArgs<ExtArgs>
            result: $Utils.Optional<AuditLogCountAggregateOutputType> | number
          }
        }
      }
      FeatureFlag: {
        payload: Prisma.$FeatureFlagPayload<ExtArgs>
        fields: Prisma.FeatureFlagFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FeatureFlagFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeatureFlagPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FeatureFlagFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeatureFlagPayload>
          }
          findFirst: {
            args: Prisma.FeatureFlagFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeatureFlagPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FeatureFlagFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeatureFlagPayload>
          }
          findMany: {
            args: Prisma.FeatureFlagFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeatureFlagPayload>[]
          }
          create: {
            args: Prisma.FeatureFlagCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeatureFlagPayload>
          }
          createMany: {
            args: Prisma.FeatureFlagCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FeatureFlagCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeatureFlagPayload>[]
          }
          delete: {
            args: Prisma.FeatureFlagDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeatureFlagPayload>
          }
          update: {
            args: Prisma.FeatureFlagUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeatureFlagPayload>
          }
          deleteMany: {
            args: Prisma.FeatureFlagDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FeatureFlagUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FeatureFlagUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeatureFlagPayload>[]
          }
          upsert: {
            args: Prisma.FeatureFlagUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeatureFlagPayload>
          }
          aggregate: {
            args: Prisma.FeatureFlagAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFeatureFlag>
          }
          groupBy: {
            args: Prisma.FeatureFlagGroupByArgs<ExtArgs>
            result: $Utils.Optional<FeatureFlagGroupByOutputType>[]
          }
          count: {
            args: Prisma.FeatureFlagCountArgs<ExtArgs>
            result: $Utils.Optional<FeatureFlagCountAggregateOutputType> | number
          }
        }
      }
      AiSuggestion: {
        payload: Prisma.$AiSuggestionPayload<ExtArgs>
        fields: Prisma.AiSuggestionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AiSuggestionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiSuggestionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AiSuggestionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiSuggestionPayload>
          }
          findFirst: {
            args: Prisma.AiSuggestionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiSuggestionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AiSuggestionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiSuggestionPayload>
          }
          findMany: {
            args: Prisma.AiSuggestionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiSuggestionPayload>[]
          }
          create: {
            args: Prisma.AiSuggestionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiSuggestionPayload>
          }
          createMany: {
            args: Prisma.AiSuggestionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AiSuggestionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiSuggestionPayload>[]
          }
          delete: {
            args: Prisma.AiSuggestionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiSuggestionPayload>
          }
          update: {
            args: Prisma.AiSuggestionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiSuggestionPayload>
          }
          deleteMany: {
            args: Prisma.AiSuggestionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AiSuggestionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AiSuggestionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiSuggestionPayload>[]
          }
          upsert: {
            args: Prisma.AiSuggestionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiSuggestionPayload>
          }
          aggregate: {
            args: Prisma.AiSuggestionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAiSuggestion>
          }
          groupBy: {
            args: Prisma.AiSuggestionGroupByArgs<ExtArgs>
            result: $Utils.Optional<AiSuggestionGroupByOutputType>[]
          }
          count: {
            args: Prisma.AiSuggestionCountArgs<ExtArgs>
            result: $Utils.Optional<AiSuggestionCountAggregateOutputType> | number
          }
        }
      }
      AiQuoteAnalysis: {
        payload: Prisma.$AiQuoteAnalysisPayload<ExtArgs>
        fields: Prisma.AiQuoteAnalysisFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AiQuoteAnalysisFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiQuoteAnalysisPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AiQuoteAnalysisFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiQuoteAnalysisPayload>
          }
          findFirst: {
            args: Prisma.AiQuoteAnalysisFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiQuoteAnalysisPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AiQuoteAnalysisFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiQuoteAnalysisPayload>
          }
          findMany: {
            args: Prisma.AiQuoteAnalysisFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiQuoteAnalysisPayload>[]
          }
          create: {
            args: Prisma.AiQuoteAnalysisCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiQuoteAnalysisPayload>
          }
          createMany: {
            args: Prisma.AiQuoteAnalysisCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AiQuoteAnalysisCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiQuoteAnalysisPayload>[]
          }
          delete: {
            args: Prisma.AiQuoteAnalysisDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiQuoteAnalysisPayload>
          }
          update: {
            args: Prisma.AiQuoteAnalysisUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiQuoteAnalysisPayload>
          }
          deleteMany: {
            args: Prisma.AiQuoteAnalysisDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AiQuoteAnalysisUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AiQuoteAnalysisUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiQuoteAnalysisPayload>[]
          }
          upsert: {
            args: Prisma.AiQuoteAnalysisUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiQuoteAnalysisPayload>
          }
          aggregate: {
            args: Prisma.AiQuoteAnalysisAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAiQuoteAnalysis>
          }
          groupBy: {
            args: Prisma.AiQuoteAnalysisGroupByArgs<ExtArgs>
            result: $Utils.Optional<AiQuoteAnalysisGroupByOutputType>[]
          }
          count: {
            args: Prisma.AiQuoteAnalysisCountArgs<ExtArgs>
            result: $Utils.Optional<AiQuoteAnalysisCountAggregateOutputType> | number
          }
        }
      }
      AppConfig: {
        payload: Prisma.$AppConfigPayload<ExtArgs>
        fields: Prisma.AppConfigFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AppConfigFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppConfigPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AppConfigFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppConfigPayload>
          }
          findFirst: {
            args: Prisma.AppConfigFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppConfigPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AppConfigFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppConfigPayload>
          }
          findMany: {
            args: Prisma.AppConfigFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppConfigPayload>[]
          }
          create: {
            args: Prisma.AppConfigCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppConfigPayload>
          }
          createMany: {
            args: Prisma.AppConfigCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AppConfigCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppConfigPayload>[]
          }
          delete: {
            args: Prisma.AppConfigDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppConfigPayload>
          }
          update: {
            args: Prisma.AppConfigUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppConfigPayload>
          }
          deleteMany: {
            args: Prisma.AppConfigDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AppConfigUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AppConfigUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppConfigPayload>[]
          }
          upsert: {
            args: Prisma.AppConfigUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppConfigPayload>
          }
          aggregate: {
            args: Prisma.AppConfigAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAppConfig>
          }
          groupBy: {
            args: Prisma.AppConfigGroupByArgs<ExtArgs>
            result: $Utils.Optional<AppConfigGroupByOutputType>[]
          }
          count: {
            args: Prisma.AppConfigCountArgs<ExtArgs>
            result: $Utils.Optional<AppConfigCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://pris.ly/d/logging).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory
    /**
     * Prisma Accelerate URL allowing the client to connect through Accelerate instead of a direct database.
     */
    accelerateUrl?: string
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
    /**
     * SQL commenter plugins that add metadata to SQL queries as comments.
     * Comments follow the sqlcommenter format: https://google.github.io/sqlcommenter/
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   adapter,
     *   comments: [
     *     traceContext(),
     *     queryInsights(),
     *   ],
     * })
     * ```
     */
    comments?: runtime.SqlCommenterPlugin[]
  }
  export type GlobalOmitConfig = {
    userProfile?: UserProfileOmit
    motorcycle?: MotorcycleOmit
    category?: CategoryOmit
    guideQuestion?: GuideQuestionOmit
    guideAnswer?: GuideAnswerOmit
    serviceRequest?: ServiceRequestOmit
    requestMedia?: RequestMediaOmit
    requestStatusHistory?: RequestStatusHistoryOmit
    workshop?: WorkshopOmit
    workshopCategory?: WorkshopCategoryOmit
    workshopVerification?: WorkshopVerificationOmit
    quote?: QuoteOmit
    quotePartItem?: QuotePartItemOmit
    workOrder?: WorkOrderOmit
    changeRequest?: ChangeRequestOmit
    evidence?: EvidenceOmit
    review?: ReviewOmit
    receipt?: ReceiptOmit
    incidentReport?: IncidentReportOmit
    chatMessage?: ChatMessageOmit
    notification?: NotificationOmit
    auditLog?: AuditLogOmit
    featureFlag?: FeatureFlagOmit
    aiSuggestion?: AiSuggestionOmit
    aiQuoteAnalysis?: AiQuoteAnalysisOmit
    appConfig?: AppConfigOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserProfileCountOutputType
   */

  export type UserProfileCountOutputType = {
    motorcycles: number
    serviceRequests: number
    reviews: number
    incidentReports: number
    notifications: number
    chatMessages: number
  }

  export type UserProfileCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    motorcycles?: boolean | UserProfileCountOutputTypeCountMotorcyclesArgs
    serviceRequests?: boolean | UserProfileCountOutputTypeCountServiceRequestsArgs
    reviews?: boolean | UserProfileCountOutputTypeCountReviewsArgs
    incidentReports?: boolean | UserProfileCountOutputTypeCountIncidentReportsArgs
    notifications?: boolean | UserProfileCountOutputTypeCountNotificationsArgs
    chatMessages?: boolean | UserProfileCountOutputTypeCountChatMessagesArgs
  }

  // Custom InputTypes
  /**
   * UserProfileCountOutputType without action
   */
  export type UserProfileCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfileCountOutputType
     */
    select?: UserProfileCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserProfileCountOutputType without action
   */
  export type UserProfileCountOutputTypeCountMotorcyclesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MotorcycleWhereInput
  }

  /**
   * UserProfileCountOutputType without action
   */
  export type UserProfileCountOutputTypeCountServiceRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceRequestWhereInput
  }

  /**
   * UserProfileCountOutputType without action
   */
  export type UserProfileCountOutputTypeCountReviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReviewWhereInput
  }

  /**
   * UserProfileCountOutputType without action
   */
  export type UserProfileCountOutputTypeCountIncidentReportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IncidentReportWhereInput
  }

  /**
   * UserProfileCountOutputType without action
   */
  export type UserProfileCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }

  /**
   * UserProfileCountOutputType without action
   */
  export type UserProfileCountOutputTypeCountChatMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChatMessageWhereInput
  }


  /**
   * Count Type MotorcycleCountOutputType
   */

  export type MotorcycleCountOutputType = {
    serviceRequests: number
  }

  export type MotorcycleCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    serviceRequests?: boolean | MotorcycleCountOutputTypeCountServiceRequestsArgs
  }

  // Custom InputTypes
  /**
   * MotorcycleCountOutputType without action
   */
  export type MotorcycleCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MotorcycleCountOutputType
     */
    select?: MotorcycleCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MotorcycleCountOutputType without action
   */
  export type MotorcycleCountOutputTypeCountServiceRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceRequestWhereInput
  }


  /**
   * Count Type CategoryCountOutputType
   */

  export type CategoryCountOutputType = {
    children: number
    guideQuestions: number
    serviceRequests: number
    workshopCategories: number
  }

  export type CategoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    children?: boolean | CategoryCountOutputTypeCountChildrenArgs
    guideQuestions?: boolean | CategoryCountOutputTypeCountGuideQuestionsArgs
    serviceRequests?: boolean | CategoryCountOutputTypeCountServiceRequestsArgs
    workshopCategories?: boolean | CategoryCountOutputTypeCountWorkshopCategoriesArgs
  }

  // Custom InputTypes
  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoryCountOutputType
     */
    select?: CategoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeCountChildrenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CategoryWhereInput
  }

  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeCountGuideQuestionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GuideQuestionWhereInput
  }

  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeCountServiceRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceRequestWhereInput
  }

  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeCountWorkshopCategoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkshopCategoryWhereInput
  }


  /**
   * Count Type GuideQuestionCountOutputType
   */

  export type GuideQuestionCountOutputType = {
    answers: number
  }

  export type GuideQuestionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    answers?: boolean | GuideQuestionCountOutputTypeCountAnswersArgs
  }

  // Custom InputTypes
  /**
   * GuideQuestionCountOutputType without action
   */
  export type GuideQuestionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuideQuestionCountOutputType
     */
    select?: GuideQuestionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * GuideQuestionCountOutputType without action
   */
  export type GuideQuestionCountOutputTypeCountAnswersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GuideAnswerWhereInput
  }


  /**
   * Count Type ServiceRequestCountOutputType
   */

  export type ServiceRequestCountOutputType = {
    media: number
    guideAnswers: number
    quotes: number
    statusHistory: number
    notifications: number
    chatMessages: number
    aiSuggestions: number
  }

  export type ServiceRequestCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    media?: boolean | ServiceRequestCountOutputTypeCountMediaArgs
    guideAnswers?: boolean | ServiceRequestCountOutputTypeCountGuideAnswersArgs
    quotes?: boolean | ServiceRequestCountOutputTypeCountQuotesArgs
    statusHistory?: boolean | ServiceRequestCountOutputTypeCountStatusHistoryArgs
    notifications?: boolean | ServiceRequestCountOutputTypeCountNotificationsArgs
    chatMessages?: boolean | ServiceRequestCountOutputTypeCountChatMessagesArgs
    aiSuggestions?: boolean | ServiceRequestCountOutputTypeCountAiSuggestionsArgs
  }

  // Custom InputTypes
  /**
   * ServiceRequestCountOutputType without action
   */
  export type ServiceRequestCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceRequestCountOutputType
     */
    select?: ServiceRequestCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ServiceRequestCountOutputType without action
   */
  export type ServiceRequestCountOutputTypeCountMediaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RequestMediaWhereInput
  }

  /**
   * ServiceRequestCountOutputType without action
   */
  export type ServiceRequestCountOutputTypeCountGuideAnswersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GuideAnswerWhereInput
  }

  /**
   * ServiceRequestCountOutputType without action
   */
  export type ServiceRequestCountOutputTypeCountQuotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuoteWhereInput
  }

  /**
   * ServiceRequestCountOutputType without action
   */
  export type ServiceRequestCountOutputTypeCountStatusHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RequestStatusHistoryWhereInput
  }

  /**
   * ServiceRequestCountOutputType without action
   */
  export type ServiceRequestCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }

  /**
   * ServiceRequestCountOutputType without action
   */
  export type ServiceRequestCountOutputTypeCountChatMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChatMessageWhereInput
  }

  /**
   * ServiceRequestCountOutputType without action
   */
  export type ServiceRequestCountOutputTypeCountAiSuggestionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AiSuggestionWhereInput
  }


  /**
   * Count Type WorkshopCountOutputType
   */

  export type WorkshopCountOutputType = {
    categories: number
    quotes: number
    workOrders: number
    reviews: number
    incidentReports: number
    verifications: number
  }

  export type WorkshopCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    categories?: boolean | WorkshopCountOutputTypeCountCategoriesArgs
    quotes?: boolean | WorkshopCountOutputTypeCountQuotesArgs
    workOrders?: boolean | WorkshopCountOutputTypeCountWorkOrdersArgs
    reviews?: boolean | WorkshopCountOutputTypeCountReviewsArgs
    incidentReports?: boolean | WorkshopCountOutputTypeCountIncidentReportsArgs
    verifications?: boolean | WorkshopCountOutputTypeCountVerificationsArgs
  }

  // Custom InputTypes
  /**
   * WorkshopCountOutputType without action
   */
  export type WorkshopCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkshopCountOutputType
     */
    select?: WorkshopCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * WorkshopCountOutputType without action
   */
  export type WorkshopCountOutputTypeCountCategoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkshopCategoryWhereInput
  }

  /**
   * WorkshopCountOutputType without action
   */
  export type WorkshopCountOutputTypeCountQuotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuoteWhereInput
  }

  /**
   * WorkshopCountOutputType without action
   */
  export type WorkshopCountOutputTypeCountWorkOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkOrderWhereInput
  }

  /**
   * WorkshopCountOutputType without action
   */
  export type WorkshopCountOutputTypeCountReviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReviewWhereInput
  }

  /**
   * WorkshopCountOutputType without action
   */
  export type WorkshopCountOutputTypeCountIncidentReportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IncidentReportWhereInput
  }

  /**
   * WorkshopCountOutputType without action
   */
  export type WorkshopCountOutputTypeCountVerificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkshopVerificationWhereInput
  }


  /**
   * Count Type QuoteCountOutputType
   */

  export type QuoteCountOutputType = {
    parts: number
    aiAnalysis: number
  }

  export type QuoteCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parts?: boolean | QuoteCountOutputTypeCountPartsArgs
    aiAnalysis?: boolean | QuoteCountOutputTypeCountAiAnalysisArgs
  }

  // Custom InputTypes
  /**
   * QuoteCountOutputType without action
   */
  export type QuoteCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuoteCountOutputType
     */
    select?: QuoteCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * QuoteCountOutputType without action
   */
  export type QuoteCountOutputTypeCountPartsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuotePartItemWhereInput
  }

  /**
   * QuoteCountOutputType without action
   */
  export type QuoteCountOutputTypeCountAiAnalysisArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AiQuoteAnalysisWhereInput
  }


  /**
   * Count Type WorkOrderCountOutputType
   */

  export type WorkOrderCountOutputType = {
    changeRequests: number
    evidences: number
  }

  export type WorkOrderCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    changeRequests?: boolean | WorkOrderCountOutputTypeCountChangeRequestsArgs
    evidences?: boolean | WorkOrderCountOutputTypeCountEvidencesArgs
  }

  // Custom InputTypes
  /**
   * WorkOrderCountOutputType without action
   */
  export type WorkOrderCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkOrderCountOutputType
     */
    select?: WorkOrderCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * WorkOrderCountOutputType without action
   */
  export type WorkOrderCountOutputTypeCountChangeRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChangeRequestWhereInput
  }

  /**
   * WorkOrderCountOutputType without action
   */
  export type WorkOrderCountOutputTypeCountEvidencesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EvidenceWhereInput
  }


  /**
   * Models
   */

  /**
   * Model UserProfile
   */

  export type AggregateUserProfile = {
    _count: UserProfileCountAggregateOutputType | null
    _min: UserProfileMinAggregateOutputType | null
    _max: UserProfileMaxAggregateOutputType | null
  }

  export type UserProfileMinAggregateOutputType = {
    id: string | null
    clerkUserId: string | null
    role: $Enums.UserRole | null
    email: string | null
    phone: string | null
    name: string | null
    district: string | null
    avatarUrl: string | null
    notifChannel: $Enums.NotificationChannel | null
    phoneVisible: boolean | null
    termsAccepted: boolean | null
    termsVersion: string | null
    termsAcceptedAt: Date | null
    privacyAccepted: boolean | null
    privacyVersion: string | null
    privacyAcceptedAt: Date | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserProfileMaxAggregateOutputType = {
    id: string | null
    clerkUserId: string | null
    role: $Enums.UserRole | null
    email: string | null
    phone: string | null
    name: string | null
    district: string | null
    avatarUrl: string | null
    notifChannel: $Enums.NotificationChannel | null
    phoneVisible: boolean | null
    termsAccepted: boolean | null
    termsVersion: string | null
    termsAcceptedAt: Date | null
    privacyAccepted: boolean | null
    privacyVersion: string | null
    privacyAcceptedAt: Date | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserProfileCountAggregateOutputType = {
    id: number
    clerkUserId: number
    role: number
    email: number
    phone: number
    name: number
    district: number
    avatarUrl: number
    notifChannel: number
    phoneVisible: number
    termsAccepted: number
    termsVersion: number
    termsAcceptedAt: number
    privacyAccepted: number
    privacyVersion: number
    privacyAcceptedAt: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserProfileMinAggregateInputType = {
    id?: true
    clerkUserId?: true
    role?: true
    email?: true
    phone?: true
    name?: true
    district?: true
    avatarUrl?: true
    notifChannel?: true
    phoneVisible?: true
    termsAccepted?: true
    termsVersion?: true
    termsAcceptedAt?: true
    privacyAccepted?: true
    privacyVersion?: true
    privacyAcceptedAt?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserProfileMaxAggregateInputType = {
    id?: true
    clerkUserId?: true
    role?: true
    email?: true
    phone?: true
    name?: true
    district?: true
    avatarUrl?: true
    notifChannel?: true
    phoneVisible?: true
    termsAccepted?: true
    termsVersion?: true
    termsAcceptedAt?: true
    privacyAccepted?: true
    privacyVersion?: true
    privacyAcceptedAt?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserProfileCountAggregateInputType = {
    id?: true
    clerkUserId?: true
    role?: true
    email?: true
    phone?: true
    name?: true
    district?: true
    avatarUrl?: true
    notifChannel?: true
    phoneVisible?: true
    termsAccepted?: true
    termsVersion?: true
    termsAcceptedAt?: true
    privacyAccepted?: true
    privacyVersion?: true
    privacyAcceptedAt?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserProfileAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserProfile to aggregate.
     */
    where?: UserProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserProfiles to fetch.
     */
    orderBy?: UserProfileOrderByWithRelationInput | UserProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserProfiles
    **/
    _count?: true | UserProfileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserProfileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserProfileMaxAggregateInputType
  }

  export type GetUserProfileAggregateType<T extends UserProfileAggregateArgs> = {
        [P in keyof T & keyof AggregateUserProfile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserProfile[P]>
      : GetScalarType<T[P], AggregateUserProfile[P]>
  }




  export type UserProfileGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserProfileWhereInput
    orderBy?: UserProfileOrderByWithAggregationInput | UserProfileOrderByWithAggregationInput[]
    by: UserProfileScalarFieldEnum[] | UserProfileScalarFieldEnum
    having?: UserProfileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserProfileCountAggregateInputType | true
    _min?: UserProfileMinAggregateInputType
    _max?: UserProfileMaxAggregateInputType
  }

  export type UserProfileGroupByOutputType = {
    id: string
    clerkUserId: string
    role: $Enums.UserRole
    email: string | null
    phone: string | null
    name: string | null
    district: string | null
    avatarUrl: string | null
    notifChannel: $Enums.NotificationChannel
    phoneVisible: boolean
    termsAccepted: boolean
    termsVersion: string | null
    termsAcceptedAt: Date | null
    privacyAccepted: boolean
    privacyVersion: string | null
    privacyAcceptedAt: Date | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: UserProfileCountAggregateOutputType | null
    _min: UserProfileMinAggregateOutputType | null
    _max: UserProfileMaxAggregateOutputType | null
  }

  type GetUserProfileGroupByPayload<T extends UserProfileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserProfileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserProfileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserProfileGroupByOutputType[P]>
            : GetScalarType<T[P], UserProfileGroupByOutputType[P]>
        }
      >
    >


  export type UserProfileSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clerkUserId?: boolean
    role?: boolean
    email?: boolean
    phone?: boolean
    name?: boolean
    district?: boolean
    avatarUrl?: boolean
    notifChannel?: boolean
    phoneVisible?: boolean
    termsAccepted?: boolean
    termsVersion?: boolean
    termsAcceptedAt?: boolean
    privacyAccepted?: boolean
    privacyVersion?: boolean
    privacyAcceptedAt?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    motorcycles?: boolean | UserProfile$motorcyclesArgs<ExtArgs>
    serviceRequests?: boolean | UserProfile$serviceRequestsArgs<ExtArgs>
    reviews?: boolean | UserProfile$reviewsArgs<ExtArgs>
    incidentReports?: boolean | UserProfile$incidentReportsArgs<ExtArgs>
    notifications?: boolean | UserProfile$notificationsArgs<ExtArgs>
    chatMessages?: boolean | UserProfile$chatMessagesArgs<ExtArgs>
    workshop?: boolean | UserProfile$workshopArgs<ExtArgs>
    _count?: boolean | UserProfileCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userProfile"]>

  export type UserProfileSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clerkUserId?: boolean
    role?: boolean
    email?: boolean
    phone?: boolean
    name?: boolean
    district?: boolean
    avatarUrl?: boolean
    notifChannel?: boolean
    phoneVisible?: boolean
    termsAccepted?: boolean
    termsVersion?: boolean
    termsAcceptedAt?: boolean
    privacyAccepted?: boolean
    privacyVersion?: boolean
    privacyAcceptedAt?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["userProfile"]>

  export type UserProfileSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clerkUserId?: boolean
    role?: boolean
    email?: boolean
    phone?: boolean
    name?: boolean
    district?: boolean
    avatarUrl?: boolean
    notifChannel?: boolean
    phoneVisible?: boolean
    termsAccepted?: boolean
    termsVersion?: boolean
    termsAcceptedAt?: boolean
    privacyAccepted?: boolean
    privacyVersion?: boolean
    privacyAcceptedAt?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["userProfile"]>

  export type UserProfileSelectScalar = {
    id?: boolean
    clerkUserId?: boolean
    role?: boolean
    email?: boolean
    phone?: boolean
    name?: boolean
    district?: boolean
    avatarUrl?: boolean
    notifChannel?: boolean
    phoneVisible?: boolean
    termsAccepted?: boolean
    termsVersion?: boolean
    termsAcceptedAt?: boolean
    privacyAccepted?: boolean
    privacyVersion?: boolean
    privacyAcceptedAt?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserProfileOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "clerkUserId" | "role" | "email" | "phone" | "name" | "district" | "avatarUrl" | "notifChannel" | "phoneVisible" | "termsAccepted" | "termsVersion" | "termsAcceptedAt" | "privacyAccepted" | "privacyVersion" | "privacyAcceptedAt" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["userProfile"]>
  export type UserProfileInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    motorcycles?: boolean | UserProfile$motorcyclesArgs<ExtArgs>
    serviceRequests?: boolean | UserProfile$serviceRequestsArgs<ExtArgs>
    reviews?: boolean | UserProfile$reviewsArgs<ExtArgs>
    incidentReports?: boolean | UserProfile$incidentReportsArgs<ExtArgs>
    notifications?: boolean | UserProfile$notificationsArgs<ExtArgs>
    chatMessages?: boolean | UserProfile$chatMessagesArgs<ExtArgs>
    workshop?: boolean | UserProfile$workshopArgs<ExtArgs>
    _count?: boolean | UserProfileCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserProfileIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserProfileIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserProfilePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserProfile"
    objects: {
      motorcycles: Prisma.$MotorcyclePayload<ExtArgs>[]
      serviceRequests: Prisma.$ServiceRequestPayload<ExtArgs>[]
      reviews: Prisma.$ReviewPayload<ExtArgs>[]
      incidentReports: Prisma.$IncidentReportPayload<ExtArgs>[]
      notifications: Prisma.$NotificationPayload<ExtArgs>[]
      chatMessages: Prisma.$ChatMessagePayload<ExtArgs>[]
      workshop: Prisma.$WorkshopPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      clerkUserId: string
      role: $Enums.UserRole
      email: string | null
      phone: string | null
      name: string | null
      district: string | null
      avatarUrl: string | null
      notifChannel: $Enums.NotificationChannel
      phoneVisible: boolean
      termsAccepted: boolean
      termsVersion: string | null
      termsAcceptedAt: Date | null
      privacyAccepted: boolean
      privacyVersion: string | null
      privacyAcceptedAt: Date | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["userProfile"]>
    composites: {}
  }

  type UserProfileGetPayload<S extends boolean | null | undefined | UserProfileDefaultArgs> = $Result.GetResult<Prisma.$UserProfilePayload, S>

  type UserProfileCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserProfileFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserProfileCountAggregateInputType | true
    }

  export interface UserProfileDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserProfile'], meta: { name: 'UserProfile' } }
    /**
     * Find zero or one UserProfile that matches the filter.
     * @param {UserProfileFindUniqueArgs} args - Arguments to find a UserProfile
     * @example
     * // Get one UserProfile
     * const userProfile = await prisma.userProfile.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserProfileFindUniqueArgs>(args: SelectSubset<T, UserProfileFindUniqueArgs<ExtArgs>>): Prisma__UserProfileClient<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserProfile that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserProfileFindUniqueOrThrowArgs} args - Arguments to find a UserProfile
     * @example
     * // Get one UserProfile
     * const userProfile = await prisma.userProfile.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserProfileFindUniqueOrThrowArgs>(args: SelectSubset<T, UserProfileFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserProfileClient<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserProfile that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProfileFindFirstArgs} args - Arguments to find a UserProfile
     * @example
     * // Get one UserProfile
     * const userProfile = await prisma.userProfile.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserProfileFindFirstArgs>(args?: SelectSubset<T, UserProfileFindFirstArgs<ExtArgs>>): Prisma__UserProfileClient<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserProfile that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProfileFindFirstOrThrowArgs} args - Arguments to find a UserProfile
     * @example
     * // Get one UserProfile
     * const userProfile = await prisma.userProfile.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserProfileFindFirstOrThrowArgs>(args?: SelectSubset<T, UserProfileFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserProfileClient<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserProfiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProfileFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserProfiles
     * const userProfiles = await prisma.userProfile.findMany()
     * 
     * // Get first 10 UserProfiles
     * const userProfiles = await prisma.userProfile.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userProfileWithIdOnly = await prisma.userProfile.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserProfileFindManyArgs>(args?: SelectSubset<T, UserProfileFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserProfile.
     * @param {UserProfileCreateArgs} args - Arguments to create a UserProfile.
     * @example
     * // Create one UserProfile
     * const UserProfile = await prisma.userProfile.create({
     *   data: {
     *     // ... data to create a UserProfile
     *   }
     * })
     * 
     */
    create<T extends UserProfileCreateArgs>(args: SelectSubset<T, UserProfileCreateArgs<ExtArgs>>): Prisma__UserProfileClient<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserProfiles.
     * @param {UserProfileCreateManyArgs} args - Arguments to create many UserProfiles.
     * @example
     * // Create many UserProfiles
     * const userProfile = await prisma.userProfile.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserProfileCreateManyArgs>(args?: SelectSubset<T, UserProfileCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserProfiles and returns the data saved in the database.
     * @param {UserProfileCreateManyAndReturnArgs} args - Arguments to create many UserProfiles.
     * @example
     * // Create many UserProfiles
     * const userProfile = await prisma.userProfile.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserProfiles and only return the `id`
     * const userProfileWithIdOnly = await prisma.userProfile.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserProfileCreateManyAndReturnArgs>(args?: SelectSubset<T, UserProfileCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserProfile.
     * @param {UserProfileDeleteArgs} args - Arguments to delete one UserProfile.
     * @example
     * // Delete one UserProfile
     * const UserProfile = await prisma.userProfile.delete({
     *   where: {
     *     // ... filter to delete one UserProfile
     *   }
     * })
     * 
     */
    delete<T extends UserProfileDeleteArgs>(args: SelectSubset<T, UserProfileDeleteArgs<ExtArgs>>): Prisma__UserProfileClient<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserProfile.
     * @param {UserProfileUpdateArgs} args - Arguments to update one UserProfile.
     * @example
     * // Update one UserProfile
     * const userProfile = await prisma.userProfile.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserProfileUpdateArgs>(args: SelectSubset<T, UserProfileUpdateArgs<ExtArgs>>): Prisma__UserProfileClient<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserProfiles.
     * @param {UserProfileDeleteManyArgs} args - Arguments to filter UserProfiles to delete.
     * @example
     * // Delete a few UserProfiles
     * const { count } = await prisma.userProfile.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserProfileDeleteManyArgs>(args?: SelectSubset<T, UserProfileDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProfileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserProfiles
     * const userProfile = await prisma.userProfile.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserProfileUpdateManyArgs>(args: SelectSubset<T, UserProfileUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserProfiles and returns the data updated in the database.
     * @param {UserProfileUpdateManyAndReturnArgs} args - Arguments to update many UserProfiles.
     * @example
     * // Update many UserProfiles
     * const userProfile = await prisma.userProfile.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserProfiles and only return the `id`
     * const userProfileWithIdOnly = await prisma.userProfile.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserProfileUpdateManyAndReturnArgs>(args: SelectSubset<T, UserProfileUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserProfile.
     * @param {UserProfileUpsertArgs} args - Arguments to update or create a UserProfile.
     * @example
     * // Update or create a UserProfile
     * const userProfile = await prisma.userProfile.upsert({
     *   create: {
     *     // ... data to create a UserProfile
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserProfile we want to update
     *   }
     * })
     */
    upsert<T extends UserProfileUpsertArgs>(args: SelectSubset<T, UserProfileUpsertArgs<ExtArgs>>): Prisma__UserProfileClient<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProfileCountArgs} args - Arguments to filter UserProfiles to count.
     * @example
     * // Count the number of UserProfiles
     * const count = await prisma.userProfile.count({
     *   where: {
     *     // ... the filter for the UserProfiles we want to count
     *   }
     * })
    **/
    count<T extends UserProfileCountArgs>(
      args?: Subset<T, UserProfileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserProfileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProfileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserProfileAggregateArgs>(args: Subset<T, UserProfileAggregateArgs>): Prisma.PrismaPromise<GetUserProfileAggregateType<T>>

    /**
     * Group by UserProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProfileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserProfileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserProfileGroupByArgs['orderBy'] }
        : { orderBy?: UserProfileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserProfileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserProfileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserProfile model
   */
  readonly fields: UserProfileFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserProfile.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserProfileClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    motorcycles<T extends UserProfile$motorcyclesArgs<ExtArgs> = {}>(args?: Subset<T, UserProfile$motorcyclesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MotorcyclePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    serviceRequests<T extends UserProfile$serviceRequestsArgs<ExtArgs> = {}>(args?: Subset<T, UserProfile$serviceRequestsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceRequestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    reviews<T extends UserProfile$reviewsArgs<ExtArgs> = {}>(args?: Subset<T, UserProfile$reviewsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    incidentReports<T extends UserProfile$incidentReportsArgs<ExtArgs> = {}>(args?: Subset<T, UserProfile$incidentReportsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IncidentReportPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    notifications<T extends UserProfile$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, UserProfile$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    chatMessages<T extends UserProfile$chatMessagesArgs<ExtArgs> = {}>(args?: Subset<T, UserProfile$chatMessagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    workshop<T extends UserProfile$workshopArgs<ExtArgs> = {}>(args?: Subset<T, UserProfile$workshopArgs<ExtArgs>>): Prisma__WorkshopClient<$Result.GetResult<Prisma.$WorkshopPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserProfile model
   */
  interface UserProfileFieldRefs {
    readonly id: FieldRef<"UserProfile", 'String'>
    readonly clerkUserId: FieldRef<"UserProfile", 'String'>
    readonly role: FieldRef<"UserProfile", 'UserRole'>
    readonly email: FieldRef<"UserProfile", 'String'>
    readonly phone: FieldRef<"UserProfile", 'String'>
    readonly name: FieldRef<"UserProfile", 'String'>
    readonly district: FieldRef<"UserProfile", 'String'>
    readonly avatarUrl: FieldRef<"UserProfile", 'String'>
    readonly notifChannel: FieldRef<"UserProfile", 'NotificationChannel'>
    readonly phoneVisible: FieldRef<"UserProfile", 'Boolean'>
    readonly termsAccepted: FieldRef<"UserProfile", 'Boolean'>
    readonly termsVersion: FieldRef<"UserProfile", 'String'>
    readonly termsAcceptedAt: FieldRef<"UserProfile", 'DateTime'>
    readonly privacyAccepted: FieldRef<"UserProfile", 'Boolean'>
    readonly privacyVersion: FieldRef<"UserProfile", 'String'>
    readonly privacyAcceptedAt: FieldRef<"UserProfile", 'DateTime'>
    readonly isActive: FieldRef<"UserProfile", 'Boolean'>
    readonly createdAt: FieldRef<"UserProfile", 'DateTime'>
    readonly updatedAt: FieldRef<"UserProfile", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserProfile findUnique
   */
  export type UserProfileFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProfile
     */
    omit?: UserProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProfileInclude<ExtArgs> | null
    /**
     * Filter, which UserProfile to fetch.
     */
    where: UserProfileWhereUniqueInput
  }

  /**
   * UserProfile findUniqueOrThrow
   */
  export type UserProfileFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProfile
     */
    omit?: UserProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProfileInclude<ExtArgs> | null
    /**
     * Filter, which UserProfile to fetch.
     */
    where: UserProfileWhereUniqueInput
  }

  /**
   * UserProfile findFirst
   */
  export type UserProfileFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProfile
     */
    omit?: UserProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProfileInclude<ExtArgs> | null
    /**
     * Filter, which UserProfile to fetch.
     */
    where?: UserProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserProfiles to fetch.
     */
    orderBy?: UserProfileOrderByWithRelationInput | UserProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserProfiles.
     */
    cursor?: UserProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserProfiles.
     */
    distinct?: UserProfileScalarFieldEnum | UserProfileScalarFieldEnum[]
  }

  /**
   * UserProfile findFirstOrThrow
   */
  export type UserProfileFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProfile
     */
    omit?: UserProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProfileInclude<ExtArgs> | null
    /**
     * Filter, which UserProfile to fetch.
     */
    where?: UserProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserProfiles to fetch.
     */
    orderBy?: UserProfileOrderByWithRelationInput | UserProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserProfiles.
     */
    cursor?: UserProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserProfiles.
     */
    distinct?: UserProfileScalarFieldEnum | UserProfileScalarFieldEnum[]
  }

  /**
   * UserProfile findMany
   */
  export type UserProfileFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProfile
     */
    omit?: UserProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProfileInclude<ExtArgs> | null
    /**
     * Filter, which UserProfiles to fetch.
     */
    where?: UserProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserProfiles to fetch.
     */
    orderBy?: UserProfileOrderByWithRelationInput | UserProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserProfiles.
     */
    cursor?: UserProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserProfiles.
     */
    skip?: number
    distinct?: UserProfileScalarFieldEnum | UserProfileScalarFieldEnum[]
  }

  /**
   * UserProfile create
   */
  export type UserProfileCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProfile
     */
    omit?: UserProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProfileInclude<ExtArgs> | null
    /**
     * The data needed to create a UserProfile.
     */
    data: XOR<UserProfileCreateInput, UserProfileUncheckedCreateInput>
  }

  /**
   * UserProfile createMany
   */
  export type UserProfileCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserProfiles.
     */
    data: UserProfileCreateManyInput | UserProfileCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserProfile createManyAndReturn
   */
  export type UserProfileCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserProfile
     */
    omit?: UserProfileOmit<ExtArgs> | null
    /**
     * The data used to create many UserProfiles.
     */
    data: UserProfileCreateManyInput | UserProfileCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserProfile update
   */
  export type UserProfileUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProfile
     */
    omit?: UserProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProfileInclude<ExtArgs> | null
    /**
     * The data needed to update a UserProfile.
     */
    data: XOR<UserProfileUpdateInput, UserProfileUncheckedUpdateInput>
    /**
     * Choose, which UserProfile to update.
     */
    where: UserProfileWhereUniqueInput
  }

  /**
   * UserProfile updateMany
   */
  export type UserProfileUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserProfiles.
     */
    data: XOR<UserProfileUpdateManyMutationInput, UserProfileUncheckedUpdateManyInput>
    /**
     * Filter which UserProfiles to update
     */
    where?: UserProfileWhereInput
    /**
     * Limit how many UserProfiles to update.
     */
    limit?: number
  }

  /**
   * UserProfile updateManyAndReturn
   */
  export type UserProfileUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserProfile
     */
    omit?: UserProfileOmit<ExtArgs> | null
    /**
     * The data used to update UserProfiles.
     */
    data: XOR<UserProfileUpdateManyMutationInput, UserProfileUncheckedUpdateManyInput>
    /**
     * Filter which UserProfiles to update
     */
    where?: UserProfileWhereInput
    /**
     * Limit how many UserProfiles to update.
     */
    limit?: number
  }

  /**
   * UserProfile upsert
   */
  export type UserProfileUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProfile
     */
    omit?: UserProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProfileInclude<ExtArgs> | null
    /**
     * The filter to search for the UserProfile to update in case it exists.
     */
    where: UserProfileWhereUniqueInput
    /**
     * In case the UserProfile found by the `where` argument doesn't exist, create a new UserProfile with this data.
     */
    create: XOR<UserProfileCreateInput, UserProfileUncheckedCreateInput>
    /**
     * In case the UserProfile was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserProfileUpdateInput, UserProfileUncheckedUpdateInput>
  }

  /**
   * UserProfile delete
   */
  export type UserProfileDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProfile
     */
    omit?: UserProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProfileInclude<ExtArgs> | null
    /**
     * Filter which UserProfile to delete.
     */
    where: UserProfileWhereUniqueInput
  }

  /**
   * UserProfile deleteMany
   */
  export type UserProfileDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserProfiles to delete
     */
    where?: UserProfileWhereInput
    /**
     * Limit how many UserProfiles to delete.
     */
    limit?: number
  }

  /**
   * UserProfile.motorcycles
   */
  export type UserProfile$motorcyclesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Motorcycle
     */
    select?: MotorcycleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Motorcycle
     */
    omit?: MotorcycleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MotorcycleInclude<ExtArgs> | null
    where?: MotorcycleWhereInput
    orderBy?: MotorcycleOrderByWithRelationInput | MotorcycleOrderByWithRelationInput[]
    cursor?: MotorcycleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MotorcycleScalarFieldEnum | MotorcycleScalarFieldEnum[]
  }

  /**
   * UserProfile.serviceRequests
   */
  export type UserProfile$serviceRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceRequest
     */
    select?: ServiceRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceRequest
     */
    omit?: ServiceRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceRequestInclude<ExtArgs> | null
    where?: ServiceRequestWhereInput
    orderBy?: ServiceRequestOrderByWithRelationInput | ServiceRequestOrderByWithRelationInput[]
    cursor?: ServiceRequestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ServiceRequestScalarFieldEnum | ServiceRequestScalarFieldEnum[]
  }

  /**
   * UserProfile.reviews
   */
  export type UserProfile$reviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    where?: ReviewWhereInput
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    cursor?: ReviewWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }

  /**
   * UserProfile.incidentReports
   */
  export type UserProfile$incidentReportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IncidentReport
     */
    select?: IncidentReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IncidentReport
     */
    omit?: IncidentReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidentReportInclude<ExtArgs> | null
    where?: IncidentReportWhereInput
    orderBy?: IncidentReportOrderByWithRelationInput | IncidentReportOrderByWithRelationInput[]
    cursor?: IncidentReportWhereUniqueInput
    take?: number
    skip?: number
    distinct?: IncidentReportScalarFieldEnum | IncidentReportScalarFieldEnum[]
  }

  /**
   * UserProfile.notifications
   */
  export type UserProfile$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * UserProfile.chatMessages
   */
  export type UserProfile$chatMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatMessage
     */
    omit?: ChatMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageInclude<ExtArgs> | null
    where?: ChatMessageWhereInput
    orderBy?: ChatMessageOrderByWithRelationInput | ChatMessageOrderByWithRelationInput[]
    cursor?: ChatMessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChatMessageScalarFieldEnum | ChatMessageScalarFieldEnum[]
  }

  /**
   * UserProfile.workshop
   */
  export type UserProfile$workshopArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workshop
     */
    select?: WorkshopSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Workshop
     */
    omit?: WorkshopOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkshopInclude<ExtArgs> | null
    where?: WorkshopWhereInput
  }

  /**
   * UserProfile without action
   */
  export type UserProfileDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProfile
     */
    omit?: UserProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProfileInclude<ExtArgs> | null
  }


  /**
   * Model Motorcycle
   */

  export type AggregateMotorcycle = {
    _count: MotorcycleCountAggregateOutputType | null
    _avg: MotorcycleAvgAggregateOutputType | null
    _sum: MotorcycleSumAggregateOutputType | null
    _min: MotorcycleMinAggregateOutputType | null
    _max: MotorcycleMaxAggregateOutputType | null
  }

  export type MotorcycleAvgAggregateOutputType = {
    year: number | null
    displacement: number | null
    kmApprox: number | null
  }

  export type MotorcycleSumAggregateOutputType = {
    year: number | null
    displacement: number | null
    kmApprox: number | null
  }

  export type MotorcycleMinAggregateOutputType = {
    id: string | null
    userId: string | null
    brand: string | null
    model: string | null
    year: number | null
    displacement: number | null
    use: $Enums.MotorcycleUse | null
    kmApprox: number | null
    placa: string | null
    alias: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MotorcycleMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    brand: string | null
    model: string | null
    year: number | null
    displacement: number | null
    use: $Enums.MotorcycleUse | null
    kmApprox: number | null
    placa: string | null
    alias: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MotorcycleCountAggregateOutputType = {
    id: number
    userId: number
    brand: number
    model: number
    year: number
    displacement: number
    use: number
    kmApprox: number
    placa: number
    alias: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MotorcycleAvgAggregateInputType = {
    year?: true
    displacement?: true
    kmApprox?: true
  }

  export type MotorcycleSumAggregateInputType = {
    year?: true
    displacement?: true
    kmApprox?: true
  }

  export type MotorcycleMinAggregateInputType = {
    id?: true
    userId?: true
    brand?: true
    model?: true
    year?: true
    displacement?: true
    use?: true
    kmApprox?: true
    placa?: true
    alias?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MotorcycleMaxAggregateInputType = {
    id?: true
    userId?: true
    brand?: true
    model?: true
    year?: true
    displacement?: true
    use?: true
    kmApprox?: true
    placa?: true
    alias?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MotorcycleCountAggregateInputType = {
    id?: true
    userId?: true
    brand?: true
    model?: true
    year?: true
    displacement?: true
    use?: true
    kmApprox?: true
    placa?: true
    alias?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MotorcycleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Motorcycle to aggregate.
     */
    where?: MotorcycleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Motorcycles to fetch.
     */
    orderBy?: MotorcycleOrderByWithRelationInput | MotorcycleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MotorcycleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Motorcycles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Motorcycles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Motorcycles
    **/
    _count?: true | MotorcycleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MotorcycleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MotorcycleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MotorcycleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MotorcycleMaxAggregateInputType
  }

  export type GetMotorcycleAggregateType<T extends MotorcycleAggregateArgs> = {
        [P in keyof T & keyof AggregateMotorcycle]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMotorcycle[P]>
      : GetScalarType<T[P], AggregateMotorcycle[P]>
  }




  export type MotorcycleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MotorcycleWhereInput
    orderBy?: MotorcycleOrderByWithAggregationInput | MotorcycleOrderByWithAggregationInput[]
    by: MotorcycleScalarFieldEnum[] | MotorcycleScalarFieldEnum
    having?: MotorcycleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MotorcycleCountAggregateInputType | true
    _avg?: MotorcycleAvgAggregateInputType
    _sum?: MotorcycleSumAggregateInputType
    _min?: MotorcycleMinAggregateInputType
    _max?: MotorcycleMaxAggregateInputType
  }

  export type MotorcycleGroupByOutputType = {
    id: string
    userId: string
    brand: string
    model: string
    year: number
    displacement: number | null
    use: $Enums.MotorcycleUse | null
    kmApprox: number | null
    placa: string | null
    alias: string | null
    createdAt: Date
    updatedAt: Date
    _count: MotorcycleCountAggregateOutputType | null
    _avg: MotorcycleAvgAggregateOutputType | null
    _sum: MotorcycleSumAggregateOutputType | null
    _min: MotorcycleMinAggregateOutputType | null
    _max: MotorcycleMaxAggregateOutputType | null
  }

  type GetMotorcycleGroupByPayload<T extends MotorcycleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MotorcycleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MotorcycleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MotorcycleGroupByOutputType[P]>
            : GetScalarType<T[P], MotorcycleGroupByOutputType[P]>
        }
      >
    >


  export type MotorcycleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    brand?: boolean
    model?: boolean
    year?: boolean
    displacement?: boolean
    use?: boolean
    kmApprox?: boolean
    placa?: boolean
    alias?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserProfileDefaultArgs<ExtArgs>
    serviceRequests?: boolean | Motorcycle$serviceRequestsArgs<ExtArgs>
    _count?: boolean | MotorcycleCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["motorcycle"]>

  export type MotorcycleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    brand?: boolean
    model?: boolean
    year?: boolean
    displacement?: boolean
    use?: boolean
    kmApprox?: boolean
    placa?: boolean
    alias?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["motorcycle"]>

  export type MotorcycleSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    brand?: boolean
    model?: boolean
    year?: boolean
    displacement?: boolean
    use?: boolean
    kmApprox?: boolean
    placa?: boolean
    alias?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["motorcycle"]>

  export type MotorcycleSelectScalar = {
    id?: boolean
    userId?: boolean
    brand?: boolean
    model?: boolean
    year?: boolean
    displacement?: boolean
    use?: boolean
    kmApprox?: boolean
    placa?: boolean
    alias?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MotorcycleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "brand" | "model" | "year" | "displacement" | "use" | "kmApprox" | "placa" | "alias" | "createdAt" | "updatedAt", ExtArgs["result"]["motorcycle"]>
  export type MotorcycleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserProfileDefaultArgs<ExtArgs>
    serviceRequests?: boolean | Motorcycle$serviceRequestsArgs<ExtArgs>
    _count?: boolean | MotorcycleCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MotorcycleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserProfileDefaultArgs<ExtArgs>
  }
  export type MotorcycleIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserProfileDefaultArgs<ExtArgs>
  }

  export type $MotorcyclePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Motorcycle"
    objects: {
      user: Prisma.$UserProfilePayload<ExtArgs>
      serviceRequests: Prisma.$ServiceRequestPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      brand: string
      model: string
      year: number
      displacement: number | null
      use: $Enums.MotorcycleUse | null
      kmApprox: number | null
      placa: string | null
      alias: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["motorcycle"]>
    composites: {}
  }

  type MotorcycleGetPayload<S extends boolean | null | undefined | MotorcycleDefaultArgs> = $Result.GetResult<Prisma.$MotorcyclePayload, S>

  type MotorcycleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MotorcycleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MotorcycleCountAggregateInputType | true
    }

  export interface MotorcycleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Motorcycle'], meta: { name: 'Motorcycle' } }
    /**
     * Find zero or one Motorcycle that matches the filter.
     * @param {MotorcycleFindUniqueArgs} args - Arguments to find a Motorcycle
     * @example
     * // Get one Motorcycle
     * const motorcycle = await prisma.motorcycle.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MotorcycleFindUniqueArgs>(args: SelectSubset<T, MotorcycleFindUniqueArgs<ExtArgs>>): Prisma__MotorcycleClient<$Result.GetResult<Prisma.$MotorcyclePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Motorcycle that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MotorcycleFindUniqueOrThrowArgs} args - Arguments to find a Motorcycle
     * @example
     * // Get one Motorcycle
     * const motorcycle = await prisma.motorcycle.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MotorcycleFindUniqueOrThrowArgs>(args: SelectSubset<T, MotorcycleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MotorcycleClient<$Result.GetResult<Prisma.$MotorcyclePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Motorcycle that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MotorcycleFindFirstArgs} args - Arguments to find a Motorcycle
     * @example
     * // Get one Motorcycle
     * const motorcycle = await prisma.motorcycle.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MotorcycleFindFirstArgs>(args?: SelectSubset<T, MotorcycleFindFirstArgs<ExtArgs>>): Prisma__MotorcycleClient<$Result.GetResult<Prisma.$MotorcyclePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Motorcycle that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MotorcycleFindFirstOrThrowArgs} args - Arguments to find a Motorcycle
     * @example
     * // Get one Motorcycle
     * const motorcycle = await prisma.motorcycle.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MotorcycleFindFirstOrThrowArgs>(args?: SelectSubset<T, MotorcycleFindFirstOrThrowArgs<ExtArgs>>): Prisma__MotorcycleClient<$Result.GetResult<Prisma.$MotorcyclePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Motorcycles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MotorcycleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Motorcycles
     * const motorcycles = await prisma.motorcycle.findMany()
     * 
     * // Get first 10 Motorcycles
     * const motorcycles = await prisma.motorcycle.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const motorcycleWithIdOnly = await prisma.motorcycle.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MotorcycleFindManyArgs>(args?: SelectSubset<T, MotorcycleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MotorcyclePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Motorcycle.
     * @param {MotorcycleCreateArgs} args - Arguments to create a Motorcycle.
     * @example
     * // Create one Motorcycle
     * const Motorcycle = await prisma.motorcycle.create({
     *   data: {
     *     // ... data to create a Motorcycle
     *   }
     * })
     * 
     */
    create<T extends MotorcycleCreateArgs>(args: SelectSubset<T, MotorcycleCreateArgs<ExtArgs>>): Prisma__MotorcycleClient<$Result.GetResult<Prisma.$MotorcyclePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Motorcycles.
     * @param {MotorcycleCreateManyArgs} args - Arguments to create many Motorcycles.
     * @example
     * // Create many Motorcycles
     * const motorcycle = await prisma.motorcycle.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MotorcycleCreateManyArgs>(args?: SelectSubset<T, MotorcycleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Motorcycles and returns the data saved in the database.
     * @param {MotorcycleCreateManyAndReturnArgs} args - Arguments to create many Motorcycles.
     * @example
     * // Create many Motorcycles
     * const motorcycle = await prisma.motorcycle.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Motorcycles and only return the `id`
     * const motorcycleWithIdOnly = await prisma.motorcycle.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MotorcycleCreateManyAndReturnArgs>(args?: SelectSubset<T, MotorcycleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MotorcyclePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Motorcycle.
     * @param {MotorcycleDeleteArgs} args - Arguments to delete one Motorcycle.
     * @example
     * // Delete one Motorcycle
     * const Motorcycle = await prisma.motorcycle.delete({
     *   where: {
     *     // ... filter to delete one Motorcycle
     *   }
     * })
     * 
     */
    delete<T extends MotorcycleDeleteArgs>(args: SelectSubset<T, MotorcycleDeleteArgs<ExtArgs>>): Prisma__MotorcycleClient<$Result.GetResult<Prisma.$MotorcyclePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Motorcycle.
     * @param {MotorcycleUpdateArgs} args - Arguments to update one Motorcycle.
     * @example
     * // Update one Motorcycle
     * const motorcycle = await prisma.motorcycle.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MotorcycleUpdateArgs>(args: SelectSubset<T, MotorcycleUpdateArgs<ExtArgs>>): Prisma__MotorcycleClient<$Result.GetResult<Prisma.$MotorcyclePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Motorcycles.
     * @param {MotorcycleDeleteManyArgs} args - Arguments to filter Motorcycles to delete.
     * @example
     * // Delete a few Motorcycles
     * const { count } = await prisma.motorcycle.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MotorcycleDeleteManyArgs>(args?: SelectSubset<T, MotorcycleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Motorcycles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MotorcycleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Motorcycles
     * const motorcycle = await prisma.motorcycle.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MotorcycleUpdateManyArgs>(args: SelectSubset<T, MotorcycleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Motorcycles and returns the data updated in the database.
     * @param {MotorcycleUpdateManyAndReturnArgs} args - Arguments to update many Motorcycles.
     * @example
     * // Update many Motorcycles
     * const motorcycle = await prisma.motorcycle.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Motorcycles and only return the `id`
     * const motorcycleWithIdOnly = await prisma.motorcycle.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MotorcycleUpdateManyAndReturnArgs>(args: SelectSubset<T, MotorcycleUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MotorcyclePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Motorcycle.
     * @param {MotorcycleUpsertArgs} args - Arguments to update or create a Motorcycle.
     * @example
     * // Update or create a Motorcycle
     * const motorcycle = await prisma.motorcycle.upsert({
     *   create: {
     *     // ... data to create a Motorcycle
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Motorcycle we want to update
     *   }
     * })
     */
    upsert<T extends MotorcycleUpsertArgs>(args: SelectSubset<T, MotorcycleUpsertArgs<ExtArgs>>): Prisma__MotorcycleClient<$Result.GetResult<Prisma.$MotorcyclePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Motorcycles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MotorcycleCountArgs} args - Arguments to filter Motorcycles to count.
     * @example
     * // Count the number of Motorcycles
     * const count = await prisma.motorcycle.count({
     *   where: {
     *     // ... the filter for the Motorcycles we want to count
     *   }
     * })
    **/
    count<T extends MotorcycleCountArgs>(
      args?: Subset<T, MotorcycleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MotorcycleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Motorcycle.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MotorcycleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MotorcycleAggregateArgs>(args: Subset<T, MotorcycleAggregateArgs>): Prisma.PrismaPromise<GetMotorcycleAggregateType<T>>

    /**
     * Group by Motorcycle.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MotorcycleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MotorcycleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MotorcycleGroupByArgs['orderBy'] }
        : { orderBy?: MotorcycleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MotorcycleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMotorcycleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Motorcycle model
   */
  readonly fields: MotorcycleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Motorcycle.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MotorcycleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserProfileDefaultArgs<ExtArgs>>): Prisma__UserProfileClient<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    serviceRequests<T extends Motorcycle$serviceRequestsArgs<ExtArgs> = {}>(args?: Subset<T, Motorcycle$serviceRequestsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceRequestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Motorcycle model
   */
  interface MotorcycleFieldRefs {
    readonly id: FieldRef<"Motorcycle", 'String'>
    readonly userId: FieldRef<"Motorcycle", 'String'>
    readonly brand: FieldRef<"Motorcycle", 'String'>
    readonly model: FieldRef<"Motorcycle", 'String'>
    readonly year: FieldRef<"Motorcycle", 'Int'>
    readonly displacement: FieldRef<"Motorcycle", 'Int'>
    readonly use: FieldRef<"Motorcycle", 'MotorcycleUse'>
    readonly kmApprox: FieldRef<"Motorcycle", 'Int'>
    readonly placa: FieldRef<"Motorcycle", 'String'>
    readonly alias: FieldRef<"Motorcycle", 'String'>
    readonly createdAt: FieldRef<"Motorcycle", 'DateTime'>
    readonly updatedAt: FieldRef<"Motorcycle", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Motorcycle findUnique
   */
  export type MotorcycleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Motorcycle
     */
    select?: MotorcycleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Motorcycle
     */
    omit?: MotorcycleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MotorcycleInclude<ExtArgs> | null
    /**
     * Filter, which Motorcycle to fetch.
     */
    where: MotorcycleWhereUniqueInput
  }

  /**
   * Motorcycle findUniqueOrThrow
   */
  export type MotorcycleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Motorcycle
     */
    select?: MotorcycleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Motorcycle
     */
    omit?: MotorcycleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MotorcycleInclude<ExtArgs> | null
    /**
     * Filter, which Motorcycle to fetch.
     */
    where: MotorcycleWhereUniqueInput
  }

  /**
   * Motorcycle findFirst
   */
  export type MotorcycleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Motorcycle
     */
    select?: MotorcycleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Motorcycle
     */
    omit?: MotorcycleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MotorcycleInclude<ExtArgs> | null
    /**
     * Filter, which Motorcycle to fetch.
     */
    where?: MotorcycleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Motorcycles to fetch.
     */
    orderBy?: MotorcycleOrderByWithRelationInput | MotorcycleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Motorcycles.
     */
    cursor?: MotorcycleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Motorcycles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Motorcycles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Motorcycles.
     */
    distinct?: MotorcycleScalarFieldEnum | MotorcycleScalarFieldEnum[]
  }

  /**
   * Motorcycle findFirstOrThrow
   */
  export type MotorcycleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Motorcycle
     */
    select?: MotorcycleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Motorcycle
     */
    omit?: MotorcycleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MotorcycleInclude<ExtArgs> | null
    /**
     * Filter, which Motorcycle to fetch.
     */
    where?: MotorcycleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Motorcycles to fetch.
     */
    orderBy?: MotorcycleOrderByWithRelationInput | MotorcycleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Motorcycles.
     */
    cursor?: MotorcycleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Motorcycles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Motorcycles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Motorcycles.
     */
    distinct?: MotorcycleScalarFieldEnum | MotorcycleScalarFieldEnum[]
  }

  /**
   * Motorcycle findMany
   */
  export type MotorcycleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Motorcycle
     */
    select?: MotorcycleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Motorcycle
     */
    omit?: MotorcycleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MotorcycleInclude<ExtArgs> | null
    /**
     * Filter, which Motorcycles to fetch.
     */
    where?: MotorcycleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Motorcycles to fetch.
     */
    orderBy?: MotorcycleOrderByWithRelationInput | MotorcycleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Motorcycles.
     */
    cursor?: MotorcycleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Motorcycles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Motorcycles.
     */
    skip?: number
    distinct?: MotorcycleScalarFieldEnum | MotorcycleScalarFieldEnum[]
  }

  /**
   * Motorcycle create
   */
  export type MotorcycleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Motorcycle
     */
    select?: MotorcycleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Motorcycle
     */
    omit?: MotorcycleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MotorcycleInclude<ExtArgs> | null
    /**
     * The data needed to create a Motorcycle.
     */
    data: XOR<MotorcycleCreateInput, MotorcycleUncheckedCreateInput>
  }

  /**
   * Motorcycle createMany
   */
  export type MotorcycleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Motorcycles.
     */
    data: MotorcycleCreateManyInput | MotorcycleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Motorcycle createManyAndReturn
   */
  export type MotorcycleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Motorcycle
     */
    select?: MotorcycleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Motorcycle
     */
    omit?: MotorcycleOmit<ExtArgs> | null
    /**
     * The data used to create many Motorcycles.
     */
    data: MotorcycleCreateManyInput | MotorcycleCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MotorcycleIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Motorcycle update
   */
  export type MotorcycleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Motorcycle
     */
    select?: MotorcycleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Motorcycle
     */
    omit?: MotorcycleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MotorcycleInclude<ExtArgs> | null
    /**
     * The data needed to update a Motorcycle.
     */
    data: XOR<MotorcycleUpdateInput, MotorcycleUncheckedUpdateInput>
    /**
     * Choose, which Motorcycle to update.
     */
    where: MotorcycleWhereUniqueInput
  }

  /**
   * Motorcycle updateMany
   */
  export type MotorcycleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Motorcycles.
     */
    data: XOR<MotorcycleUpdateManyMutationInput, MotorcycleUncheckedUpdateManyInput>
    /**
     * Filter which Motorcycles to update
     */
    where?: MotorcycleWhereInput
    /**
     * Limit how many Motorcycles to update.
     */
    limit?: number
  }

  /**
   * Motorcycle updateManyAndReturn
   */
  export type MotorcycleUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Motorcycle
     */
    select?: MotorcycleSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Motorcycle
     */
    omit?: MotorcycleOmit<ExtArgs> | null
    /**
     * The data used to update Motorcycles.
     */
    data: XOR<MotorcycleUpdateManyMutationInput, MotorcycleUncheckedUpdateManyInput>
    /**
     * Filter which Motorcycles to update
     */
    where?: MotorcycleWhereInput
    /**
     * Limit how many Motorcycles to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MotorcycleIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Motorcycle upsert
   */
  export type MotorcycleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Motorcycle
     */
    select?: MotorcycleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Motorcycle
     */
    omit?: MotorcycleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MotorcycleInclude<ExtArgs> | null
    /**
     * The filter to search for the Motorcycle to update in case it exists.
     */
    where: MotorcycleWhereUniqueInput
    /**
     * In case the Motorcycle found by the `where` argument doesn't exist, create a new Motorcycle with this data.
     */
    create: XOR<MotorcycleCreateInput, MotorcycleUncheckedCreateInput>
    /**
     * In case the Motorcycle was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MotorcycleUpdateInput, MotorcycleUncheckedUpdateInput>
  }

  /**
   * Motorcycle delete
   */
  export type MotorcycleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Motorcycle
     */
    select?: MotorcycleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Motorcycle
     */
    omit?: MotorcycleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MotorcycleInclude<ExtArgs> | null
    /**
     * Filter which Motorcycle to delete.
     */
    where: MotorcycleWhereUniqueInput
  }

  /**
   * Motorcycle deleteMany
   */
  export type MotorcycleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Motorcycles to delete
     */
    where?: MotorcycleWhereInput
    /**
     * Limit how many Motorcycles to delete.
     */
    limit?: number
  }

  /**
   * Motorcycle.serviceRequests
   */
  export type Motorcycle$serviceRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceRequest
     */
    select?: ServiceRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceRequest
     */
    omit?: ServiceRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceRequestInclude<ExtArgs> | null
    where?: ServiceRequestWhereInput
    orderBy?: ServiceRequestOrderByWithRelationInput | ServiceRequestOrderByWithRelationInput[]
    cursor?: ServiceRequestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ServiceRequestScalarFieldEnum | ServiceRequestScalarFieldEnum[]
  }

  /**
   * Motorcycle without action
   */
  export type MotorcycleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Motorcycle
     */
    select?: MotorcycleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Motorcycle
     */
    omit?: MotorcycleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MotorcycleInclude<ExtArgs> | null
  }


  /**
   * Model Category
   */

  export type AggregateCategory = {
    _count: CategoryCountAggregateOutputType | null
    _avg: CategoryAvgAggregateOutputType | null
    _sum: CategorySumAggregateOutputType | null
    _min: CategoryMinAggregateOutputType | null
    _max: CategoryMaxAggregateOutputType | null
  }

  export type CategoryAvgAggregateOutputType = {
    version: number | null
  }

  export type CategorySumAggregateOutputType = {
    version: number | null
  }

  export type CategoryMinAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    description: string | null
    parentId: string | null
    version: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CategoryMaxAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    description: string | null
    parentId: string | null
    version: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CategoryCountAggregateOutputType = {
    id: number
    name: number
    slug: number
    description: number
    parentId: number
    version: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CategoryAvgAggregateInputType = {
    version?: true
  }

  export type CategorySumAggregateInputType = {
    version?: true
  }

  export type CategoryMinAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    description?: true
    parentId?: true
    version?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CategoryMaxAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    description?: true
    parentId?: true
    version?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CategoryCountAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    description?: true
    parentId?: true
    version?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Category to aggregate.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Categories
    **/
    _count?: true | CategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CategoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CategorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CategoryMaxAggregateInputType
  }

  export type GetCategoryAggregateType<T extends CategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCategory[P]>
      : GetScalarType<T[P], AggregateCategory[P]>
  }




  export type CategoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CategoryWhereInput
    orderBy?: CategoryOrderByWithAggregationInput | CategoryOrderByWithAggregationInput[]
    by: CategoryScalarFieldEnum[] | CategoryScalarFieldEnum
    having?: CategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CategoryCountAggregateInputType | true
    _avg?: CategoryAvgAggregateInputType
    _sum?: CategorySumAggregateInputType
    _min?: CategoryMinAggregateInputType
    _max?: CategoryMaxAggregateInputType
  }

  export type CategoryGroupByOutputType = {
    id: string
    name: string
    slug: string
    description: string | null
    parentId: string | null
    version: number
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: CategoryCountAggregateOutputType | null
    _avg: CategoryAvgAggregateOutputType | null
    _sum: CategorySumAggregateOutputType | null
    _min: CategoryMinAggregateOutputType | null
    _max: CategoryMaxAggregateOutputType | null
  }

  type GetCategoryGroupByPayload<T extends CategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CategoryGroupByOutputType[P]>
            : GetScalarType<T[P], CategoryGroupByOutputType[P]>
        }
      >
    >


  export type CategorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    parentId?: boolean
    version?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    parent?: boolean | Category$parentArgs<ExtArgs>
    children?: boolean | Category$childrenArgs<ExtArgs>
    guideQuestions?: boolean | Category$guideQuestionsArgs<ExtArgs>
    serviceRequests?: boolean | Category$serviceRequestsArgs<ExtArgs>
    workshopCategories?: boolean | Category$workshopCategoriesArgs<ExtArgs>
    _count?: boolean | CategoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["category"]>

  export type CategorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    parentId?: boolean
    version?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    parent?: boolean | Category$parentArgs<ExtArgs>
  }, ExtArgs["result"]["category"]>

  export type CategorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    parentId?: boolean
    version?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    parent?: boolean | Category$parentArgs<ExtArgs>
  }, ExtArgs["result"]["category"]>

  export type CategorySelectScalar = {
    id?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    parentId?: boolean
    version?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CategoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "slug" | "description" | "parentId" | "version" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["category"]>
  export type CategoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parent?: boolean | Category$parentArgs<ExtArgs>
    children?: boolean | Category$childrenArgs<ExtArgs>
    guideQuestions?: boolean | Category$guideQuestionsArgs<ExtArgs>
    serviceRequests?: boolean | Category$serviceRequestsArgs<ExtArgs>
    workshopCategories?: boolean | Category$workshopCategoriesArgs<ExtArgs>
    _count?: boolean | CategoryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CategoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parent?: boolean | Category$parentArgs<ExtArgs>
  }
  export type CategoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parent?: boolean | Category$parentArgs<ExtArgs>
  }

  export type $CategoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Category"
    objects: {
      parent: Prisma.$CategoryPayload<ExtArgs> | null
      children: Prisma.$CategoryPayload<ExtArgs>[]
      guideQuestions: Prisma.$GuideQuestionPayload<ExtArgs>[]
      serviceRequests: Prisma.$ServiceRequestPayload<ExtArgs>[]
      workshopCategories: Prisma.$WorkshopCategoryPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      slug: string
      description: string | null
      parentId: string | null
      version: number
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["category"]>
    composites: {}
  }

  type CategoryGetPayload<S extends boolean | null | undefined | CategoryDefaultArgs> = $Result.GetResult<Prisma.$CategoryPayload, S>

  type CategoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CategoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CategoryCountAggregateInputType | true
    }

  export interface CategoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Category'], meta: { name: 'Category' } }
    /**
     * Find zero or one Category that matches the filter.
     * @param {CategoryFindUniqueArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CategoryFindUniqueArgs>(args: SelectSubset<T, CategoryFindUniqueArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Category that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CategoryFindUniqueOrThrowArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CategoryFindUniqueOrThrowArgs>(args: SelectSubset<T, CategoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Category that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindFirstArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CategoryFindFirstArgs>(args?: SelectSubset<T, CategoryFindFirstArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Category that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindFirstOrThrowArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CategoryFindFirstOrThrowArgs>(args?: SelectSubset<T, CategoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Categories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Categories
     * const categories = await prisma.category.findMany()
     * 
     * // Get first 10 Categories
     * const categories = await prisma.category.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const categoryWithIdOnly = await prisma.category.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CategoryFindManyArgs>(args?: SelectSubset<T, CategoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Category.
     * @param {CategoryCreateArgs} args - Arguments to create a Category.
     * @example
     * // Create one Category
     * const Category = await prisma.category.create({
     *   data: {
     *     // ... data to create a Category
     *   }
     * })
     * 
     */
    create<T extends CategoryCreateArgs>(args: SelectSubset<T, CategoryCreateArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Categories.
     * @param {CategoryCreateManyArgs} args - Arguments to create many Categories.
     * @example
     * // Create many Categories
     * const category = await prisma.category.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CategoryCreateManyArgs>(args?: SelectSubset<T, CategoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Categories and returns the data saved in the database.
     * @param {CategoryCreateManyAndReturnArgs} args - Arguments to create many Categories.
     * @example
     * // Create many Categories
     * const category = await prisma.category.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Categories and only return the `id`
     * const categoryWithIdOnly = await prisma.category.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CategoryCreateManyAndReturnArgs>(args?: SelectSubset<T, CategoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Category.
     * @param {CategoryDeleteArgs} args - Arguments to delete one Category.
     * @example
     * // Delete one Category
     * const Category = await prisma.category.delete({
     *   where: {
     *     // ... filter to delete one Category
     *   }
     * })
     * 
     */
    delete<T extends CategoryDeleteArgs>(args: SelectSubset<T, CategoryDeleteArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Category.
     * @param {CategoryUpdateArgs} args - Arguments to update one Category.
     * @example
     * // Update one Category
     * const category = await prisma.category.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CategoryUpdateArgs>(args: SelectSubset<T, CategoryUpdateArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Categories.
     * @param {CategoryDeleteManyArgs} args - Arguments to filter Categories to delete.
     * @example
     * // Delete a few Categories
     * const { count } = await prisma.category.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CategoryDeleteManyArgs>(args?: SelectSubset<T, CategoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Categories
     * const category = await prisma.category.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CategoryUpdateManyArgs>(args: SelectSubset<T, CategoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Categories and returns the data updated in the database.
     * @param {CategoryUpdateManyAndReturnArgs} args - Arguments to update many Categories.
     * @example
     * // Update many Categories
     * const category = await prisma.category.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Categories and only return the `id`
     * const categoryWithIdOnly = await prisma.category.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CategoryUpdateManyAndReturnArgs>(args: SelectSubset<T, CategoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Category.
     * @param {CategoryUpsertArgs} args - Arguments to update or create a Category.
     * @example
     * // Update or create a Category
     * const category = await prisma.category.upsert({
     *   create: {
     *     // ... data to create a Category
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Category we want to update
     *   }
     * })
     */
    upsert<T extends CategoryUpsertArgs>(args: SelectSubset<T, CategoryUpsertArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryCountArgs} args - Arguments to filter Categories to count.
     * @example
     * // Count the number of Categories
     * const count = await prisma.category.count({
     *   where: {
     *     // ... the filter for the Categories we want to count
     *   }
     * })
    **/
    count<T extends CategoryCountArgs>(
      args?: Subset<T, CategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CategoryAggregateArgs>(args: Subset<T, CategoryAggregateArgs>): Prisma.PrismaPromise<GetCategoryAggregateType<T>>

    /**
     * Group by Category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CategoryGroupByArgs['orderBy'] }
        : { orderBy?: CategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Category model
   */
  readonly fields: CategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Category.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CategoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    parent<T extends Category$parentArgs<ExtArgs> = {}>(args?: Subset<T, Category$parentArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    children<T extends Category$childrenArgs<ExtArgs> = {}>(args?: Subset<T, Category$childrenArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    guideQuestions<T extends Category$guideQuestionsArgs<ExtArgs> = {}>(args?: Subset<T, Category$guideQuestionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GuideQuestionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    serviceRequests<T extends Category$serviceRequestsArgs<ExtArgs> = {}>(args?: Subset<T, Category$serviceRequestsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceRequestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    workshopCategories<T extends Category$workshopCategoriesArgs<ExtArgs> = {}>(args?: Subset<T, Category$workshopCategoriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkshopCategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Category model
   */
  interface CategoryFieldRefs {
    readonly id: FieldRef<"Category", 'String'>
    readonly name: FieldRef<"Category", 'String'>
    readonly slug: FieldRef<"Category", 'String'>
    readonly description: FieldRef<"Category", 'String'>
    readonly parentId: FieldRef<"Category", 'String'>
    readonly version: FieldRef<"Category", 'Int'>
    readonly isActive: FieldRef<"Category", 'Boolean'>
    readonly createdAt: FieldRef<"Category", 'DateTime'>
    readonly updatedAt: FieldRef<"Category", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Category findUnique
   */
  export type CategoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category findUniqueOrThrow
   */
  export type CategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category findFirst
   */
  export type CategoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Categories.
     */
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Category findFirstOrThrow
   */
  export type CategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Categories.
     */
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Category findMany
   */
  export type CategoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Categories to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Category create
   */
  export type CategoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * The data needed to create a Category.
     */
    data: XOR<CategoryCreateInput, CategoryUncheckedCreateInput>
  }

  /**
   * Category createMany
   */
  export type CategoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Categories.
     */
    data: CategoryCreateManyInput | CategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Category createManyAndReturn
   */
  export type CategoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * The data used to create many Categories.
     */
    data: CategoryCreateManyInput | CategoryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Category update
   */
  export type CategoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * The data needed to update a Category.
     */
    data: XOR<CategoryUpdateInput, CategoryUncheckedUpdateInput>
    /**
     * Choose, which Category to update.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category updateMany
   */
  export type CategoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Categories.
     */
    data: XOR<CategoryUpdateManyMutationInput, CategoryUncheckedUpdateManyInput>
    /**
     * Filter which Categories to update
     */
    where?: CategoryWhereInput
    /**
     * Limit how many Categories to update.
     */
    limit?: number
  }

  /**
   * Category updateManyAndReturn
   */
  export type CategoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * The data used to update Categories.
     */
    data: XOR<CategoryUpdateManyMutationInput, CategoryUncheckedUpdateManyInput>
    /**
     * Filter which Categories to update
     */
    where?: CategoryWhereInput
    /**
     * Limit how many Categories to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Category upsert
   */
  export type CategoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * The filter to search for the Category to update in case it exists.
     */
    where: CategoryWhereUniqueInput
    /**
     * In case the Category found by the `where` argument doesn't exist, create a new Category with this data.
     */
    create: XOR<CategoryCreateInput, CategoryUncheckedCreateInput>
    /**
     * In case the Category was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CategoryUpdateInput, CategoryUncheckedUpdateInput>
  }

  /**
   * Category delete
   */
  export type CategoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter which Category to delete.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category deleteMany
   */
  export type CategoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Categories to delete
     */
    where?: CategoryWhereInput
    /**
     * Limit how many Categories to delete.
     */
    limit?: number
  }

  /**
   * Category.parent
   */
  export type Category$parentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    where?: CategoryWhereInput
  }

  /**
   * Category.children
   */
  export type Category$childrenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    where?: CategoryWhereInput
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    cursor?: CategoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Category.guideQuestions
   */
  export type Category$guideQuestionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuideQuestion
     */
    select?: GuideQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GuideQuestion
     */
    omit?: GuideQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuideQuestionInclude<ExtArgs> | null
    where?: GuideQuestionWhereInput
    orderBy?: GuideQuestionOrderByWithRelationInput | GuideQuestionOrderByWithRelationInput[]
    cursor?: GuideQuestionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GuideQuestionScalarFieldEnum | GuideQuestionScalarFieldEnum[]
  }

  /**
   * Category.serviceRequests
   */
  export type Category$serviceRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceRequest
     */
    select?: ServiceRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceRequest
     */
    omit?: ServiceRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceRequestInclude<ExtArgs> | null
    where?: ServiceRequestWhereInput
    orderBy?: ServiceRequestOrderByWithRelationInput | ServiceRequestOrderByWithRelationInput[]
    cursor?: ServiceRequestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ServiceRequestScalarFieldEnum | ServiceRequestScalarFieldEnum[]
  }

  /**
   * Category.workshopCategories
   */
  export type Category$workshopCategoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkshopCategory
     */
    select?: WorkshopCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkshopCategory
     */
    omit?: WorkshopCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkshopCategoryInclude<ExtArgs> | null
    where?: WorkshopCategoryWhereInput
    orderBy?: WorkshopCategoryOrderByWithRelationInput | WorkshopCategoryOrderByWithRelationInput[]
    cursor?: WorkshopCategoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WorkshopCategoryScalarFieldEnum | WorkshopCategoryScalarFieldEnum[]
  }

  /**
   * Category without action
   */
  export type CategoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
  }


  /**
   * Model GuideQuestion
   */

  export type AggregateGuideQuestion = {
    _count: GuideQuestionCountAggregateOutputType | null
    _avg: GuideQuestionAvgAggregateOutputType | null
    _sum: GuideQuestionSumAggregateOutputType | null
    _min: GuideQuestionMinAggregateOutputType | null
    _max: GuideQuestionMaxAggregateOutputType | null
  }

  export type GuideQuestionAvgAggregateOutputType = {
    order: number | null
  }

  export type GuideQuestionSumAggregateOutputType = {
    order: number | null
  }

  export type GuideQuestionMinAggregateOutputType = {
    id: string | null
    categoryId: string | null
    question: string | null
    inputType: string | null
    options: string | null
    order: number | null
    isActive: boolean | null
    createdAt: Date | null
  }

  export type GuideQuestionMaxAggregateOutputType = {
    id: string | null
    categoryId: string | null
    question: string | null
    inputType: string | null
    options: string | null
    order: number | null
    isActive: boolean | null
    createdAt: Date | null
  }

  export type GuideQuestionCountAggregateOutputType = {
    id: number
    categoryId: number
    question: number
    inputType: number
    options: number
    order: number
    isActive: number
    createdAt: number
    _all: number
  }


  export type GuideQuestionAvgAggregateInputType = {
    order?: true
  }

  export type GuideQuestionSumAggregateInputType = {
    order?: true
  }

  export type GuideQuestionMinAggregateInputType = {
    id?: true
    categoryId?: true
    question?: true
    inputType?: true
    options?: true
    order?: true
    isActive?: true
    createdAt?: true
  }

  export type GuideQuestionMaxAggregateInputType = {
    id?: true
    categoryId?: true
    question?: true
    inputType?: true
    options?: true
    order?: true
    isActive?: true
    createdAt?: true
  }

  export type GuideQuestionCountAggregateInputType = {
    id?: true
    categoryId?: true
    question?: true
    inputType?: true
    options?: true
    order?: true
    isActive?: true
    createdAt?: true
    _all?: true
  }

  export type GuideQuestionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GuideQuestion to aggregate.
     */
    where?: GuideQuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GuideQuestions to fetch.
     */
    orderBy?: GuideQuestionOrderByWithRelationInput | GuideQuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GuideQuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GuideQuestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GuideQuestions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned GuideQuestions
    **/
    _count?: true | GuideQuestionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GuideQuestionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GuideQuestionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GuideQuestionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GuideQuestionMaxAggregateInputType
  }

  export type GetGuideQuestionAggregateType<T extends GuideQuestionAggregateArgs> = {
        [P in keyof T & keyof AggregateGuideQuestion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGuideQuestion[P]>
      : GetScalarType<T[P], AggregateGuideQuestion[P]>
  }




  export type GuideQuestionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GuideQuestionWhereInput
    orderBy?: GuideQuestionOrderByWithAggregationInput | GuideQuestionOrderByWithAggregationInput[]
    by: GuideQuestionScalarFieldEnum[] | GuideQuestionScalarFieldEnum
    having?: GuideQuestionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GuideQuestionCountAggregateInputType | true
    _avg?: GuideQuestionAvgAggregateInputType
    _sum?: GuideQuestionSumAggregateInputType
    _min?: GuideQuestionMinAggregateInputType
    _max?: GuideQuestionMaxAggregateInputType
  }

  export type GuideQuestionGroupByOutputType = {
    id: string
    categoryId: string
    question: string
    inputType: string
    options: string | null
    order: number
    isActive: boolean
    createdAt: Date
    _count: GuideQuestionCountAggregateOutputType | null
    _avg: GuideQuestionAvgAggregateOutputType | null
    _sum: GuideQuestionSumAggregateOutputType | null
    _min: GuideQuestionMinAggregateOutputType | null
    _max: GuideQuestionMaxAggregateOutputType | null
  }

  type GetGuideQuestionGroupByPayload<T extends GuideQuestionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GuideQuestionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GuideQuestionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GuideQuestionGroupByOutputType[P]>
            : GetScalarType<T[P], GuideQuestionGroupByOutputType[P]>
        }
      >
    >


  export type GuideQuestionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    categoryId?: boolean
    question?: boolean
    inputType?: boolean
    options?: boolean
    order?: boolean
    isActive?: boolean
    createdAt?: boolean
    category?: boolean | CategoryDefaultArgs<ExtArgs>
    answers?: boolean | GuideQuestion$answersArgs<ExtArgs>
    _count?: boolean | GuideQuestionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["guideQuestion"]>

  export type GuideQuestionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    categoryId?: boolean
    question?: boolean
    inputType?: boolean
    options?: boolean
    order?: boolean
    isActive?: boolean
    createdAt?: boolean
    category?: boolean | CategoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["guideQuestion"]>

  export type GuideQuestionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    categoryId?: boolean
    question?: boolean
    inputType?: boolean
    options?: boolean
    order?: boolean
    isActive?: boolean
    createdAt?: boolean
    category?: boolean | CategoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["guideQuestion"]>

  export type GuideQuestionSelectScalar = {
    id?: boolean
    categoryId?: boolean
    question?: boolean
    inputType?: boolean
    options?: boolean
    order?: boolean
    isActive?: boolean
    createdAt?: boolean
  }

  export type GuideQuestionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "categoryId" | "question" | "inputType" | "options" | "order" | "isActive" | "createdAt", ExtArgs["result"]["guideQuestion"]>
  export type GuideQuestionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    category?: boolean | CategoryDefaultArgs<ExtArgs>
    answers?: boolean | GuideQuestion$answersArgs<ExtArgs>
    _count?: boolean | GuideQuestionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type GuideQuestionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    category?: boolean | CategoryDefaultArgs<ExtArgs>
  }
  export type GuideQuestionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    category?: boolean | CategoryDefaultArgs<ExtArgs>
  }

  export type $GuideQuestionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "GuideQuestion"
    objects: {
      category: Prisma.$CategoryPayload<ExtArgs>
      answers: Prisma.$GuideAnswerPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      categoryId: string
      question: string
      inputType: string
      options: string | null
      order: number
      isActive: boolean
      createdAt: Date
    }, ExtArgs["result"]["guideQuestion"]>
    composites: {}
  }

  type GuideQuestionGetPayload<S extends boolean | null | undefined | GuideQuestionDefaultArgs> = $Result.GetResult<Prisma.$GuideQuestionPayload, S>

  type GuideQuestionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<GuideQuestionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GuideQuestionCountAggregateInputType | true
    }

  export interface GuideQuestionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['GuideQuestion'], meta: { name: 'GuideQuestion' } }
    /**
     * Find zero or one GuideQuestion that matches the filter.
     * @param {GuideQuestionFindUniqueArgs} args - Arguments to find a GuideQuestion
     * @example
     * // Get one GuideQuestion
     * const guideQuestion = await prisma.guideQuestion.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GuideQuestionFindUniqueArgs>(args: SelectSubset<T, GuideQuestionFindUniqueArgs<ExtArgs>>): Prisma__GuideQuestionClient<$Result.GetResult<Prisma.$GuideQuestionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one GuideQuestion that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {GuideQuestionFindUniqueOrThrowArgs} args - Arguments to find a GuideQuestion
     * @example
     * // Get one GuideQuestion
     * const guideQuestion = await prisma.guideQuestion.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GuideQuestionFindUniqueOrThrowArgs>(args: SelectSubset<T, GuideQuestionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GuideQuestionClient<$Result.GetResult<Prisma.$GuideQuestionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GuideQuestion that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuideQuestionFindFirstArgs} args - Arguments to find a GuideQuestion
     * @example
     * // Get one GuideQuestion
     * const guideQuestion = await prisma.guideQuestion.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GuideQuestionFindFirstArgs>(args?: SelectSubset<T, GuideQuestionFindFirstArgs<ExtArgs>>): Prisma__GuideQuestionClient<$Result.GetResult<Prisma.$GuideQuestionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GuideQuestion that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuideQuestionFindFirstOrThrowArgs} args - Arguments to find a GuideQuestion
     * @example
     * // Get one GuideQuestion
     * const guideQuestion = await prisma.guideQuestion.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GuideQuestionFindFirstOrThrowArgs>(args?: SelectSubset<T, GuideQuestionFindFirstOrThrowArgs<ExtArgs>>): Prisma__GuideQuestionClient<$Result.GetResult<Prisma.$GuideQuestionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more GuideQuestions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuideQuestionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GuideQuestions
     * const guideQuestions = await prisma.guideQuestion.findMany()
     * 
     * // Get first 10 GuideQuestions
     * const guideQuestions = await prisma.guideQuestion.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const guideQuestionWithIdOnly = await prisma.guideQuestion.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GuideQuestionFindManyArgs>(args?: SelectSubset<T, GuideQuestionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GuideQuestionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a GuideQuestion.
     * @param {GuideQuestionCreateArgs} args - Arguments to create a GuideQuestion.
     * @example
     * // Create one GuideQuestion
     * const GuideQuestion = await prisma.guideQuestion.create({
     *   data: {
     *     // ... data to create a GuideQuestion
     *   }
     * })
     * 
     */
    create<T extends GuideQuestionCreateArgs>(args: SelectSubset<T, GuideQuestionCreateArgs<ExtArgs>>): Prisma__GuideQuestionClient<$Result.GetResult<Prisma.$GuideQuestionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many GuideQuestions.
     * @param {GuideQuestionCreateManyArgs} args - Arguments to create many GuideQuestions.
     * @example
     * // Create many GuideQuestions
     * const guideQuestion = await prisma.guideQuestion.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GuideQuestionCreateManyArgs>(args?: SelectSubset<T, GuideQuestionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many GuideQuestions and returns the data saved in the database.
     * @param {GuideQuestionCreateManyAndReturnArgs} args - Arguments to create many GuideQuestions.
     * @example
     * // Create many GuideQuestions
     * const guideQuestion = await prisma.guideQuestion.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many GuideQuestions and only return the `id`
     * const guideQuestionWithIdOnly = await prisma.guideQuestion.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GuideQuestionCreateManyAndReturnArgs>(args?: SelectSubset<T, GuideQuestionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GuideQuestionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a GuideQuestion.
     * @param {GuideQuestionDeleteArgs} args - Arguments to delete one GuideQuestion.
     * @example
     * // Delete one GuideQuestion
     * const GuideQuestion = await prisma.guideQuestion.delete({
     *   where: {
     *     // ... filter to delete one GuideQuestion
     *   }
     * })
     * 
     */
    delete<T extends GuideQuestionDeleteArgs>(args: SelectSubset<T, GuideQuestionDeleteArgs<ExtArgs>>): Prisma__GuideQuestionClient<$Result.GetResult<Prisma.$GuideQuestionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one GuideQuestion.
     * @param {GuideQuestionUpdateArgs} args - Arguments to update one GuideQuestion.
     * @example
     * // Update one GuideQuestion
     * const guideQuestion = await prisma.guideQuestion.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GuideQuestionUpdateArgs>(args: SelectSubset<T, GuideQuestionUpdateArgs<ExtArgs>>): Prisma__GuideQuestionClient<$Result.GetResult<Prisma.$GuideQuestionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more GuideQuestions.
     * @param {GuideQuestionDeleteManyArgs} args - Arguments to filter GuideQuestions to delete.
     * @example
     * // Delete a few GuideQuestions
     * const { count } = await prisma.guideQuestion.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GuideQuestionDeleteManyArgs>(args?: SelectSubset<T, GuideQuestionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GuideQuestions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuideQuestionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GuideQuestions
     * const guideQuestion = await prisma.guideQuestion.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GuideQuestionUpdateManyArgs>(args: SelectSubset<T, GuideQuestionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GuideQuestions and returns the data updated in the database.
     * @param {GuideQuestionUpdateManyAndReturnArgs} args - Arguments to update many GuideQuestions.
     * @example
     * // Update many GuideQuestions
     * const guideQuestion = await prisma.guideQuestion.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more GuideQuestions and only return the `id`
     * const guideQuestionWithIdOnly = await prisma.guideQuestion.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends GuideQuestionUpdateManyAndReturnArgs>(args: SelectSubset<T, GuideQuestionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GuideQuestionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one GuideQuestion.
     * @param {GuideQuestionUpsertArgs} args - Arguments to update or create a GuideQuestion.
     * @example
     * // Update or create a GuideQuestion
     * const guideQuestion = await prisma.guideQuestion.upsert({
     *   create: {
     *     // ... data to create a GuideQuestion
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GuideQuestion we want to update
     *   }
     * })
     */
    upsert<T extends GuideQuestionUpsertArgs>(args: SelectSubset<T, GuideQuestionUpsertArgs<ExtArgs>>): Prisma__GuideQuestionClient<$Result.GetResult<Prisma.$GuideQuestionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of GuideQuestions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuideQuestionCountArgs} args - Arguments to filter GuideQuestions to count.
     * @example
     * // Count the number of GuideQuestions
     * const count = await prisma.guideQuestion.count({
     *   where: {
     *     // ... the filter for the GuideQuestions we want to count
     *   }
     * })
    **/
    count<T extends GuideQuestionCountArgs>(
      args?: Subset<T, GuideQuestionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GuideQuestionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a GuideQuestion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuideQuestionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GuideQuestionAggregateArgs>(args: Subset<T, GuideQuestionAggregateArgs>): Prisma.PrismaPromise<GetGuideQuestionAggregateType<T>>

    /**
     * Group by GuideQuestion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuideQuestionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GuideQuestionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GuideQuestionGroupByArgs['orderBy'] }
        : { orderBy?: GuideQuestionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GuideQuestionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGuideQuestionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the GuideQuestion model
   */
  readonly fields: GuideQuestionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for GuideQuestion.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GuideQuestionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    category<T extends CategoryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CategoryDefaultArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    answers<T extends GuideQuestion$answersArgs<ExtArgs> = {}>(args?: Subset<T, GuideQuestion$answersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GuideAnswerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the GuideQuestion model
   */
  interface GuideQuestionFieldRefs {
    readonly id: FieldRef<"GuideQuestion", 'String'>
    readonly categoryId: FieldRef<"GuideQuestion", 'String'>
    readonly question: FieldRef<"GuideQuestion", 'String'>
    readonly inputType: FieldRef<"GuideQuestion", 'String'>
    readonly options: FieldRef<"GuideQuestion", 'String'>
    readonly order: FieldRef<"GuideQuestion", 'Int'>
    readonly isActive: FieldRef<"GuideQuestion", 'Boolean'>
    readonly createdAt: FieldRef<"GuideQuestion", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * GuideQuestion findUnique
   */
  export type GuideQuestionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuideQuestion
     */
    select?: GuideQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GuideQuestion
     */
    omit?: GuideQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuideQuestionInclude<ExtArgs> | null
    /**
     * Filter, which GuideQuestion to fetch.
     */
    where: GuideQuestionWhereUniqueInput
  }

  /**
   * GuideQuestion findUniqueOrThrow
   */
  export type GuideQuestionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuideQuestion
     */
    select?: GuideQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GuideQuestion
     */
    omit?: GuideQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuideQuestionInclude<ExtArgs> | null
    /**
     * Filter, which GuideQuestion to fetch.
     */
    where: GuideQuestionWhereUniqueInput
  }

  /**
   * GuideQuestion findFirst
   */
  export type GuideQuestionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuideQuestion
     */
    select?: GuideQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GuideQuestion
     */
    omit?: GuideQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuideQuestionInclude<ExtArgs> | null
    /**
     * Filter, which GuideQuestion to fetch.
     */
    where?: GuideQuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GuideQuestions to fetch.
     */
    orderBy?: GuideQuestionOrderByWithRelationInput | GuideQuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GuideQuestions.
     */
    cursor?: GuideQuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GuideQuestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GuideQuestions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GuideQuestions.
     */
    distinct?: GuideQuestionScalarFieldEnum | GuideQuestionScalarFieldEnum[]
  }

  /**
   * GuideQuestion findFirstOrThrow
   */
  export type GuideQuestionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuideQuestion
     */
    select?: GuideQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GuideQuestion
     */
    omit?: GuideQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuideQuestionInclude<ExtArgs> | null
    /**
     * Filter, which GuideQuestion to fetch.
     */
    where?: GuideQuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GuideQuestions to fetch.
     */
    orderBy?: GuideQuestionOrderByWithRelationInput | GuideQuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GuideQuestions.
     */
    cursor?: GuideQuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GuideQuestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GuideQuestions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GuideQuestions.
     */
    distinct?: GuideQuestionScalarFieldEnum | GuideQuestionScalarFieldEnum[]
  }

  /**
   * GuideQuestion findMany
   */
  export type GuideQuestionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuideQuestion
     */
    select?: GuideQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GuideQuestion
     */
    omit?: GuideQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuideQuestionInclude<ExtArgs> | null
    /**
     * Filter, which GuideQuestions to fetch.
     */
    where?: GuideQuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GuideQuestions to fetch.
     */
    orderBy?: GuideQuestionOrderByWithRelationInput | GuideQuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing GuideQuestions.
     */
    cursor?: GuideQuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GuideQuestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GuideQuestions.
     */
    skip?: number
    distinct?: GuideQuestionScalarFieldEnum | GuideQuestionScalarFieldEnum[]
  }

  /**
   * GuideQuestion create
   */
  export type GuideQuestionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuideQuestion
     */
    select?: GuideQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GuideQuestion
     */
    omit?: GuideQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuideQuestionInclude<ExtArgs> | null
    /**
     * The data needed to create a GuideQuestion.
     */
    data: XOR<GuideQuestionCreateInput, GuideQuestionUncheckedCreateInput>
  }

  /**
   * GuideQuestion createMany
   */
  export type GuideQuestionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many GuideQuestions.
     */
    data: GuideQuestionCreateManyInput | GuideQuestionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * GuideQuestion createManyAndReturn
   */
  export type GuideQuestionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuideQuestion
     */
    select?: GuideQuestionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GuideQuestion
     */
    omit?: GuideQuestionOmit<ExtArgs> | null
    /**
     * The data used to create many GuideQuestions.
     */
    data: GuideQuestionCreateManyInput | GuideQuestionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuideQuestionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * GuideQuestion update
   */
  export type GuideQuestionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuideQuestion
     */
    select?: GuideQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GuideQuestion
     */
    omit?: GuideQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuideQuestionInclude<ExtArgs> | null
    /**
     * The data needed to update a GuideQuestion.
     */
    data: XOR<GuideQuestionUpdateInput, GuideQuestionUncheckedUpdateInput>
    /**
     * Choose, which GuideQuestion to update.
     */
    where: GuideQuestionWhereUniqueInput
  }

  /**
   * GuideQuestion updateMany
   */
  export type GuideQuestionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update GuideQuestions.
     */
    data: XOR<GuideQuestionUpdateManyMutationInput, GuideQuestionUncheckedUpdateManyInput>
    /**
     * Filter which GuideQuestions to update
     */
    where?: GuideQuestionWhereInput
    /**
     * Limit how many GuideQuestions to update.
     */
    limit?: number
  }

  /**
   * GuideQuestion updateManyAndReturn
   */
  export type GuideQuestionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuideQuestion
     */
    select?: GuideQuestionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GuideQuestion
     */
    omit?: GuideQuestionOmit<ExtArgs> | null
    /**
     * The data used to update GuideQuestions.
     */
    data: XOR<GuideQuestionUpdateManyMutationInput, GuideQuestionUncheckedUpdateManyInput>
    /**
     * Filter which GuideQuestions to update
     */
    where?: GuideQuestionWhereInput
    /**
     * Limit how many GuideQuestions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuideQuestionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * GuideQuestion upsert
   */
  export type GuideQuestionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuideQuestion
     */
    select?: GuideQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GuideQuestion
     */
    omit?: GuideQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuideQuestionInclude<ExtArgs> | null
    /**
     * The filter to search for the GuideQuestion to update in case it exists.
     */
    where: GuideQuestionWhereUniqueInput
    /**
     * In case the GuideQuestion found by the `where` argument doesn't exist, create a new GuideQuestion with this data.
     */
    create: XOR<GuideQuestionCreateInput, GuideQuestionUncheckedCreateInput>
    /**
     * In case the GuideQuestion was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GuideQuestionUpdateInput, GuideQuestionUncheckedUpdateInput>
  }

  /**
   * GuideQuestion delete
   */
  export type GuideQuestionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuideQuestion
     */
    select?: GuideQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GuideQuestion
     */
    omit?: GuideQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuideQuestionInclude<ExtArgs> | null
    /**
     * Filter which GuideQuestion to delete.
     */
    where: GuideQuestionWhereUniqueInput
  }

  /**
   * GuideQuestion deleteMany
   */
  export type GuideQuestionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GuideQuestions to delete
     */
    where?: GuideQuestionWhereInput
    /**
     * Limit how many GuideQuestions to delete.
     */
    limit?: number
  }

  /**
   * GuideQuestion.answers
   */
  export type GuideQuestion$answersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuideAnswer
     */
    select?: GuideAnswerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GuideAnswer
     */
    omit?: GuideAnswerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuideAnswerInclude<ExtArgs> | null
    where?: GuideAnswerWhereInput
    orderBy?: GuideAnswerOrderByWithRelationInput | GuideAnswerOrderByWithRelationInput[]
    cursor?: GuideAnswerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GuideAnswerScalarFieldEnum | GuideAnswerScalarFieldEnum[]
  }

  /**
   * GuideQuestion without action
   */
  export type GuideQuestionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuideQuestion
     */
    select?: GuideQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GuideQuestion
     */
    omit?: GuideQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuideQuestionInclude<ExtArgs> | null
  }


  /**
   * Model GuideAnswer
   */

  export type AggregateGuideAnswer = {
    _count: GuideAnswerCountAggregateOutputType | null
    _min: GuideAnswerMinAggregateOutputType | null
    _max: GuideAnswerMaxAggregateOutputType | null
  }

  export type GuideAnswerMinAggregateOutputType = {
    id: string | null
    questionId: string | null
    requestId: string | null
    answer: string | null
    createdAt: Date | null
  }

  export type GuideAnswerMaxAggregateOutputType = {
    id: string | null
    questionId: string | null
    requestId: string | null
    answer: string | null
    createdAt: Date | null
  }

  export type GuideAnswerCountAggregateOutputType = {
    id: number
    questionId: number
    requestId: number
    answer: number
    createdAt: number
    _all: number
  }


  export type GuideAnswerMinAggregateInputType = {
    id?: true
    questionId?: true
    requestId?: true
    answer?: true
    createdAt?: true
  }

  export type GuideAnswerMaxAggregateInputType = {
    id?: true
    questionId?: true
    requestId?: true
    answer?: true
    createdAt?: true
  }

  export type GuideAnswerCountAggregateInputType = {
    id?: true
    questionId?: true
    requestId?: true
    answer?: true
    createdAt?: true
    _all?: true
  }

  export type GuideAnswerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GuideAnswer to aggregate.
     */
    where?: GuideAnswerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GuideAnswers to fetch.
     */
    orderBy?: GuideAnswerOrderByWithRelationInput | GuideAnswerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GuideAnswerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GuideAnswers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GuideAnswers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned GuideAnswers
    **/
    _count?: true | GuideAnswerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GuideAnswerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GuideAnswerMaxAggregateInputType
  }

  export type GetGuideAnswerAggregateType<T extends GuideAnswerAggregateArgs> = {
        [P in keyof T & keyof AggregateGuideAnswer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGuideAnswer[P]>
      : GetScalarType<T[P], AggregateGuideAnswer[P]>
  }




  export type GuideAnswerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GuideAnswerWhereInput
    orderBy?: GuideAnswerOrderByWithAggregationInput | GuideAnswerOrderByWithAggregationInput[]
    by: GuideAnswerScalarFieldEnum[] | GuideAnswerScalarFieldEnum
    having?: GuideAnswerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GuideAnswerCountAggregateInputType | true
    _min?: GuideAnswerMinAggregateInputType
    _max?: GuideAnswerMaxAggregateInputType
  }

  export type GuideAnswerGroupByOutputType = {
    id: string
    questionId: string
    requestId: string
    answer: string
    createdAt: Date
    _count: GuideAnswerCountAggregateOutputType | null
    _min: GuideAnswerMinAggregateOutputType | null
    _max: GuideAnswerMaxAggregateOutputType | null
  }

  type GetGuideAnswerGroupByPayload<T extends GuideAnswerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GuideAnswerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GuideAnswerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GuideAnswerGroupByOutputType[P]>
            : GetScalarType<T[P], GuideAnswerGroupByOutputType[P]>
        }
      >
    >


  export type GuideAnswerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    questionId?: boolean
    requestId?: boolean
    answer?: boolean
    createdAt?: boolean
    question?: boolean | GuideQuestionDefaultArgs<ExtArgs>
    request?: boolean | ServiceRequestDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["guideAnswer"]>

  export type GuideAnswerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    questionId?: boolean
    requestId?: boolean
    answer?: boolean
    createdAt?: boolean
    question?: boolean | GuideQuestionDefaultArgs<ExtArgs>
    request?: boolean | ServiceRequestDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["guideAnswer"]>

  export type GuideAnswerSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    questionId?: boolean
    requestId?: boolean
    answer?: boolean
    createdAt?: boolean
    question?: boolean | GuideQuestionDefaultArgs<ExtArgs>
    request?: boolean | ServiceRequestDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["guideAnswer"]>

  export type GuideAnswerSelectScalar = {
    id?: boolean
    questionId?: boolean
    requestId?: boolean
    answer?: boolean
    createdAt?: boolean
  }

  export type GuideAnswerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "questionId" | "requestId" | "answer" | "createdAt", ExtArgs["result"]["guideAnswer"]>
  export type GuideAnswerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    question?: boolean | GuideQuestionDefaultArgs<ExtArgs>
    request?: boolean | ServiceRequestDefaultArgs<ExtArgs>
  }
  export type GuideAnswerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    question?: boolean | GuideQuestionDefaultArgs<ExtArgs>
    request?: boolean | ServiceRequestDefaultArgs<ExtArgs>
  }
  export type GuideAnswerIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    question?: boolean | GuideQuestionDefaultArgs<ExtArgs>
    request?: boolean | ServiceRequestDefaultArgs<ExtArgs>
  }

  export type $GuideAnswerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "GuideAnswer"
    objects: {
      question: Prisma.$GuideQuestionPayload<ExtArgs>
      request: Prisma.$ServiceRequestPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      questionId: string
      requestId: string
      answer: string
      createdAt: Date
    }, ExtArgs["result"]["guideAnswer"]>
    composites: {}
  }

  type GuideAnswerGetPayload<S extends boolean | null | undefined | GuideAnswerDefaultArgs> = $Result.GetResult<Prisma.$GuideAnswerPayload, S>

  type GuideAnswerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<GuideAnswerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GuideAnswerCountAggregateInputType | true
    }

  export interface GuideAnswerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['GuideAnswer'], meta: { name: 'GuideAnswer' } }
    /**
     * Find zero or one GuideAnswer that matches the filter.
     * @param {GuideAnswerFindUniqueArgs} args - Arguments to find a GuideAnswer
     * @example
     * // Get one GuideAnswer
     * const guideAnswer = await prisma.guideAnswer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GuideAnswerFindUniqueArgs>(args: SelectSubset<T, GuideAnswerFindUniqueArgs<ExtArgs>>): Prisma__GuideAnswerClient<$Result.GetResult<Prisma.$GuideAnswerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one GuideAnswer that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {GuideAnswerFindUniqueOrThrowArgs} args - Arguments to find a GuideAnswer
     * @example
     * // Get one GuideAnswer
     * const guideAnswer = await prisma.guideAnswer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GuideAnswerFindUniqueOrThrowArgs>(args: SelectSubset<T, GuideAnswerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GuideAnswerClient<$Result.GetResult<Prisma.$GuideAnswerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GuideAnswer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuideAnswerFindFirstArgs} args - Arguments to find a GuideAnswer
     * @example
     * // Get one GuideAnswer
     * const guideAnswer = await prisma.guideAnswer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GuideAnswerFindFirstArgs>(args?: SelectSubset<T, GuideAnswerFindFirstArgs<ExtArgs>>): Prisma__GuideAnswerClient<$Result.GetResult<Prisma.$GuideAnswerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GuideAnswer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuideAnswerFindFirstOrThrowArgs} args - Arguments to find a GuideAnswer
     * @example
     * // Get one GuideAnswer
     * const guideAnswer = await prisma.guideAnswer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GuideAnswerFindFirstOrThrowArgs>(args?: SelectSubset<T, GuideAnswerFindFirstOrThrowArgs<ExtArgs>>): Prisma__GuideAnswerClient<$Result.GetResult<Prisma.$GuideAnswerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more GuideAnswers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuideAnswerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GuideAnswers
     * const guideAnswers = await prisma.guideAnswer.findMany()
     * 
     * // Get first 10 GuideAnswers
     * const guideAnswers = await prisma.guideAnswer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const guideAnswerWithIdOnly = await prisma.guideAnswer.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GuideAnswerFindManyArgs>(args?: SelectSubset<T, GuideAnswerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GuideAnswerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a GuideAnswer.
     * @param {GuideAnswerCreateArgs} args - Arguments to create a GuideAnswer.
     * @example
     * // Create one GuideAnswer
     * const GuideAnswer = await prisma.guideAnswer.create({
     *   data: {
     *     // ... data to create a GuideAnswer
     *   }
     * })
     * 
     */
    create<T extends GuideAnswerCreateArgs>(args: SelectSubset<T, GuideAnswerCreateArgs<ExtArgs>>): Prisma__GuideAnswerClient<$Result.GetResult<Prisma.$GuideAnswerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many GuideAnswers.
     * @param {GuideAnswerCreateManyArgs} args - Arguments to create many GuideAnswers.
     * @example
     * // Create many GuideAnswers
     * const guideAnswer = await prisma.guideAnswer.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GuideAnswerCreateManyArgs>(args?: SelectSubset<T, GuideAnswerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many GuideAnswers and returns the data saved in the database.
     * @param {GuideAnswerCreateManyAndReturnArgs} args - Arguments to create many GuideAnswers.
     * @example
     * // Create many GuideAnswers
     * const guideAnswer = await prisma.guideAnswer.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many GuideAnswers and only return the `id`
     * const guideAnswerWithIdOnly = await prisma.guideAnswer.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GuideAnswerCreateManyAndReturnArgs>(args?: SelectSubset<T, GuideAnswerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GuideAnswerPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a GuideAnswer.
     * @param {GuideAnswerDeleteArgs} args - Arguments to delete one GuideAnswer.
     * @example
     * // Delete one GuideAnswer
     * const GuideAnswer = await prisma.guideAnswer.delete({
     *   where: {
     *     // ... filter to delete one GuideAnswer
     *   }
     * })
     * 
     */
    delete<T extends GuideAnswerDeleteArgs>(args: SelectSubset<T, GuideAnswerDeleteArgs<ExtArgs>>): Prisma__GuideAnswerClient<$Result.GetResult<Prisma.$GuideAnswerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one GuideAnswer.
     * @param {GuideAnswerUpdateArgs} args - Arguments to update one GuideAnswer.
     * @example
     * // Update one GuideAnswer
     * const guideAnswer = await prisma.guideAnswer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GuideAnswerUpdateArgs>(args: SelectSubset<T, GuideAnswerUpdateArgs<ExtArgs>>): Prisma__GuideAnswerClient<$Result.GetResult<Prisma.$GuideAnswerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more GuideAnswers.
     * @param {GuideAnswerDeleteManyArgs} args - Arguments to filter GuideAnswers to delete.
     * @example
     * // Delete a few GuideAnswers
     * const { count } = await prisma.guideAnswer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GuideAnswerDeleteManyArgs>(args?: SelectSubset<T, GuideAnswerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GuideAnswers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuideAnswerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GuideAnswers
     * const guideAnswer = await prisma.guideAnswer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GuideAnswerUpdateManyArgs>(args: SelectSubset<T, GuideAnswerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GuideAnswers and returns the data updated in the database.
     * @param {GuideAnswerUpdateManyAndReturnArgs} args - Arguments to update many GuideAnswers.
     * @example
     * // Update many GuideAnswers
     * const guideAnswer = await prisma.guideAnswer.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more GuideAnswers and only return the `id`
     * const guideAnswerWithIdOnly = await prisma.guideAnswer.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends GuideAnswerUpdateManyAndReturnArgs>(args: SelectSubset<T, GuideAnswerUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GuideAnswerPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one GuideAnswer.
     * @param {GuideAnswerUpsertArgs} args - Arguments to update or create a GuideAnswer.
     * @example
     * // Update or create a GuideAnswer
     * const guideAnswer = await prisma.guideAnswer.upsert({
     *   create: {
     *     // ... data to create a GuideAnswer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GuideAnswer we want to update
     *   }
     * })
     */
    upsert<T extends GuideAnswerUpsertArgs>(args: SelectSubset<T, GuideAnswerUpsertArgs<ExtArgs>>): Prisma__GuideAnswerClient<$Result.GetResult<Prisma.$GuideAnswerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of GuideAnswers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuideAnswerCountArgs} args - Arguments to filter GuideAnswers to count.
     * @example
     * // Count the number of GuideAnswers
     * const count = await prisma.guideAnswer.count({
     *   where: {
     *     // ... the filter for the GuideAnswers we want to count
     *   }
     * })
    **/
    count<T extends GuideAnswerCountArgs>(
      args?: Subset<T, GuideAnswerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GuideAnswerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a GuideAnswer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuideAnswerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GuideAnswerAggregateArgs>(args: Subset<T, GuideAnswerAggregateArgs>): Prisma.PrismaPromise<GetGuideAnswerAggregateType<T>>

    /**
     * Group by GuideAnswer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuideAnswerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GuideAnswerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GuideAnswerGroupByArgs['orderBy'] }
        : { orderBy?: GuideAnswerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GuideAnswerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGuideAnswerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the GuideAnswer model
   */
  readonly fields: GuideAnswerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for GuideAnswer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GuideAnswerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    question<T extends GuideQuestionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GuideQuestionDefaultArgs<ExtArgs>>): Prisma__GuideQuestionClient<$Result.GetResult<Prisma.$GuideQuestionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    request<T extends ServiceRequestDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ServiceRequestDefaultArgs<ExtArgs>>): Prisma__ServiceRequestClient<$Result.GetResult<Prisma.$ServiceRequestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the GuideAnswer model
   */
  interface GuideAnswerFieldRefs {
    readonly id: FieldRef<"GuideAnswer", 'String'>
    readonly questionId: FieldRef<"GuideAnswer", 'String'>
    readonly requestId: FieldRef<"GuideAnswer", 'String'>
    readonly answer: FieldRef<"GuideAnswer", 'String'>
    readonly createdAt: FieldRef<"GuideAnswer", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * GuideAnswer findUnique
   */
  export type GuideAnswerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuideAnswer
     */
    select?: GuideAnswerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GuideAnswer
     */
    omit?: GuideAnswerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuideAnswerInclude<ExtArgs> | null
    /**
     * Filter, which GuideAnswer to fetch.
     */
    where: GuideAnswerWhereUniqueInput
  }

  /**
   * GuideAnswer findUniqueOrThrow
   */
  export type GuideAnswerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuideAnswer
     */
    select?: GuideAnswerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GuideAnswer
     */
    omit?: GuideAnswerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuideAnswerInclude<ExtArgs> | null
    /**
     * Filter, which GuideAnswer to fetch.
     */
    where: GuideAnswerWhereUniqueInput
  }

  /**
   * GuideAnswer findFirst
   */
  export type GuideAnswerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuideAnswer
     */
    select?: GuideAnswerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GuideAnswer
     */
    omit?: GuideAnswerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuideAnswerInclude<ExtArgs> | null
    /**
     * Filter, which GuideAnswer to fetch.
     */
    where?: GuideAnswerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GuideAnswers to fetch.
     */
    orderBy?: GuideAnswerOrderByWithRelationInput | GuideAnswerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GuideAnswers.
     */
    cursor?: GuideAnswerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GuideAnswers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GuideAnswers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GuideAnswers.
     */
    distinct?: GuideAnswerScalarFieldEnum | GuideAnswerScalarFieldEnum[]
  }

  /**
   * GuideAnswer findFirstOrThrow
   */
  export type GuideAnswerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuideAnswer
     */
    select?: GuideAnswerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GuideAnswer
     */
    omit?: GuideAnswerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuideAnswerInclude<ExtArgs> | null
    /**
     * Filter, which GuideAnswer to fetch.
     */
    where?: GuideAnswerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GuideAnswers to fetch.
     */
    orderBy?: GuideAnswerOrderByWithRelationInput | GuideAnswerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GuideAnswers.
     */
    cursor?: GuideAnswerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GuideAnswers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GuideAnswers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GuideAnswers.
     */
    distinct?: GuideAnswerScalarFieldEnum | GuideAnswerScalarFieldEnum[]
  }

  /**
   * GuideAnswer findMany
   */
  export type GuideAnswerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuideAnswer
     */
    select?: GuideAnswerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GuideAnswer
     */
    omit?: GuideAnswerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuideAnswerInclude<ExtArgs> | null
    /**
     * Filter, which GuideAnswers to fetch.
     */
    where?: GuideAnswerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GuideAnswers to fetch.
     */
    orderBy?: GuideAnswerOrderByWithRelationInput | GuideAnswerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing GuideAnswers.
     */
    cursor?: GuideAnswerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GuideAnswers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GuideAnswers.
     */
    skip?: number
    distinct?: GuideAnswerScalarFieldEnum | GuideAnswerScalarFieldEnum[]
  }

  /**
   * GuideAnswer create
   */
  export type GuideAnswerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuideAnswer
     */
    select?: GuideAnswerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GuideAnswer
     */
    omit?: GuideAnswerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuideAnswerInclude<ExtArgs> | null
    /**
     * The data needed to create a GuideAnswer.
     */
    data: XOR<GuideAnswerCreateInput, GuideAnswerUncheckedCreateInput>
  }

  /**
   * GuideAnswer createMany
   */
  export type GuideAnswerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many GuideAnswers.
     */
    data: GuideAnswerCreateManyInput | GuideAnswerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * GuideAnswer createManyAndReturn
   */
  export type GuideAnswerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuideAnswer
     */
    select?: GuideAnswerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GuideAnswer
     */
    omit?: GuideAnswerOmit<ExtArgs> | null
    /**
     * The data used to create many GuideAnswers.
     */
    data: GuideAnswerCreateManyInput | GuideAnswerCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuideAnswerIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * GuideAnswer update
   */
  export type GuideAnswerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuideAnswer
     */
    select?: GuideAnswerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GuideAnswer
     */
    omit?: GuideAnswerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuideAnswerInclude<ExtArgs> | null
    /**
     * The data needed to update a GuideAnswer.
     */
    data: XOR<GuideAnswerUpdateInput, GuideAnswerUncheckedUpdateInput>
    /**
     * Choose, which GuideAnswer to update.
     */
    where: GuideAnswerWhereUniqueInput
  }

  /**
   * GuideAnswer updateMany
   */
  export type GuideAnswerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update GuideAnswers.
     */
    data: XOR<GuideAnswerUpdateManyMutationInput, GuideAnswerUncheckedUpdateManyInput>
    /**
     * Filter which GuideAnswers to update
     */
    where?: GuideAnswerWhereInput
    /**
     * Limit how many GuideAnswers to update.
     */
    limit?: number
  }

  /**
   * GuideAnswer updateManyAndReturn
   */
  export type GuideAnswerUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuideAnswer
     */
    select?: GuideAnswerSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GuideAnswer
     */
    omit?: GuideAnswerOmit<ExtArgs> | null
    /**
     * The data used to update GuideAnswers.
     */
    data: XOR<GuideAnswerUpdateManyMutationInput, GuideAnswerUncheckedUpdateManyInput>
    /**
     * Filter which GuideAnswers to update
     */
    where?: GuideAnswerWhereInput
    /**
     * Limit how many GuideAnswers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuideAnswerIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * GuideAnswer upsert
   */
  export type GuideAnswerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuideAnswer
     */
    select?: GuideAnswerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GuideAnswer
     */
    omit?: GuideAnswerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuideAnswerInclude<ExtArgs> | null
    /**
     * The filter to search for the GuideAnswer to update in case it exists.
     */
    where: GuideAnswerWhereUniqueInput
    /**
     * In case the GuideAnswer found by the `where` argument doesn't exist, create a new GuideAnswer with this data.
     */
    create: XOR<GuideAnswerCreateInput, GuideAnswerUncheckedCreateInput>
    /**
     * In case the GuideAnswer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GuideAnswerUpdateInput, GuideAnswerUncheckedUpdateInput>
  }

  /**
   * GuideAnswer delete
   */
  export type GuideAnswerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuideAnswer
     */
    select?: GuideAnswerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GuideAnswer
     */
    omit?: GuideAnswerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuideAnswerInclude<ExtArgs> | null
    /**
     * Filter which GuideAnswer to delete.
     */
    where: GuideAnswerWhereUniqueInput
  }

  /**
   * GuideAnswer deleteMany
   */
  export type GuideAnswerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GuideAnswers to delete
     */
    where?: GuideAnswerWhereInput
    /**
     * Limit how many GuideAnswers to delete.
     */
    limit?: number
  }

  /**
   * GuideAnswer without action
   */
  export type GuideAnswerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuideAnswer
     */
    select?: GuideAnswerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GuideAnswer
     */
    omit?: GuideAnswerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuideAnswerInclude<ExtArgs> | null
  }


  /**
   * Model ServiceRequest
   */

  export type AggregateServiceRequest = {
    _count: ServiceRequestCountAggregateOutputType | null
    _avg: ServiceRequestAvgAggregateOutputType | null
    _sum: ServiceRequestSumAggregateOutputType | null
    _min: ServiceRequestMinAggregateOutputType | null
    _max: ServiceRequestMaxAggregateOutputType | null
  }

  export type ServiceRequestAvgAggregateOutputType = {
    completionScore: number | null
  }

  export type ServiceRequestSumAggregateOutputType = {
    completionScore: number | null
  }

  export type ServiceRequestMinAggregateOutputType = {
    id: string | null
    userId: string | null
    motorcycleId: string | null
    categoryId: string | null
    description: string | null
    district: string | null
    urgency: $Enums.UrgencyLevel | null
    status: $Enums.ServiceRequestStatus | null
    completionScore: number | null
    expiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ServiceRequestMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    motorcycleId: string | null
    categoryId: string | null
    description: string | null
    district: string | null
    urgency: $Enums.UrgencyLevel | null
    status: $Enums.ServiceRequestStatus | null
    completionScore: number | null
    expiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ServiceRequestCountAggregateOutputType = {
    id: number
    userId: number
    motorcycleId: number
    categoryId: number
    description: number
    district: number
    urgency: number
    status: number
    completionScore: number
    expiresAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ServiceRequestAvgAggregateInputType = {
    completionScore?: true
  }

  export type ServiceRequestSumAggregateInputType = {
    completionScore?: true
  }

  export type ServiceRequestMinAggregateInputType = {
    id?: true
    userId?: true
    motorcycleId?: true
    categoryId?: true
    description?: true
    district?: true
    urgency?: true
    status?: true
    completionScore?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ServiceRequestMaxAggregateInputType = {
    id?: true
    userId?: true
    motorcycleId?: true
    categoryId?: true
    description?: true
    district?: true
    urgency?: true
    status?: true
    completionScore?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ServiceRequestCountAggregateInputType = {
    id?: true
    userId?: true
    motorcycleId?: true
    categoryId?: true
    description?: true
    district?: true
    urgency?: true
    status?: true
    completionScore?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ServiceRequestAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ServiceRequest to aggregate.
     */
    where?: ServiceRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceRequests to fetch.
     */
    orderBy?: ServiceRequestOrderByWithRelationInput | ServiceRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ServiceRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ServiceRequests
    **/
    _count?: true | ServiceRequestCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ServiceRequestAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ServiceRequestSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ServiceRequestMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ServiceRequestMaxAggregateInputType
  }

  export type GetServiceRequestAggregateType<T extends ServiceRequestAggregateArgs> = {
        [P in keyof T & keyof AggregateServiceRequest]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateServiceRequest[P]>
      : GetScalarType<T[P], AggregateServiceRequest[P]>
  }




  export type ServiceRequestGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceRequestWhereInput
    orderBy?: ServiceRequestOrderByWithAggregationInput | ServiceRequestOrderByWithAggregationInput[]
    by: ServiceRequestScalarFieldEnum[] | ServiceRequestScalarFieldEnum
    having?: ServiceRequestScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ServiceRequestCountAggregateInputType | true
    _avg?: ServiceRequestAvgAggregateInputType
    _sum?: ServiceRequestSumAggregateInputType
    _min?: ServiceRequestMinAggregateInputType
    _max?: ServiceRequestMaxAggregateInputType
  }

  export type ServiceRequestGroupByOutputType = {
    id: string
    userId: string
    motorcycleId: string
    categoryId: string
    description: string
    district: string
    urgency: $Enums.UrgencyLevel
    status: $Enums.ServiceRequestStatus
    completionScore: number
    expiresAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: ServiceRequestCountAggregateOutputType | null
    _avg: ServiceRequestAvgAggregateOutputType | null
    _sum: ServiceRequestSumAggregateOutputType | null
    _min: ServiceRequestMinAggregateOutputType | null
    _max: ServiceRequestMaxAggregateOutputType | null
  }

  type GetServiceRequestGroupByPayload<T extends ServiceRequestGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ServiceRequestGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ServiceRequestGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ServiceRequestGroupByOutputType[P]>
            : GetScalarType<T[P], ServiceRequestGroupByOutputType[P]>
        }
      >
    >


  export type ServiceRequestSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    motorcycleId?: boolean
    categoryId?: boolean
    description?: boolean
    district?: boolean
    urgency?: boolean
    status?: boolean
    completionScore?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserProfileDefaultArgs<ExtArgs>
    motorcycle?: boolean | MotorcycleDefaultArgs<ExtArgs>
    category?: boolean | CategoryDefaultArgs<ExtArgs>
    media?: boolean | ServiceRequest$mediaArgs<ExtArgs>
    guideAnswers?: boolean | ServiceRequest$guideAnswersArgs<ExtArgs>
    quotes?: boolean | ServiceRequest$quotesArgs<ExtArgs>
    statusHistory?: boolean | ServiceRequest$statusHistoryArgs<ExtArgs>
    notifications?: boolean | ServiceRequest$notificationsArgs<ExtArgs>
    workOrder?: boolean | ServiceRequest$workOrderArgs<ExtArgs>
    chatMessages?: boolean | ServiceRequest$chatMessagesArgs<ExtArgs>
    aiSuggestions?: boolean | ServiceRequest$aiSuggestionsArgs<ExtArgs>
    _count?: boolean | ServiceRequestCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["serviceRequest"]>

  export type ServiceRequestSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    motorcycleId?: boolean
    categoryId?: boolean
    description?: boolean
    district?: boolean
    urgency?: boolean
    status?: boolean
    completionScore?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserProfileDefaultArgs<ExtArgs>
    motorcycle?: boolean | MotorcycleDefaultArgs<ExtArgs>
    category?: boolean | CategoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["serviceRequest"]>

  export type ServiceRequestSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    motorcycleId?: boolean
    categoryId?: boolean
    description?: boolean
    district?: boolean
    urgency?: boolean
    status?: boolean
    completionScore?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserProfileDefaultArgs<ExtArgs>
    motorcycle?: boolean | MotorcycleDefaultArgs<ExtArgs>
    category?: boolean | CategoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["serviceRequest"]>

  export type ServiceRequestSelectScalar = {
    id?: boolean
    userId?: boolean
    motorcycleId?: boolean
    categoryId?: boolean
    description?: boolean
    district?: boolean
    urgency?: boolean
    status?: boolean
    completionScore?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ServiceRequestOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "motorcycleId" | "categoryId" | "description" | "district" | "urgency" | "status" | "completionScore" | "expiresAt" | "createdAt" | "updatedAt", ExtArgs["result"]["serviceRequest"]>
  export type ServiceRequestInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserProfileDefaultArgs<ExtArgs>
    motorcycle?: boolean | MotorcycleDefaultArgs<ExtArgs>
    category?: boolean | CategoryDefaultArgs<ExtArgs>
    media?: boolean | ServiceRequest$mediaArgs<ExtArgs>
    guideAnswers?: boolean | ServiceRequest$guideAnswersArgs<ExtArgs>
    quotes?: boolean | ServiceRequest$quotesArgs<ExtArgs>
    statusHistory?: boolean | ServiceRequest$statusHistoryArgs<ExtArgs>
    notifications?: boolean | ServiceRequest$notificationsArgs<ExtArgs>
    workOrder?: boolean | ServiceRequest$workOrderArgs<ExtArgs>
    chatMessages?: boolean | ServiceRequest$chatMessagesArgs<ExtArgs>
    aiSuggestions?: boolean | ServiceRequest$aiSuggestionsArgs<ExtArgs>
    _count?: boolean | ServiceRequestCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ServiceRequestIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserProfileDefaultArgs<ExtArgs>
    motorcycle?: boolean | MotorcycleDefaultArgs<ExtArgs>
    category?: boolean | CategoryDefaultArgs<ExtArgs>
  }
  export type ServiceRequestIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserProfileDefaultArgs<ExtArgs>
    motorcycle?: boolean | MotorcycleDefaultArgs<ExtArgs>
    category?: boolean | CategoryDefaultArgs<ExtArgs>
  }

  export type $ServiceRequestPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ServiceRequest"
    objects: {
      user: Prisma.$UserProfilePayload<ExtArgs>
      motorcycle: Prisma.$MotorcyclePayload<ExtArgs>
      category: Prisma.$CategoryPayload<ExtArgs>
      media: Prisma.$RequestMediaPayload<ExtArgs>[]
      guideAnswers: Prisma.$GuideAnswerPayload<ExtArgs>[]
      quotes: Prisma.$QuotePayload<ExtArgs>[]
      statusHistory: Prisma.$RequestStatusHistoryPayload<ExtArgs>[]
      notifications: Prisma.$NotificationPayload<ExtArgs>[]
      workOrder: Prisma.$WorkOrderPayload<ExtArgs> | null
      chatMessages: Prisma.$ChatMessagePayload<ExtArgs>[]
      aiSuggestions: Prisma.$AiSuggestionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      motorcycleId: string
      categoryId: string
      description: string
      district: string
      urgency: $Enums.UrgencyLevel
      status: $Enums.ServiceRequestStatus
      completionScore: number
      expiresAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["serviceRequest"]>
    composites: {}
  }

  type ServiceRequestGetPayload<S extends boolean | null | undefined | ServiceRequestDefaultArgs> = $Result.GetResult<Prisma.$ServiceRequestPayload, S>

  type ServiceRequestCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ServiceRequestFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ServiceRequestCountAggregateInputType | true
    }

  export interface ServiceRequestDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ServiceRequest'], meta: { name: 'ServiceRequest' } }
    /**
     * Find zero or one ServiceRequest that matches the filter.
     * @param {ServiceRequestFindUniqueArgs} args - Arguments to find a ServiceRequest
     * @example
     * // Get one ServiceRequest
     * const serviceRequest = await prisma.serviceRequest.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ServiceRequestFindUniqueArgs>(args: SelectSubset<T, ServiceRequestFindUniqueArgs<ExtArgs>>): Prisma__ServiceRequestClient<$Result.GetResult<Prisma.$ServiceRequestPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ServiceRequest that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ServiceRequestFindUniqueOrThrowArgs} args - Arguments to find a ServiceRequest
     * @example
     * // Get one ServiceRequest
     * const serviceRequest = await prisma.serviceRequest.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ServiceRequestFindUniqueOrThrowArgs>(args: SelectSubset<T, ServiceRequestFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ServiceRequestClient<$Result.GetResult<Prisma.$ServiceRequestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ServiceRequest that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceRequestFindFirstArgs} args - Arguments to find a ServiceRequest
     * @example
     * // Get one ServiceRequest
     * const serviceRequest = await prisma.serviceRequest.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ServiceRequestFindFirstArgs>(args?: SelectSubset<T, ServiceRequestFindFirstArgs<ExtArgs>>): Prisma__ServiceRequestClient<$Result.GetResult<Prisma.$ServiceRequestPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ServiceRequest that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceRequestFindFirstOrThrowArgs} args - Arguments to find a ServiceRequest
     * @example
     * // Get one ServiceRequest
     * const serviceRequest = await prisma.serviceRequest.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ServiceRequestFindFirstOrThrowArgs>(args?: SelectSubset<T, ServiceRequestFindFirstOrThrowArgs<ExtArgs>>): Prisma__ServiceRequestClient<$Result.GetResult<Prisma.$ServiceRequestPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ServiceRequests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceRequestFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ServiceRequests
     * const serviceRequests = await prisma.serviceRequest.findMany()
     * 
     * // Get first 10 ServiceRequests
     * const serviceRequests = await prisma.serviceRequest.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const serviceRequestWithIdOnly = await prisma.serviceRequest.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ServiceRequestFindManyArgs>(args?: SelectSubset<T, ServiceRequestFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceRequestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ServiceRequest.
     * @param {ServiceRequestCreateArgs} args - Arguments to create a ServiceRequest.
     * @example
     * // Create one ServiceRequest
     * const ServiceRequest = await prisma.serviceRequest.create({
     *   data: {
     *     // ... data to create a ServiceRequest
     *   }
     * })
     * 
     */
    create<T extends ServiceRequestCreateArgs>(args: SelectSubset<T, ServiceRequestCreateArgs<ExtArgs>>): Prisma__ServiceRequestClient<$Result.GetResult<Prisma.$ServiceRequestPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ServiceRequests.
     * @param {ServiceRequestCreateManyArgs} args - Arguments to create many ServiceRequests.
     * @example
     * // Create many ServiceRequests
     * const serviceRequest = await prisma.serviceRequest.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ServiceRequestCreateManyArgs>(args?: SelectSubset<T, ServiceRequestCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ServiceRequests and returns the data saved in the database.
     * @param {ServiceRequestCreateManyAndReturnArgs} args - Arguments to create many ServiceRequests.
     * @example
     * // Create many ServiceRequests
     * const serviceRequest = await prisma.serviceRequest.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ServiceRequests and only return the `id`
     * const serviceRequestWithIdOnly = await prisma.serviceRequest.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ServiceRequestCreateManyAndReturnArgs>(args?: SelectSubset<T, ServiceRequestCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceRequestPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ServiceRequest.
     * @param {ServiceRequestDeleteArgs} args - Arguments to delete one ServiceRequest.
     * @example
     * // Delete one ServiceRequest
     * const ServiceRequest = await prisma.serviceRequest.delete({
     *   where: {
     *     // ... filter to delete one ServiceRequest
     *   }
     * })
     * 
     */
    delete<T extends ServiceRequestDeleteArgs>(args: SelectSubset<T, ServiceRequestDeleteArgs<ExtArgs>>): Prisma__ServiceRequestClient<$Result.GetResult<Prisma.$ServiceRequestPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ServiceRequest.
     * @param {ServiceRequestUpdateArgs} args - Arguments to update one ServiceRequest.
     * @example
     * // Update one ServiceRequest
     * const serviceRequest = await prisma.serviceRequest.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ServiceRequestUpdateArgs>(args: SelectSubset<T, ServiceRequestUpdateArgs<ExtArgs>>): Prisma__ServiceRequestClient<$Result.GetResult<Prisma.$ServiceRequestPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ServiceRequests.
     * @param {ServiceRequestDeleteManyArgs} args - Arguments to filter ServiceRequests to delete.
     * @example
     * // Delete a few ServiceRequests
     * const { count } = await prisma.serviceRequest.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ServiceRequestDeleteManyArgs>(args?: SelectSubset<T, ServiceRequestDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ServiceRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceRequestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ServiceRequests
     * const serviceRequest = await prisma.serviceRequest.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ServiceRequestUpdateManyArgs>(args: SelectSubset<T, ServiceRequestUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ServiceRequests and returns the data updated in the database.
     * @param {ServiceRequestUpdateManyAndReturnArgs} args - Arguments to update many ServiceRequests.
     * @example
     * // Update many ServiceRequests
     * const serviceRequest = await prisma.serviceRequest.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ServiceRequests and only return the `id`
     * const serviceRequestWithIdOnly = await prisma.serviceRequest.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ServiceRequestUpdateManyAndReturnArgs>(args: SelectSubset<T, ServiceRequestUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceRequestPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ServiceRequest.
     * @param {ServiceRequestUpsertArgs} args - Arguments to update or create a ServiceRequest.
     * @example
     * // Update or create a ServiceRequest
     * const serviceRequest = await prisma.serviceRequest.upsert({
     *   create: {
     *     // ... data to create a ServiceRequest
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ServiceRequest we want to update
     *   }
     * })
     */
    upsert<T extends ServiceRequestUpsertArgs>(args: SelectSubset<T, ServiceRequestUpsertArgs<ExtArgs>>): Prisma__ServiceRequestClient<$Result.GetResult<Prisma.$ServiceRequestPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ServiceRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceRequestCountArgs} args - Arguments to filter ServiceRequests to count.
     * @example
     * // Count the number of ServiceRequests
     * const count = await prisma.serviceRequest.count({
     *   where: {
     *     // ... the filter for the ServiceRequests we want to count
     *   }
     * })
    **/
    count<T extends ServiceRequestCountArgs>(
      args?: Subset<T, ServiceRequestCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ServiceRequestCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ServiceRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceRequestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ServiceRequestAggregateArgs>(args: Subset<T, ServiceRequestAggregateArgs>): Prisma.PrismaPromise<GetServiceRequestAggregateType<T>>

    /**
     * Group by ServiceRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceRequestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ServiceRequestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ServiceRequestGroupByArgs['orderBy'] }
        : { orderBy?: ServiceRequestGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ServiceRequestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetServiceRequestGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ServiceRequest model
   */
  readonly fields: ServiceRequestFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ServiceRequest.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ServiceRequestClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserProfileDefaultArgs<ExtArgs>>): Prisma__UserProfileClient<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    motorcycle<T extends MotorcycleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MotorcycleDefaultArgs<ExtArgs>>): Prisma__MotorcycleClient<$Result.GetResult<Prisma.$MotorcyclePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    category<T extends CategoryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CategoryDefaultArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    media<T extends ServiceRequest$mediaArgs<ExtArgs> = {}>(args?: Subset<T, ServiceRequest$mediaArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RequestMediaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    guideAnswers<T extends ServiceRequest$guideAnswersArgs<ExtArgs> = {}>(args?: Subset<T, ServiceRequest$guideAnswersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GuideAnswerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    quotes<T extends ServiceRequest$quotesArgs<ExtArgs> = {}>(args?: Subset<T, ServiceRequest$quotesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuotePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    statusHistory<T extends ServiceRequest$statusHistoryArgs<ExtArgs> = {}>(args?: Subset<T, ServiceRequest$statusHistoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RequestStatusHistoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    notifications<T extends ServiceRequest$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, ServiceRequest$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    workOrder<T extends ServiceRequest$workOrderArgs<ExtArgs> = {}>(args?: Subset<T, ServiceRequest$workOrderArgs<ExtArgs>>): Prisma__WorkOrderClient<$Result.GetResult<Prisma.$WorkOrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    chatMessages<T extends ServiceRequest$chatMessagesArgs<ExtArgs> = {}>(args?: Subset<T, ServiceRequest$chatMessagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    aiSuggestions<T extends ServiceRequest$aiSuggestionsArgs<ExtArgs> = {}>(args?: Subset<T, ServiceRequest$aiSuggestionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AiSuggestionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ServiceRequest model
   */
  interface ServiceRequestFieldRefs {
    readonly id: FieldRef<"ServiceRequest", 'String'>
    readonly userId: FieldRef<"ServiceRequest", 'String'>
    readonly motorcycleId: FieldRef<"ServiceRequest", 'String'>
    readonly categoryId: FieldRef<"ServiceRequest", 'String'>
    readonly description: FieldRef<"ServiceRequest", 'String'>
    readonly district: FieldRef<"ServiceRequest", 'String'>
    readonly urgency: FieldRef<"ServiceRequest", 'UrgencyLevel'>
    readonly status: FieldRef<"ServiceRequest", 'ServiceRequestStatus'>
    readonly completionScore: FieldRef<"ServiceRequest", 'Int'>
    readonly expiresAt: FieldRef<"ServiceRequest", 'DateTime'>
    readonly createdAt: FieldRef<"ServiceRequest", 'DateTime'>
    readonly updatedAt: FieldRef<"ServiceRequest", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ServiceRequest findUnique
   */
  export type ServiceRequestFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceRequest
     */
    select?: ServiceRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceRequest
     */
    omit?: ServiceRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceRequestInclude<ExtArgs> | null
    /**
     * Filter, which ServiceRequest to fetch.
     */
    where: ServiceRequestWhereUniqueInput
  }

  /**
   * ServiceRequest findUniqueOrThrow
   */
  export type ServiceRequestFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceRequest
     */
    select?: ServiceRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceRequest
     */
    omit?: ServiceRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceRequestInclude<ExtArgs> | null
    /**
     * Filter, which ServiceRequest to fetch.
     */
    where: ServiceRequestWhereUniqueInput
  }

  /**
   * ServiceRequest findFirst
   */
  export type ServiceRequestFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceRequest
     */
    select?: ServiceRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceRequest
     */
    omit?: ServiceRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceRequestInclude<ExtArgs> | null
    /**
     * Filter, which ServiceRequest to fetch.
     */
    where?: ServiceRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceRequests to fetch.
     */
    orderBy?: ServiceRequestOrderByWithRelationInput | ServiceRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ServiceRequests.
     */
    cursor?: ServiceRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ServiceRequests.
     */
    distinct?: ServiceRequestScalarFieldEnum | ServiceRequestScalarFieldEnum[]
  }

  /**
   * ServiceRequest findFirstOrThrow
   */
  export type ServiceRequestFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceRequest
     */
    select?: ServiceRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceRequest
     */
    omit?: ServiceRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceRequestInclude<ExtArgs> | null
    /**
     * Filter, which ServiceRequest to fetch.
     */
    where?: ServiceRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceRequests to fetch.
     */
    orderBy?: ServiceRequestOrderByWithRelationInput | ServiceRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ServiceRequests.
     */
    cursor?: ServiceRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ServiceRequests.
     */
    distinct?: ServiceRequestScalarFieldEnum | ServiceRequestScalarFieldEnum[]
  }

  /**
   * ServiceRequest findMany
   */
  export type ServiceRequestFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceRequest
     */
    select?: ServiceRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceRequest
     */
    omit?: ServiceRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceRequestInclude<ExtArgs> | null
    /**
     * Filter, which ServiceRequests to fetch.
     */
    where?: ServiceRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceRequests to fetch.
     */
    orderBy?: ServiceRequestOrderByWithRelationInput | ServiceRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ServiceRequests.
     */
    cursor?: ServiceRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceRequests.
     */
    skip?: number
    distinct?: ServiceRequestScalarFieldEnum | ServiceRequestScalarFieldEnum[]
  }

  /**
   * ServiceRequest create
   */
  export type ServiceRequestCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceRequest
     */
    select?: ServiceRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceRequest
     */
    omit?: ServiceRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceRequestInclude<ExtArgs> | null
    /**
     * The data needed to create a ServiceRequest.
     */
    data: XOR<ServiceRequestCreateInput, ServiceRequestUncheckedCreateInput>
  }

  /**
   * ServiceRequest createMany
   */
  export type ServiceRequestCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ServiceRequests.
     */
    data: ServiceRequestCreateManyInput | ServiceRequestCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ServiceRequest createManyAndReturn
   */
  export type ServiceRequestCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceRequest
     */
    select?: ServiceRequestSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceRequest
     */
    omit?: ServiceRequestOmit<ExtArgs> | null
    /**
     * The data used to create many ServiceRequests.
     */
    data: ServiceRequestCreateManyInput | ServiceRequestCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceRequestIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ServiceRequest update
   */
  export type ServiceRequestUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceRequest
     */
    select?: ServiceRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceRequest
     */
    omit?: ServiceRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceRequestInclude<ExtArgs> | null
    /**
     * The data needed to update a ServiceRequest.
     */
    data: XOR<ServiceRequestUpdateInput, ServiceRequestUncheckedUpdateInput>
    /**
     * Choose, which ServiceRequest to update.
     */
    where: ServiceRequestWhereUniqueInput
  }

  /**
   * ServiceRequest updateMany
   */
  export type ServiceRequestUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ServiceRequests.
     */
    data: XOR<ServiceRequestUpdateManyMutationInput, ServiceRequestUncheckedUpdateManyInput>
    /**
     * Filter which ServiceRequests to update
     */
    where?: ServiceRequestWhereInput
    /**
     * Limit how many ServiceRequests to update.
     */
    limit?: number
  }

  /**
   * ServiceRequest updateManyAndReturn
   */
  export type ServiceRequestUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceRequest
     */
    select?: ServiceRequestSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceRequest
     */
    omit?: ServiceRequestOmit<ExtArgs> | null
    /**
     * The data used to update ServiceRequests.
     */
    data: XOR<ServiceRequestUpdateManyMutationInput, ServiceRequestUncheckedUpdateManyInput>
    /**
     * Filter which ServiceRequests to update
     */
    where?: ServiceRequestWhereInput
    /**
     * Limit how many ServiceRequests to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceRequestIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ServiceRequest upsert
   */
  export type ServiceRequestUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceRequest
     */
    select?: ServiceRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceRequest
     */
    omit?: ServiceRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceRequestInclude<ExtArgs> | null
    /**
     * The filter to search for the ServiceRequest to update in case it exists.
     */
    where: ServiceRequestWhereUniqueInput
    /**
     * In case the ServiceRequest found by the `where` argument doesn't exist, create a new ServiceRequest with this data.
     */
    create: XOR<ServiceRequestCreateInput, ServiceRequestUncheckedCreateInput>
    /**
     * In case the ServiceRequest was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ServiceRequestUpdateInput, ServiceRequestUncheckedUpdateInput>
  }

  /**
   * ServiceRequest delete
   */
  export type ServiceRequestDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceRequest
     */
    select?: ServiceRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceRequest
     */
    omit?: ServiceRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceRequestInclude<ExtArgs> | null
    /**
     * Filter which ServiceRequest to delete.
     */
    where: ServiceRequestWhereUniqueInput
  }

  /**
   * ServiceRequest deleteMany
   */
  export type ServiceRequestDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ServiceRequests to delete
     */
    where?: ServiceRequestWhereInput
    /**
     * Limit how many ServiceRequests to delete.
     */
    limit?: number
  }

  /**
   * ServiceRequest.media
   */
  export type ServiceRequest$mediaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequestMedia
     */
    select?: RequestMediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RequestMedia
     */
    omit?: RequestMediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestMediaInclude<ExtArgs> | null
    where?: RequestMediaWhereInput
    orderBy?: RequestMediaOrderByWithRelationInput | RequestMediaOrderByWithRelationInput[]
    cursor?: RequestMediaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RequestMediaScalarFieldEnum | RequestMediaScalarFieldEnum[]
  }

  /**
   * ServiceRequest.guideAnswers
   */
  export type ServiceRequest$guideAnswersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuideAnswer
     */
    select?: GuideAnswerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GuideAnswer
     */
    omit?: GuideAnswerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuideAnswerInclude<ExtArgs> | null
    where?: GuideAnswerWhereInput
    orderBy?: GuideAnswerOrderByWithRelationInput | GuideAnswerOrderByWithRelationInput[]
    cursor?: GuideAnswerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GuideAnswerScalarFieldEnum | GuideAnswerScalarFieldEnum[]
  }

  /**
   * ServiceRequest.quotes
   */
  export type ServiceRequest$quotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quote
     */
    select?: QuoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quote
     */
    omit?: QuoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteInclude<ExtArgs> | null
    where?: QuoteWhereInput
    orderBy?: QuoteOrderByWithRelationInput | QuoteOrderByWithRelationInput[]
    cursor?: QuoteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuoteScalarFieldEnum | QuoteScalarFieldEnum[]
  }

  /**
   * ServiceRequest.statusHistory
   */
  export type ServiceRequest$statusHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequestStatusHistory
     */
    select?: RequestStatusHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the RequestStatusHistory
     */
    omit?: RequestStatusHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestStatusHistoryInclude<ExtArgs> | null
    where?: RequestStatusHistoryWhereInput
    orderBy?: RequestStatusHistoryOrderByWithRelationInput | RequestStatusHistoryOrderByWithRelationInput[]
    cursor?: RequestStatusHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RequestStatusHistoryScalarFieldEnum | RequestStatusHistoryScalarFieldEnum[]
  }

  /**
   * ServiceRequest.notifications
   */
  export type ServiceRequest$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * ServiceRequest.workOrder
   */
  export type ServiceRequest$workOrderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkOrder
     */
    select?: WorkOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkOrder
     */
    omit?: WorkOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkOrderInclude<ExtArgs> | null
    where?: WorkOrderWhereInput
  }

  /**
   * ServiceRequest.chatMessages
   */
  export type ServiceRequest$chatMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatMessage
     */
    omit?: ChatMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageInclude<ExtArgs> | null
    where?: ChatMessageWhereInput
    orderBy?: ChatMessageOrderByWithRelationInput | ChatMessageOrderByWithRelationInput[]
    cursor?: ChatMessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChatMessageScalarFieldEnum | ChatMessageScalarFieldEnum[]
  }

  /**
   * ServiceRequest.aiSuggestions
   */
  export type ServiceRequest$aiSuggestionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiSuggestion
     */
    select?: AiSuggestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiSuggestion
     */
    omit?: AiSuggestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiSuggestionInclude<ExtArgs> | null
    where?: AiSuggestionWhereInput
    orderBy?: AiSuggestionOrderByWithRelationInput | AiSuggestionOrderByWithRelationInput[]
    cursor?: AiSuggestionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AiSuggestionScalarFieldEnum | AiSuggestionScalarFieldEnum[]
  }

  /**
   * ServiceRequest without action
   */
  export type ServiceRequestDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceRequest
     */
    select?: ServiceRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceRequest
     */
    omit?: ServiceRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceRequestInclude<ExtArgs> | null
  }


  /**
   * Model RequestMedia
   */

  export type AggregateRequestMedia = {
    _count: RequestMediaCountAggregateOutputType | null
    _avg: RequestMediaAvgAggregateOutputType | null
    _sum: RequestMediaSumAggregateOutputType | null
    _min: RequestMediaMinAggregateOutputType | null
    _max: RequestMediaMaxAggregateOutputType | null
  }

  export type RequestMediaAvgAggregateOutputType = {
    fileSize: number | null
  }

  export type RequestMediaSumAggregateOutputType = {
    fileSize: number | null
  }

  export type RequestMediaMinAggregateOutputType = {
    id: string | null
    requestId: string | null
    url: string | null
    mediaType: $Enums.MediaType | null
    fileName: string | null
    fileSize: number | null
    createdAt: Date | null
  }

  export type RequestMediaMaxAggregateOutputType = {
    id: string | null
    requestId: string | null
    url: string | null
    mediaType: $Enums.MediaType | null
    fileName: string | null
    fileSize: number | null
    createdAt: Date | null
  }

  export type RequestMediaCountAggregateOutputType = {
    id: number
    requestId: number
    url: number
    mediaType: number
    fileName: number
    fileSize: number
    createdAt: number
    _all: number
  }


  export type RequestMediaAvgAggregateInputType = {
    fileSize?: true
  }

  export type RequestMediaSumAggregateInputType = {
    fileSize?: true
  }

  export type RequestMediaMinAggregateInputType = {
    id?: true
    requestId?: true
    url?: true
    mediaType?: true
    fileName?: true
    fileSize?: true
    createdAt?: true
  }

  export type RequestMediaMaxAggregateInputType = {
    id?: true
    requestId?: true
    url?: true
    mediaType?: true
    fileName?: true
    fileSize?: true
    createdAt?: true
  }

  export type RequestMediaCountAggregateInputType = {
    id?: true
    requestId?: true
    url?: true
    mediaType?: true
    fileName?: true
    fileSize?: true
    createdAt?: true
    _all?: true
  }

  export type RequestMediaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RequestMedia to aggregate.
     */
    where?: RequestMediaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RequestMedias to fetch.
     */
    orderBy?: RequestMediaOrderByWithRelationInput | RequestMediaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RequestMediaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RequestMedias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RequestMedias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RequestMedias
    **/
    _count?: true | RequestMediaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RequestMediaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RequestMediaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RequestMediaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RequestMediaMaxAggregateInputType
  }

  export type GetRequestMediaAggregateType<T extends RequestMediaAggregateArgs> = {
        [P in keyof T & keyof AggregateRequestMedia]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRequestMedia[P]>
      : GetScalarType<T[P], AggregateRequestMedia[P]>
  }




  export type RequestMediaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RequestMediaWhereInput
    orderBy?: RequestMediaOrderByWithAggregationInput | RequestMediaOrderByWithAggregationInput[]
    by: RequestMediaScalarFieldEnum[] | RequestMediaScalarFieldEnum
    having?: RequestMediaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RequestMediaCountAggregateInputType | true
    _avg?: RequestMediaAvgAggregateInputType
    _sum?: RequestMediaSumAggregateInputType
    _min?: RequestMediaMinAggregateInputType
    _max?: RequestMediaMaxAggregateInputType
  }

  export type RequestMediaGroupByOutputType = {
    id: string
    requestId: string
    url: string
    mediaType: $Enums.MediaType
    fileName: string | null
    fileSize: number | null
    createdAt: Date
    _count: RequestMediaCountAggregateOutputType | null
    _avg: RequestMediaAvgAggregateOutputType | null
    _sum: RequestMediaSumAggregateOutputType | null
    _min: RequestMediaMinAggregateOutputType | null
    _max: RequestMediaMaxAggregateOutputType | null
  }

  type GetRequestMediaGroupByPayload<T extends RequestMediaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RequestMediaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RequestMediaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RequestMediaGroupByOutputType[P]>
            : GetScalarType<T[P], RequestMediaGroupByOutputType[P]>
        }
      >
    >


  export type RequestMediaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    requestId?: boolean
    url?: boolean
    mediaType?: boolean
    fileName?: boolean
    fileSize?: boolean
    createdAt?: boolean
    request?: boolean | ServiceRequestDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["requestMedia"]>

  export type RequestMediaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    requestId?: boolean
    url?: boolean
    mediaType?: boolean
    fileName?: boolean
    fileSize?: boolean
    createdAt?: boolean
    request?: boolean | ServiceRequestDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["requestMedia"]>

  export type RequestMediaSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    requestId?: boolean
    url?: boolean
    mediaType?: boolean
    fileName?: boolean
    fileSize?: boolean
    createdAt?: boolean
    request?: boolean | ServiceRequestDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["requestMedia"]>

  export type RequestMediaSelectScalar = {
    id?: boolean
    requestId?: boolean
    url?: boolean
    mediaType?: boolean
    fileName?: boolean
    fileSize?: boolean
    createdAt?: boolean
  }

  export type RequestMediaOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "requestId" | "url" | "mediaType" | "fileName" | "fileSize" | "createdAt", ExtArgs["result"]["requestMedia"]>
  export type RequestMediaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    request?: boolean | ServiceRequestDefaultArgs<ExtArgs>
  }
  export type RequestMediaIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    request?: boolean | ServiceRequestDefaultArgs<ExtArgs>
  }
  export type RequestMediaIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    request?: boolean | ServiceRequestDefaultArgs<ExtArgs>
  }

  export type $RequestMediaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RequestMedia"
    objects: {
      request: Prisma.$ServiceRequestPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      requestId: string
      url: string
      mediaType: $Enums.MediaType
      fileName: string | null
      fileSize: number | null
      createdAt: Date
    }, ExtArgs["result"]["requestMedia"]>
    composites: {}
  }

  type RequestMediaGetPayload<S extends boolean | null | undefined | RequestMediaDefaultArgs> = $Result.GetResult<Prisma.$RequestMediaPayload, S>

  type RequestMediaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RequestMediaFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RequestMediaCountAggregateInputType | true
    }

  export interface RequestMediaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RequestMedia'], meta: { name: 'RequestMedia' } }
    /**
     * Find zero or one RequestMedia that matches the filter.
     * @param {RequestMediaFindUniqueArgs} args - Arguments to find a RequestMedia
     * @example
     * // Get one RequestMedia
     * const requestMedia = await prisma.requestMedia.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RequestMediaFindUniqueArgs>(args: SelectSubset<T, RequestMediaFindUniqueArgs<ExtArgs>>): Prisma__RequestMediaClient<$Result.GetResult<Prisma.$RequestMediaPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RequestMedia that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RequestMediaFindUniqueOrThrowArgs} args - Arguments to find a RequestMedia
     * @example
     * // Get one RequestMedia
     * const requestMedia = await prisma.requestMedia.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RequestMediaFindUniqueOrThrowArgs>(args: SelectSubset<T, RequestMediaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RequestMediaClient<$Result.GetResult<Prisma.$RequestMediaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RequestMedia that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestMediaFindFirstArgs} args - Arguments to find a RequestMedia
     * @example
     * // Get one RequestMedia
     * const requestMedia = await prisma.requestMedia.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RequestMediaFindFirstArgs>(args?: SelectSubset<T, RequestMediaFindFirstArgs<ExtArgs>>): Prisma__RequestMediaClient<$Result.GetResult<Prisma.$RequestMediaPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RequestMedia that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestMediaFindFirstOrThrowArgs} args - Arguments to find a RequestMedia
     * @example
     * // Get one RequestMedia
     * const requestMedia = await prisma.requestMedia.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RequestMediaFindFirstOrThrowArgs>(args?: SelectSubset<T, RequestMediaFindFirstOrThrowArgs<ExtArgs>>): Prisma__RequestMediaClient<$Result.GetResult<Prisma.$RequestMediaPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RequestMedias that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestMediaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RequestMedias
     * const requestMedias = await prisma.requestMedia.findMany()
     * 
     * // Get first 10 RequestMedias
     * const requestMedias = await prisma.requestMedia.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const requestMediaWithIdOnly = await prisma.requestMedia.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RequestMediaFindManyArgs>(args?: SelectSubset<T, RequestMediaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RequestMediaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RequestMedia.
     * @param {RequestMediaCreateArgs} args - Arguments to create a RequestMedia.
     * @example
     * // Create one RequestMedia
     * const RequestMedia = await prisma.requestMedia.create({
     *   data: {
     *     // ... data to create a RequestMedia
     *   }
     * })
     * 
     */
    create<T extends RequestMediaCreateArgs>(args: SelectSubset<T, RequestMediaCreateArgs<ExtArgs>>): Prisma__RequestMediaClient<$Result.GetResult<Prisma.$RequestMediaPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RequestMedias.
     * @param {RequestMediaCreateManyArgs} args - Arguments to create many RequestMedias.
     * @example
     * // Create many RequestMedias
     * const requestMedia = await prisma.requestMedia.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RequestMediaCreateManyArgs>(args?: SelectSubset<T, RequestMediaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RequestMedias and returns the data saved in the database.
     * @param {RequestMediaCreateManyAndReturnArgs} args - Arguments to create many RequestMedias.
     * @example
     * // Create many RequestMedias
     * const requestMedia = await prisma.requestMedia.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RequestMedias and only return the `id`
     * const requestMediaWithIdOnly = await prisma.requestMedia.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RequestMediaCreateManyAndReturnArgs>(args?: SelectSubset<T, RequestMediaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RequestMediaPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RequestMedia.
     * @param {RequestMediaDeleteArgs} args - Arguments to delete one RequestMedia.
     * @example
     * // Delete one RequestMedia
     * const RequestMedia = await prisma.requestMedia.delete({
     *   where: {
     *     // ... filter to delete one RequestMedia
     *   }
     * })
     * 
     */
    delete<T extends RequestMediaDeleteArgs>(args: SelectSubset<T, RequestMediaDeleteArgs<ExtArgs>>): Prisma__RequestMediaClient<$Result.GetResult<Prisma.$RequestMediaPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RequestMedia.
     * @param {RequestMediaUpdateArgs} args - Arguments to update one RequestMedia.
     * @example
     * // Update one RequestMedia
     * const requestMedia = await prisma.requestMedia.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RequestMediaUpdateArgs>(args: SelectSubset<T, RequestMediaUpdateArgs<ExtArgs>>): Prisma__RequestMediaClient<$Result.GetResult<Prisma.$RequestMediaPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RequestMedias.
     * @param {RequestMediaDeleteManyArgs} args - Arguments to filter RequestMedias to delete.
     * @example
     * // Delete a few RequestMedias
     * const { count } = await prisma.requestMedia.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RequestMediaDeleteManyArgs>(args?: SelectSubset<T, RequestMediaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RequestMedias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestMediaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RequestMedias
     * const requestMedia = await prisma.requestMedia.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RequestMediaUpdateManyArgs>(args: SelectSubset<T, RequestMediaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RequestMedias and returns the data updated in the database.
     * @param {RequestMediaUpdateManyAndReturnArgs} args - Arguments to update many RequestMedias.
     * @example
     * // Update many RequestMedias
     * const requestMedia = await prisma.requestMedia.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RequestMedias and only return the `id`
     * const requestMediaWithIdOnly = await prisma.requestMedia.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RequestMediaUpdateManyAndReturnArgs>(args: SelectSubset<T, RequestMediaUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RequestMediaPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RequestMedia.
     * @param {RequestMediaUpsertArgs} args - Arguments to update or create a RequestMedia.
     * @example
     * // Update or create a RequestMedia
     * const requestMedia = await prisma.requestMedia.upsert({
     *   create: {
     *     // ... data to create a RequestMedia
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RequestMedia we want to update
     *   }
     * })
     */
    upsert<T extends RequestMediaUpsertArgs>(args: SelectSubset<T, RequestMediaUpsertArgs<ExtArgs>>): Prisma__RequestMediaClient<$Result.GetResult<Prisma.$RequestMediaPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RequestMedias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestMediaCountArgs} args - Arguments to filter RequestMedias to count.
     * @example
     * // Count the number of RequestMedias
     * const count = await prisma.requestMedia.count({
     *   where: {
     *     // ... the filter for the RequestMedias we want to count
     *   }
     * })
    **/
    count<T extends RequestMediaCountArgs>(
      args?: Subset<T, RequestMediaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RequestMediaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RequestMedia.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestMediaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RequestMediaAggregateArgs>(args: Subset<T, RequestMediaAggregateArgs>): Prisma.PrismaPromise<GetRequestMediaAggregateType<T>>

    /**
     * Group by RequestMedia.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestMediaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RequestMediaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RequestMediaGroupByArgs['orderBy'] }
        : { orderBy?: RequestMediaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RequestMediaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRequestMediaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RequestMedia model
   */
  readonly fields: RequestMediaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RequestMedia.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RequestMediaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    request<T extends ServiceRequestDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ServiceRequestDefaultArgs<ExtArgs>>): Prisma__ServiceRequestClient<$Result.GetResult<Prisma.$ServiceRequestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RequestMedia model
   */
  interface RequestMediaFieldRefs {
    readonly id: FieldRef<"RequestMedia", 'String'>
    readonly requestId: FieldRef<"RequestMedia", 'String'>
    readonly url: FieldRef<"RequestMedia", 'String'>
    readonly mediaType: FieldRef<"RequestMedia", 'MediaType'>
    readonly fileName: FieldRef<"RequestMedia", 'String'>
    readonly fileSize: FieldRef<"RequestMedia", 'Int'>
    readonly createdAt: FieldRef<"RequestMedia", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RequestMedia findUnique
   */
  export type RequestMediaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequestMedia
     */
    select?: RequestMediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RequestMedia
     */
    omit?: RequestMediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestMediaInclude<ExtArgs> | null
    /**
     * Filter, which RequestMedia to fetch.
     */
    where: RequestMediaWhereUniqueInput
  }

  /**
   * RequestMedia findUniqueOrThrow
   */
  export type RequestMediaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequestMedia
     */
    select?: RequestMediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RequestMedia
     */
    omit?: RequestMediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestMediaInclude<ExtArgs> | null
    /**
     * Filter, which RequestMedia to fetch.
     */
    where: RequestMediaWhereUniqueInput
  }

  /**
   * RequestMedia findFirst
   */
  export type RequestMediaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequestMedia
     */
    select?: RequestMediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RequestMedia
     */
    omit?: RequestMediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestMediaInclude<ExtArgs> | null
    /**
     * Filter, which RequestMedia to fetch.
     */
    where?: RequestMediaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RequestMedias to fetch.
     */
    orderBy?: RequestMediaOrderByWithRelationInput | RequestMediaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RequestMedias.
     */
    cursor?: RequestMediaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RequestMedias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RequestMedias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RequestMedias.
     */
    distinct?: RequestMediaScalarFieldEnum | RequestMediaScalarFieldEnum[]
  }

  /**
   * RequestMedia findFirstOrThrow
   */
  export type RequestMediaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequestMedia
     */
    select?: RequestMediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RequestMedia
     */
    omit?: RequestMediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestMediaInclude<ExtArgs> | null
    /**
     * Filter, which RequestMedia to fetch.
     */
    where?: RequestMediaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RequestMedias to fetch.
     */
    orderBy?: RequestMediaOrderByWithRelationInput | RequestMediaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RequestMedias.
     */
    cursor?: RequestMediaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RequestMedias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RequestMedias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RequestMedias.
     */
    distinct?: RequestMediaScalarFieldEnum | RequestMediaScalarFieldEnum[]
  }

  /**
   * RequestMedia findMany
   */
  export type RequestMediaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequestMedia
     */
    select?: RequestMediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RequestMedia
     */
    omit?: RequestMediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestMediaInclude<ExtArgs> | null
    /**
     * Filter, which RequestMedias to fetch.
     */
    where?: RequestMediaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RequestMedias to fetch.
     */
    orderBy?: RequestMediaOrderByWithRelationInput | RequestMediaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RequestMedias.
     */
    cursor?: RequestMediaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RequestMedias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RequestMedias.
     */
    skip?: number
    distinct?: RequestMediaScalarFieldEnum | RequestMediaScalarFieldEnum[]
  }

  /**
   * RequestMedia create
   */
  export type RequestMediaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequestMedia
     */
    select?: RequestMediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RequestMedia
     */
    omit?: RequestMediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestMediaInclude<ExtArgs> | null
    /**
     * The data needed to create a RequestMedia.
     */
    data: XOR<RequestMediaCreateInput, RequestMediaUncheckedCreateInput>
  }

  /**
   * RequestMedia createMany
   */
  export type RequestMediaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RequestMedias.
     */
    data: RequestMediaCreateManyInput | RequestMediaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RequestMedia createManyAndReturn
   */
  export type RequestMediaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequestMedia
     */
    select?: RequestMediaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RequestMedia
     */
    omit?: RequestMediaOmit<ExtArgs> | null
    /**
     * The data used to create many RequestMedias.
     */
    data: RequestMediaCreateManyInput | RequestMediaCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestMediaIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RequestMedia update
   */
  export type RequestMediaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequestMedia
     */
    select?: RequestMediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RequestMedia
     */
    omit?: RequestMediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestMediaInclude<ExtArgs> | null
    /**
     * The data needed to update a RequestMedia.
     */
    data: XOR<RequestMediaUpdateInput, RequestMediaUncheckedUpdateInput>
    /**
     * Choose, which RequestMedia to update.
     */
    where: RequestMediaWhereUniqueInput
  }

  /**
   * RequestMedia updateMany
   */
  export type RequestMediaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RequestMedias.
     */
    data: XOR<RequestMediaUpdateManyMutationInput, RequestMediaUncheckedUpdateManyInput>
    /**
     * Filter which RequestMedias to update
     */
    where?: RequestMediaWhereInput
    /**
     * Limit how many RequestMedias to update.
     */
    limit?: number
  }

  /**
   * RequestMedia updateManyAndReturn
   */
  export type RequestMediaUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequestMedia
     */
    select?: RequestMediaSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RequestMedia
     */
    omit?: RequestMediaOmit<ExtArgs> | null
    /**
     * The data used to update RequestMedias.
     */
    data: XOR<RequestMediaUpdateManyMutationInput, RequestMediaUncheckedUpdateManyInput>
    /**
     * Filter which RequestMedias to update
     */
    where?: RequestMediaWhereInput
    /**
     * Limit how many RequestMedias to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestMediaIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * RequestMedia upsert
   */
  export type RequestMediaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequestMedia
     */
    select?: RequestMediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RequestMedia
     */
    omit?: RequestMediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestMediaInclude<ExtArgs> | null
    /**
     * The filter to search for the RequestMedia to update in case it exists.
     */
    where: RequestMediaWhereUniqueInput
    /**
     * In case the RequestMedia found by the `where` argument doesn't exist, create a new RequestMedia with this data.
     */
    create: XOR<RequestMediaCreateInput, RequestMediaUncheckedCreateInput>
    /**
     * In case the RequestMedia was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RequestMediaUpdateInput, RequestMediaUncheckedUpdateInput>
  }

  /**
   * RequestMedia delete
   */
  export type RequestMediaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequestMedia
     */
    select?: RequestMediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RequestMedia
     */
    omit?: RequestMediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestMediaInclude<ExtArgs> | null
    /**
     * Filter which RequestMedia to delete.
     */
    where: RequestMediaWhereUniqueInput
  }

  /**
   * RequestMedia deleteMany
   */
  export type RequestMediaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RequestMedias to delete
     */
    where?: RequestMediaWhereInput
    /**
     * Limit how many RequestMedias to delete.
     */
    limit?: number
  }

  /**
   * RequestMedia without action
   */
  export type RequestMediaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequestMedia
     */
    select?: RequestMediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RequestMedia
     */
    omit?: RequestMediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestMediaInclude<ExtArgs> | null
  }


  /**
   * Model RequestStatusHistory
   */

  export type AggregateRequestStatusHistory = {
    _count: RequestStatusHistoryCountAggregateOutputType | null
    _min: RequestStatusHistoryMinAggregateOutputType | null
    _max: RequestStatusHistoryMaxAggregateOutputType | null
  }

  export type RequestStatusHistoryMinAggregateOutputType = {
    id: string | null
    requestId: string | null
    fromStatus: $Enums.ServiceRequestStatus | null
    toStatus: $Enums.ServiceRequestStatus | null
    actorId: string | null
    reason: string | null
    createdAt: Date | null
  }

  export type RequestStatusHistoryMaxAggregateOutputType = {
    id: string | null
    requestId: string | null
    fromStatus: $Enums.ServiceRequestStatus | null
    toStatus: $Enums.ServiceRequestStatus | null
    actorId: string | null
    reason: string | null
    createdAt: Date | null
  }

  export type RequestStatusHistoryCountAggregateOutputType = {
    id: number
    requestId: number
    fromStatus: number
    toStatus: number
    actorId: number
    reason: number
    createdAt: number
    _all: number
  }


  export type RequestStatusHistoryMinAggregateInputType = {
    id?: true
    requestId?: true
    fromStatus?: true
    toStatus?: true
    actorId?: true
    reason?: true
    createdAt?: true
  }

  export type RequestStatusHistoryMaxAggregateInputType = {
    id?: true
    requestId?: true
    fromStatus?: true
    toStatus?: true
    actorId?: true
    reason?: true
    createdAt?: true
  }

  export type RequestStatusHistoryCountAggregateInputType = {
    id?: true
    requestId?: true
    fromStatus?: true
    toStatus?: true
    actorId?: true
    reason?: true
    createdAt?: true
    _all?: true
  }

  export type RequestStatusHistoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RequestStatusHistory to aggregate.
     */
    where?: RequestStatusHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RequestStatusHistories to fetch.
     */
    orderBy?: RequestStatusHistoryOrderByWithRelationInput | RequestStatusHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RequestStatusHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RequestStatusHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RequestStatusHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RequestStatusHistories
    **/
    _count?: true | RequestStatusHistoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RequestStatusHistoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RequestStatusHistoryMaxAggregateInputType
  }

  export type GetRequestStatusHistoryAggregateType<T extends RequestStatusHistoryAggregateArgs> = {
        [P in keyof T & keyof AggregateRequestStatusHistory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRequestStatusHistory[P]>
      : GetScalarType<T[P], AggregateRequestStatusHistory[P]>
  }




  export type RequestStatusHistoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RequestStatusHistoryWhereInput
    orderBy?: RequestStatusHistoryOrderByWithAggregationInput | RequestStatusHistoryOrderByWithAggregationInput[]
    by: RequestStatusHistoryScalarFieldEnum[] | RequestStatusHistoryScalarFieldEnum
    having?: RequestStatusHistoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RequestStatusHistoryCountAggregateInputType | true
    _min?: RequestStatusHistoryMinAggregateInputType
    _max?: RequestStatusHistoryMaxAggregateInputType
  }

  export type RequestStatusHistoryGroupByOutputType = {
    id: string
    requestId: string
    fromStatus: $Enums.ServiceRequestStatus | null
    toStatus: $Enums.ServiceRequestStatus
    actorId: string | null
    reason: string | null
    createdAt: Date
    _count: RequestStatusHistoryCountAggregateOutputType | null
    _min: RequestStatusHistoryMinAggregateOutputType | null
    _max: RequestStatusHistoryMaxAggregateOutputType | null
  }

  type GetRequestStatusHistoryGroupByPayload<T extends RequestStatusHistoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RequestStatusHistoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RequestStatusHistoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RequestStatusHistoryGroupByOutputType[P]>
            : GetScalarType<T[P], RequestStatusHistoryGroupByOutputType[P]>
        }
      >
    >


  export type RequestStatusHistorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    requestId?: boolean
    fromStatus?: boolean
    toStatus?: boolean
    actorId?: boolean
    reason?: boolean
    createdAt?: boolean
    request?: boolean | ServiceRequestDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["requestStatusHistory"]>

  export type RequestStatusHistorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    requestId?: boolean
    fromStatus?: boolean
    toStatus?: boolean
    actorId?: boolean
    reason?: boolean
    createdAt?: boolean
    request?: boolean | ServiceRequestDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["requestStatusHistory"]>

  export type RequestStatusHistorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    requestId?: boolean
    fromStatus?: boolean
    toStatus?: boolean
    actorId?: boolean
    reason?: boolean
    createdAt?: boolean
    request?: boolean | ServiceRequestDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["requestStatusHistory"]>

  export type RequestStatusHistorySelectScalar = {
    id?: boolean
    requestId?: boolean
    fromStatus?: boolean
    toStatus?: boolean
    actorId?: boolean
    reason?: boolean
    createdAt?: boolean
  }

  export type RequestStatusHistoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "requestId" | "fromStatus" | "toStatus" | "actorId" | "reason" | "createdAt", ExtArgs["result"]["requestStatusHistory"]>
  export type RequestStatusHistoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    request?: boolean | ServiceRequestDefaultArgs<ExtArgs>
  }
  export type RequestStatusHistoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    request?: boolean | ServiceRequestDefaultArgs<ExtArgs>
  }
  export type RequestStatusHistoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    request?: boolean | ServiceRequestDefaultArgs<ExtArgs>
  }

  export type $RequestStatusHistoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RequestStatusHistory"
    objects: {
      request: Prisma.$ServiceRequestPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      requestId: string
      fromStatus: $Enums.ServiceRequestStatus | null
      toStatus: $Enums.ServiceRequestStatus
      actorId: string | null
      reason: string | null
      createdAt: Date
    }, ExtArgs["result"]["requestStatusHistory"]>
    composites: {}
  }

  type RequestStatusHistoryGetPayload<S extends boolean | null | undefined | RequestStatusHistoryDefaultArgs> = $Result.GetResult<Prisma.$RequestStatusHistoryPayload, S>

  type RequestStatusHistoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RequestStatusHistoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RequestStatusHistoryCountAggregateInputType | true
    }

  export interface RequestStatusHistoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RequestStatusHistory'], meta: { name: 'RequestStatusHistory' } }
    /**
     * Find zero or one RequestStatusHistory that matches the filter.
     * @param {RequestStatusHistoryFindUniqueArgs} args - Arguments to find a RequestStatusHistory
     * @example
     * // Get one RequestStatusHistory
     * const requestStatusHistory = await prisma.requestStatusHistory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RequestStatusHistoryFindUniqueArgs>(args: SelectSubset<T, RequestStatusHistoryFindUniqueArgs<ExtArgs>>): Prisma__RequestStatusHistoryClient<$Result.GetResult<Prisma.$RequestStatusHistoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RequestStatusHistory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RequestStatusHistoryFindUniqueOrThrowArgs} args - Arguments to find a RequestStatusHistory
     * @example
     * // Get one RequestStatusHistory
     * const requestStatusHistory = await prisma.requestStatusHistory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RequestStatusHistoryFindUniqueOrThrowArgs>(args: SelectSubset<T, RequestStatusHistoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RequestStatusHistoryClient<$Result.GetResult<Prisma.$RequestStatusHistoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RequestStatusHistory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestStatusHistoryFindFirstArgs} args - Arguments to find a RequestStatusHistory
     * @example
     * // Get one RequestStatusHistory
     * const requestStatusHistory = await prisma.requestStatusHistory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RequestStatusHistoryFindFirstArgs>(args?: SelectSubset<T, RequestStatusHistoryFindFirstArgs<ExtArgs>>): Prisma__RequestStatusHistoryClient<$Result.GetResult<Prisma.$RequestStatusHistoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RequestStatusHistory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestStatusHistoryFindFirstOrThrowArgs} args - Arguments to find a RequestStatusHistory
     * @example
     * // Get one RequestStatusHistory
     * const requestStatusHistory = await prisma.requestStatusHistory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RequestStatusHistoryFindFirstOrThrowArgs>(args?: SelectSubset<T, RequestStatusHistoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__RequestStatusHistoryClient<$Result.GetResult<Prisma.$RequestStatusHistoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RequestStatusHistories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestStatusHistoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RequestStatusHistories
     * const requestStatusHistories = await prisma.requestStatusHistory.findMany()
     * 
     * // Get first 10 RequestStatusHistories
     * const requestStatusHistories = await prisma.requestStatusHistory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const requestStatusHistoryWithIdOnly = await prisma.requestStatusHistory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RequestStatusHistoryFindManyArgs>(args?: SelectSubset<T, RequestStatusHistoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RequestStatusHistoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RequestStatusHistory.
     * @param {RequestStatusHistoryCreateArgs} args - Arguments to create a RequestStatusHistory.
     * @example
     * // Create one RequestStatusHistory
     * const RequestStatusHistory = await prisma.requestStatusHistory.create({
     *   data: {
     *     // ... data to create a RequestStatusHistory
     *   }
     * })
     * 
     */
    create<T extends RequestStatusHistoryCreateArgs>(args: SelectSubset<T, RequestStatusHistoryCreateArgs<ExtArgs>>): Prisma__RequestStatusHistoryClient<$Result.GetResult<Prisma.$RequestStatusHistoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RequestStatusHistories.
     * @param {RequestStatusHistoryCreateManyArgs} args - Arguments to create many RequestStatusHistories.
     * @example
     * // Create many RequestStatusHistories
     * const requestStatusHistory = await prisma.requestStatusHistory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RequestStatusHistoryCreateManyArgs>(args?: SelectSubset<T, RequestStatusHistoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RequestStatusHistories and returns the data saved in the database.
     * @param {RequestStatusHistoryCreateManyAndReturnArgs} args - Arguments to create many RequestStatusHistories.
     * @example
     * // Create many RequestStatusHistories
     * const requestStatusHistory = await prisma.requestStatusHistory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RequestStatusHistories and only return the `id`
     * const requestStatusHistoryWithIdOnly = await prisma.requestStatusHistory.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RequestStatusHistoryCreateManyAndReturnArgs>(args?: SelectSubset<T, RequestStatusHistoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RequestStatusHistoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RequestStatusHistory.
     * @param {RequestStatusHistoryDeleteArgs} args - Arguments to delete one RequestStatusHistory.
     * @example
     * // Delete one RequestStatusHistory
     * const RequestStatusHistory = await prisma.requestStatusHistory.delete({
     *   where: {
     *     // ... filter to delete one RequestStatusHistory
     *   }
     * })
     * 
     */
    delete<T extends RequestStatusHistoryDeleteArgs>(args: SelectSubset<T, RequestStatusHistoryDeleteArgs<ExtArgs>>): Prisma__RequestStatusHistoryClient<$Result.GetResult<Prisma.$RequestStatusHistoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RequestStatusHistory.
     * @param {RequestStatusHistoryUpdateArgs} args - Arguments to update one RequestStatusHistory.
     * @example
     * // Update one RequestStatusHistory
     * const requestStatusHistory = await prisma.requestStatusHistory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RequestStatusHistoryUpdateArgs>(args: SelectSubset<T, RequestStatusHistoryUpdateArgs<ExtArgs>>): Prisma__RequestStatusHistoryClient<$Result.GetResult<Prisma.$RequestStatusHistoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RequestStatusHistories.
     * @param {RequestStatusHistoryDeleteManyArgs} args - Arguments to filter RequestStatusHistories to delete.
     * @example
     * // Delete a few RequestStatusHistories
     * const { count } = await prisma.requestStatusHistory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RequestStatusHistoryDeleteManyArgs>(args?: SelectSubset<T, RequestStatusHistoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RequestStatusHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestStatusHistoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RequestStatusHistories
     * const requestStatusHistory = await prisma.requestStatusHistory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RequestStatusHistoryUpdateManyArgs>(args: SelectSubset<T, RequestStatusHistoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RequestStatusHistories and returns the data updated in the database.
     * @param {RequestStatusHistoryUpdateManyAndReturnArgs} args - Arguments to update many RequestStatusHistories.
     * @example
     * // Update many RequestStatusHistories
     * const requestStatusHistory = await prisma.requestStatusHistory.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RequestStatusHistories and only return the `id`
     * const requestStatusHistoryWithIdOnly = await prisma.requestStatusHistory.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RequestStatusHistoryUpdateManyAndReturnArgs>(args: SelectSubset<T, RequestStatusHistoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RequestStatusHistoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RequestStatusHistory.
     * @param {RequestStatusHistoryUpsertArgs} args - Arguments to update or create a RequestStatusHistory.
     * @example
     * // Update or create a RequestStatusHistory
     * const requestStatusHistory = await prisma.requestStatusHistory.upsert({
     *   create: {
     *     // ... data to create a RequestStatusHistory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RequestStatusHistory we want to update
     *   }
     * })
     */
    upsert<T extends RequestStatusHistoryUpsertArgs>(args: SelectSubset<T, RequestStatusHistoryUpsertArgs<ExtArgs>>): Prisma__RequestStatusHistoryClient<$Result.GetResult<Prisma.$RequestStatusHistoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RequestStatusHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestStatusHistoryCountArgs} args - Arguments to filter RequestStatusHistories to count.
     * @example
     * // Count the number of RequestStatusHistories
     * const count = await prisma.requestStatusHistory.count({
     *   where: {
     *     // ... the filter for the RequestStatusHistories we want to count
     *   }
     * })
    **/
    count<T extends RequestStatusHistoryCountArgs>(
      args?: Subset<T, RequestStatusHistoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RequestStatusHistoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RequestStatusHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestStatusHistoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RequestStatusHistoryAggregateArgs>(args: Subset<T, RequestStatusHistoryAggregateArgs>): Prisma.PrismaPromise<GetRequestStatusHistoryAggregateType<T>>

    /**
     * Group by RequestStatusHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestStatusHistoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RequestStatusHistoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RequestStatusHistoryGroupByArgs['orderBy'] }
        : { orderBy?: RequestStatusHistoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RequestStatusHistoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRequestStatusHistoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RequestStatusHistory model
   */
  readonly fields: RequestStatusHistoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RequestStatusHistory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RequestStatusHistoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    request<T extends ServiceRequestDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ServiceRequestDefaultArgs<ExtArgs>>): Prisma__ServiceRequestClient<$Result.GetResult<Prisma.$ServiceRequestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RequestStatusHistory model
   */
  interface RequestStatusHistoryFieldRefs {
    readonly id: FieldRef<"RequestStatusHistory", 'String'>
    readonly requestId: FieldRef<"RequestStatusHistory", 'String'>
    readonly fromStatus: FieldRef<"RequestStatusHistory", 'ServiceRequestStatus'>
    readonly toStatus: FieldRef<"RequestStatusHistory", 'ServiceRequestStatus'>
    readonly actorId: FieldRef<"RequestStatusHistory", 'String'>
    readonly reason: FieldRef<"RequestStatusHistory", 'String'>
    readonly createdAt: FieldRef<"RequestStatusHistory", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RequestStatusHistory findUnique
   */
  export type RequestStatusHistoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequestStatusHistory
     */
    select?: RequestStatusHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the RequestStatusHistory
     */
    omit?: RequestStatusHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestStatusHistoryInclude<ExtArgs> | null
    /**
     * Filter, which RequestStatusHistory to fetch.
     */
    where: RequestStatusHistoryWhereUniqueInput
  }

  /**
   * RequestStatusHistory findUniqueOrThrow
   */
  export type RequestStatusHistoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequestStatusHistory
     */
    select?: RequestStatusHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the RequestStatusHistory
     */
    omit?: RequestStatusHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestStatusHistoryInclude<ExtArgs> | null
    /**
     * Filter, which RequestStatusHistory to fetch.
     */
    where: RequestStatusHistoryWhereUniqueInput
  }

  /**
   * RequestStatusHistory findFirst
   */
  export type RequestStatusHistoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequestStatusHistory
     */
    select?: RequestStatusHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the RequestStatusHistory
     */
    omit?: RequestStatusHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestStatusHistoryInclude<ExtArgs> | null
    /**
     * Filter, which RequestStatusHistory to fetch.
     */
    where?: RequestStatusHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RequestStatusHistories to fetch.
     */
    orderBy?: RequestStatusHistoryOrderByWithRelationInput | RequestStatusHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RequestStatusHistories.
     */
    cursor?: RequestStatusHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RequestStatusHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RequestStatusHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RequestStatusHistories.
     */
    distinct?: RequestStatusHistoryScalarFieldEnum | RequestStatusHistoryScalarFieldEnum[]
  }

  /**
   * RequestStatusHistory findFirstOrThrow
   */
  export type RequestStatusHistoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequestStatusHistory
     */
    select?: RequestStatusHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the RequestStatusHistory
     */
    omit?: RequestStatusHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestStatusHistoryInclude<ExtArgs> | null
    /**
     * Filter, which RequestStatusHistory to fetch.
     */
    where?: RequestStatusHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RequestStatusHistories to fetch.
     */
    orderBy?: RequestStatusHistoryOrderByWithRelationInput | RequestStatusHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RequestStatusHistories.
     */
    cursor?: RequestStatusHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RequestStatusHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RequestStatusHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RequestStatusHistories.
     */
    distinct?: RequestStatusHistoryScalarFieldEnum | RequestStatusHistoryScalarFieldEnum[]
  }

  /**
   * RequestStatusHistory findMany
   */
  export type RequestStatusHistoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequestStatusHistory
     */
    select?: RequestStatusHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the RequestStatusHistory
     */
    omit?: RequestStatusHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestStatusHistoryInclude<ExtArgs> | null
    /**
     * Filter, which RequestStatusHistories to fetch.
     */
    where?: RequestStatusHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RequestStatusHistories to fetch.
     */
    orderBy?: RequestStatusHistoryOrderByWithRelationInput | RequestStatusHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RequestStatusHistories.
     */
    cursor?: RequestStatusHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RequestStatusHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RequestStatusHistories.
     */
    skip?: number
    distinct?: RequestStatusHistoryScalarFieldEnum | RequestStatusHistoryScalarFieldEnum[]
  }

  /**
   * RequestStatusHistory create
   */
  export type RequestStatusHistoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequestStatusHistory
     */
    select?: RequestStatusHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the RequestStatusHistory
     */
    omit?: RequestStatusHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestStatusHistoryInclude<ExtArgs> | null
    /**
     * The data needed to create a RequestStatusHistory.
     */
    data: XOR<RequestStatusHistoryCreateInput, RequestStatusHistoryUncheckedCreateInput>
  }

  /**
   * RequestStatusHistory createMany
   */
  export type RequestStatusHistoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RequestStatusHistories.
     */
    data: RequestStatusHistoryCreateManyInput | RequestStatusHistoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RequestStatusHistory createManyAndReturn
   */
  export type RequestStatusHistoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequestStatusHistory
     */
    select?: RequestStatusHistorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RequestStatusHistory
     */
    omit?: RequestStatusHistoryOmit<ExtArgs> | null
    /**
     * The data used to create many RequestStatusHistories.
     */
    data: RequestStatusHistoryCreateManyInput | RequestStatusHistoryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestStatusHistoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RequestStatusHistory update
   */
  export type RequestStatusHistoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequestStatusHistory
     */
    select?: RequestStatusHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the RequestStatusHistory
     */
    omit?: RequestStatusHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestStatusHistoryInclude<ExtArgs> | null
    /**
     * The data needed to update a RequestStatusHistory.
     */
    data: XOR<RequestStatusHistoryUpdateInput, RequestStatusHistoryUncheckedUpdateInput>
    /**
     * Choose, which RequestStatusHistory to update.
     */
    where: RequestStatusHistoryWhereUniqueInput
  }

  /**
   * RequestStatusHistory updateMany
   */
  export type RequestStatusHistoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RequestStatusHistories.
     */
    data: XOR<RequestStatusHistoryUpdateManyMutationInput, RequestStatusHistoryUncheckedUpdateManyInput>
    /**
     * Filter which RequestStatusHistories to update
     */
    where?: RequestStatusHistoryWhereInput
    /**
     * Limit how many RequestStatusHistories to update.
     */
    limit?: number
  }

  /**
   * RequestStatusHistory updateManyAndReturn
   */
  export type RequestStatusHistoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequestStatusHistory
     */
    select?: RequestStatusHistorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RequestStatusHistory
     */
    omit?: RequestStatusHistoryOmit<ExtArgs> | null
    /**
     * The data used to update RequestStatusHistories.
     */
    data: XOR<RequestStatusHistoryUpdateManyMutationInput, RequestStatusHistoryUncheckedUpdateManyInput>
    /**
     * Filter which RequestStatusHistories to update
     */
    where?: RequestStatusHistoryWhereInput
    /**
     * Limit how many RequestStatusHistories to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestStatusHistoryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * RequestStatusHistory upsert
   */
  export type RequestStatusHistoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequestStatusHistory
     */
    select?: RequestStatusHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the RequestStatusHistory
     */
    omit?: RequestStatusHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestStatusHistoryInclude<ExtArgs> | null
    /**
     * The filter to search for the RequestStatusHistory to update in case it exists.
     */
    where: RequestStatusHistoryWhereUniqueInput
    /**
     * In case the RequestStatusHistory found by the `where` argument doesn't exist, create a new RequestStatusHistory with this data.
     */
    create: XOR<RequestStatusHistoryCreateInput, RequestStatusHistoryUncheckedCreateInput>
    /**
     * In case the RequestStatusHistory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RequestStatusHistoryUpdateInput, RequestStatusHistoryUncheckedUpdateInput>
  }

  /**
   * RequestStatusHistory delete
   */
  export type RequestStatusHistoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequestStatusHistory
     */
    select?: RequestStatusHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the RequestStatusHistory
     */
    omit?: RequestStatusHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestStatusHistoryInclude<ExtArgs> | null
    /**
     * Filter which RequestStatusHistory to delete.
     */
    where: RequestStatusHistoryWhereUniqueInput
  }

  /**
   * RequestStatusHistory deleteMany
   */
  export type RequestStatusHistoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RequestStatusHistories to delete
     */
    where?: RequestStatusHistoryWhereInput
    /**
     * Limit how many RequestStatusHistories to delete.
     */
    limit?: number
  }

  /**
   * RequestStatusHistory without action
   */
  export type RequestStatusHistoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequestStatusHistory
     */
    select?: RequestStatusHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the RequestStatusHistory
     */
    omit?: RequestStatusHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestStatusHistoryInclude<ExtArgs> | null
  }


  /**
   * Model Workshop
   */

  export type AggregateWorkshop = {
    _count: WorkshopCountAggregateOutputType | null
    _avg: WorkshopAvgAggregateOutputType | null
    _sum: WorkshopSumAggregateOutputType | null
    _min: WorkshopMinAggregateOutputType | null
    _max: WorkshopMaxAggregateOutputType | null
  }

  export type WorkshopAvgAggregateOutputType = {
    latitude: number | null
    longitude: number | null
    rating: number | null
    totalServices: number | null
    evidenceRate: number | null
  }

  export type WorkshopSumAggregateOutputType = {
    latitude: number | null
    longitude: number | null
    rating: number | null
    totalServices: number | null
    evidenceRate: number | null
  }

  export type WorkshopMinAggregateOutputType = {
    id: string | null
    userId: string | null
    name: string | null
    address: string | null
    district: string | null
    phone: string | null
    ruc: string | null
    description: string | null
    photoUrl: string | null
    status: $Enums.WorkshopStatus | null
    transparencyAccepted: boolean | null
    guaranteePolicy: string | null
    latitude: number | null
    longitude: number | null
    rating: number | null
    totalServices: number | null
    evidenceRate: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WorkshopMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    name: string | null
    address: string | null
    district: string | null
    phone: string | null
    ruc: string | null
    description: string | null
    photoUrl: string | null
    status: $Enums.WorkshopStatus | null
    transparencyAccepted: boolean | null
    guaranteePolicy: string | null
    latitude: number | null
    longitude: number | null
    rating: number | null
    totalServices: number | null
    evidenceRate: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WorkshopCountAggregateOutputType = {
    id: number
    userId: number
    name: number
    address: number
    district: number
    phone: number
    ruc: number
    description: number
    photoUrl: number
    status: number
    transparencyAccepted: number
    guaranteePolicy: number
    latitude: number
    longitude: number
    rating: number
    totalServices: number
    evidenceRate: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type WorkshopAvgAggregateInputType = {
    latitude?: true
    longitude?: true
    rating?: true
    totalServices?: true
    evidenceRate?: true
  }

  export type WorkshopSumAggregateInputType = {
    latitude?: true
    longitude?: true
    rating?: true
    totalServices?: true
    evidenceRate?: true
  }

  export type WorkshopMinAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    address?: true
    district?: true
    phone?: true
    ruc?: true
    description?: true
    photoUrl?: true
    status?: true
    transparencyAccepted?: true
    guaranteePolicy?: true
    latitude?: true
    longitude?: true
    rating?: true
    totalServices?: true
    evidenceRate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WorkshopMaxAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    address?: true
    district?: true
    phone?: true
    ruc?: true
    description?: true
    photoUrl?: true
    status?: true
    transparencyAccepted?: true
    guaranteePolicy?: true
    latitude?: true
    longitude?: true
    rating?: true
    totalServices?: true
    evidenceRate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WorkshopCountAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    address?: true
    district?: true
    phone?: true
    ruc?: true
    description?: true
    photoUrl?: true
    status?: true
    transparencyAccepted?: true
    guaranteePolicy?: true
    latitude?: true
    longitude?: true
    rating?: true
    totalServices?: true
    evidenceRate?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type WorkshopAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Workshop to aggregate.
     */
    where?: WorkshopWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Workshops to fetch.
     */
    orderBy?: WorkshopOrderByWithRelationInput | WorkshopOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WorkshopWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Workshops from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Workshops.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Workshops
    **/
    _count?: true | WorkshopCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WorkshopAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WorkshopSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WorkshopMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WorkshopMaxAggregateInputType
  }

  export type GetWorkshopAggregateType<T extends WorkshopAggregateArgs> = {
        [P in keyof T & keyof AggregateWorkshop]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWorkshop[P]>
      : GetScalarType<T[P], AggregateWorkshop[P]>
  }




  export type WorkshopGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkshopWhereInput
    orderBy?: WorkshopOrderByWithAggregationInput | WorkshopOrderByWithAggregationInput[]
    by: WorkshopScalarFieldEnum[] | WorkshopScalarFieldEnum
    having?: WorkshopScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WorkshopCountAggregateInputType | true
    _avg?: WorkshopAvgAggregateInputType
    _sum?: WorkshopSumAggregateInputType
    _min?: WorkshopMinAggregateInputType
    _max?: WorkshopMaxAggregateInputType
  }

  export type WorkshopGroupByOutputType = {
    id: string
    userId: string
    name: string
    address: string
    district: string
    phone: string
    ruc: string | null
    description: string | null
    photoUrl: string | null
    status: $Enums.WorkshopStatus
    transparencyAccepted: boolean
    guaranteePolicy: string | null
    latitude: number | null
    longitude: number | null
    rating: number
    totalServices: number
    evidenceRate: number
    createdAt: Date
    updatedAt: Date
    _count: WorkshopCountAggregateOutputType | null
    _avg: WorkshopAvgAggregateOutputType | null
    _sum: WorkshopSumAggregateOutputType | null
    _min: WorkshopMinAggregateOutputType | null
    _max: WorkshopMaxAggregateOutputType | null
  }

  type GetWorkshopGroupByPayload<T extends WorkshopGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WorkshopGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WorkshopGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WorkshopGroupByOutputType[P]>
            : GetScalarType<T[P], WorkshopGroupByOutputType[P]>
        }
      >
    >


  export type WorkshopSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    name?: boolean
    address?: boolean
    district?: boolean
    phone?: boolean
    ruc?: boolean
    description?: boolean
    photoUrl?: boolean
    status?: boolean
    transparencyAccepted?: boolean
    guaranteePolicy?: boolean
    latitude?: boolean
    longitude?: boolean
    rating?: boolean
    totalServices?: boolean
    evidenceRate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserProfileDefaultArgs<ExtArgs>
    categories?: boolean | Workshop$categoriesArgs<ExtArgs>
    quotes?: boolean | Workshop$quotesArgs<ExtArgs>
    workOrders?: boolean | Workshop$workOrdersArgs<ExtArgs>
    reviews?: boolean | Workshop$reviewsArgs<ExtArgs>
    incidentReports?: boolean | Workshop$incidentReportsArgs<ExtArgs>
    verifications?: boolean | Workshop$verificationsArgs<ExtArgs>
    _count?: boolean | WorkshopCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workshop"]>

  export type WorkshopSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    name?: boolean
    address?: boolean
    district?: boolean
    phone?: boolean
    ruc?: boolean
    description?: boolean
    photoUrl?: boolean
    status?: boolean
    transparencyAccepted?: boolean
    guaranteePolicy?: boolean
    latitude?: boolean
    longitude?: boolean
    rating?: boolean
    totalServices?: boolean
    evidenceRate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workshop"]>

  export type WorkshopSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    name?: boolean
    address?: boolean
    district?: boolean
    phone?: boolean
    ruc?: boolean
    description?: boolean
    photoUrl?: boolean
    status?: boolean
    transparencyAccepted?: boolean
    guaranteePolicy?: boolean
    latitude?: boolean
    longitude?: boolean
    rating?: boolean
    totalServices?: boolean
    evidenceRate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workshop"]>

  export type WorkshopSelectScalar = {
    id?: boolean
    userId?: boolean
    name?: boolean
    address?: boolean
    district?: boolean
    phone?: boolean
    ruc?: boolean
    description?: boolean
    photoUrl?: boolean
    status?: boolean
    transparencyAccepted?: boolean
    guaranteePolicy?: boolean
    latitude?: boolean
    longitude?: boolean
    rating?: boolean
    totalServices?: boolean
    evidenceRate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type WorkshopOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "name" | "address" | "district" | "phone" | "ruc" | "description" | "photoUrl" | "status" | "transparencyAccepted" | "guaranteePolicy" | "latitude" | "longitude" | "rating" | "totalServices" | "evidenceRate" | "createdAt" | "updatedAt", ExtArgs["result"]["workshop"]>
  export type WorkshopInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserProfileDefaultArgs<ExtArgs>
    categories?: boolean | Workshop$categoriesArgs<ExtArgs>
    quotes?: boolean | Workshop$quotesArgs<ExtArgs>
    workOrders?: boolean | Workshop$workOrdersArgs<ExtArgs>
    reviews?: boolean | Workshop$reviewsArgs<ExtArgs>
    incidentReports?: boolean | Workshop$incidentReportsArgs<ExtArgs>
    verifications?: boolean | Workshop$verificationsArgs<ExtArgs>
    _count?: boolean | WorkshopCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type WorkshopIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserProfileDefaultArgs<ExtArgs>
  }
  export type WorkshopIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserProfileDefaultArgs<ExtArgs>
  }

  export type $WorkshopPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Workshop"
    objects: {
      user: Prisma.$UserProfilePayload<ExtArgs>
      categories: Prisma.$WorkshopCategoryPayload<ExtArgs>[]
      quotes: Prisma.$QuotePayload<ExtArgs>[]
      workOrders: Prisma.$WorkOrderPayload<ExtArgs>[]
      reviews: Prisma.$ReviewPayload<ExtArgs>[]
      incidentReports: Prisma.$IncidentReportPayload<ExtArgs>[]
      verifications: Prisma.$WorkshopVerificationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      name: string
      address: string
      district: string
      phone: string
      ruc: string | null
      description: string | null
      photoUrl: string | null
      status: $Enums.WorkshopStatus
      transparencyAccepted: boolean
      guaranteePolicy: string | null
      latitude: number | null
      longitude: number | null
      rating: number
      totalServices: number
      evidenceRate: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["workshop"]>
    composites: {}
  }

  type WorkshopGetPayload<S extends boolean | null | undefined | WorkshopDefaultArgs> = $Result.GetResult<Prisma.$WorkshopPayload, S>

  type WorkshopCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WorkshopFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WorkshopCountAggregateInputType | true
    }

  export interface WorkshopDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Workshop'], meta: { name: 'Workshop' } }
    /**
     * Find zero or one Workshop that matches the filter.
     * @param {WorkshopFindUniqueArgs} args - Arguments to find a Workshop
     * @example
     * // Get one Workshop
     * const workshop = await prisma.workshop.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WorkshopFindUniqueArgs>(args: SelectSubset<T, WorkshopFindUniqueArgs<ExtArgs>>): Prisma__WorkshopClient<$Result.GetResult<Prisma.$WorkshopPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Workshop that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WorkshopFindUniqueOrThrowArgs} args - Arguments to find a Workshop
     * @example
     * // Get one Workshop
     * const workshop = await prisma.workshop.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WorkshopFindUniqueOrThrowArgs>(args: SelectSubset<T, WorkshopFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WorkshopClient<$Result.GetResult<Prisma.$WorkshopPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Workshop that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkshopFindFirstArgs} args - Arguments to find a Workshop
     * @example
     * // Get one Workshop
     * const workshop = await prisma.workshop.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WorkshopFindFirstArgs>(args?: SelectSubset<T, WorkshopFindFirstArgs<ExtArgs>>): Prisma__WorkshopClient<$Result.GetResult<Prisma.$WorkshopPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Workshop that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkshopFindFirstOrThrowArgs} args - Arguments to find a Workshop
     * @example
     * // Get one Workshop
     * const workshop = await prisma.workshop.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WorkshopFindFirstOrThrowArgs>(args?: SelectSubset<T, WorkshopFindFirstOrThrowArgs<ExtArgs>>): Prisma__WorkshopClient<$Result.GetResult<Prisma.$WorkshopPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Workshops that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkshopFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Workshops
     * const workshops = await prisma.workshop.findMany()
     * 
     * // Get first 10 Workshops
     * const workshops = await prisma.workshop.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const workshopWithIdOnly = await prisma.workshop.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WorkshopFindManyArgs>(args?: SelectSubset<T, WorkshopFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkshopPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Workshop.
     * @param {WorkshopCreateArgs} args - Arguments to create a Workshop.
     * @example
     * // Create one Workshop
     * const Workshop = await prisma.workshop.create({
     *   data: {
     *     // ... data to create a Workshop
     *   }
     * })
     * 
     */
    create<T extends WorkshopCreateArgs>(args: SelectSubset<T, WorkshopCreateArgs<ExtArgs>>): Prisma__WorkshopClient<$Result.GetResult<Prisma.$WorkshopPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Workshops.
     * @param {WorkshopCreateManyArgs} args - Arguments to create many Workshops.
     * @example
     * // Create many Workshops
     * const workshop = await prisma.workshop.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WorkshopCreateManyArgs>(args?: SelectSubset<T, WorkshopCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Workshops and returns the data saved in the database.
     * @param {WorkshopCreateManyAndReturnArgs} args - Arguments to create many Workshops.
     * @example
     * // Create many Workshops
     * const workshop = await prisma.workshop.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Workshops and only return the `id`
     * const workshopWithIdOnly = await prisma.workshop.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WorkshopCreateManyAndReturnArgs>(args?: SelectSubset<T, WorkshopCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkshopPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Workshop.
     * @param {WorkshopDeleteArgs} args - Arguments to delete one Workshop.
     * @example
     * // Delete one Workshop
     * const Workshop = await prisma.workshop.delete({
     *   where: {
     *     // ... filter to delete one Workshop
     *   }
     * })
     * 
     */
    delete<T extends WorkshopDeleteArgs>(args: SelectSubset<T, WorkshopDeleteArgs<ExtArgs>>): Prisma__WorkshopClient<$Result.GetResult<Prisma.$WorkshopPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Workshop.
     * @param {WorkshopUpdateArgs} args - Arguments to update one Workshop.
     * @example
     * // Update one Workshop
     * const workshop = await prisma.workshop.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WorkshopUpdateArgs>(args: SelectSubset<T, WorkshopUpdateArgs<ExtArgs>>): Prisma__WorkshopClient<$Result.GetResult<Prisma.$WorkshopPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Workshops.
     * @param {WorkshopDeleteManyArgs} args - Arguments to filter Workshops to delete.
     * @example
     * // Delete a few Workshops
     * const { count } = await prisma.workshop.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WorkshopDeleteManyArgs>(args?: SelectSubset<T, WorkshopDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Workshops.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkshopUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Workshops
     * const workshop = await prisma.workshop.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WorkshopUpdateManyArgs>(args: SelectSubset<T, WorkshopUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Workshops and returns the data updated in the database.
     * @param {WorkshopUpdateManyAndReturnArgs} args - Arguments to update many Workshops.
     * @example
     * // Update many Workshops
     * const workshop = await prisma.workshop.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Workshops and only return the `id`
     * const workshopWithIdOnly = await prisma.workshop.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends WorkshopUpdateManyAndReturnArgs>(args: SelectSubset<T, WorkshopUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkshopPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Workshop.
     * @param {WorkshopUpsertArgs} args - Arguments to update or create a Workshop.
     * @example
     * // Update or create a Workshop
     * const workshop = await prisma.workshop.upsert({
     *   create: {
     *     // ... data to create a Workshop
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Workshop we want to update
     *   }
     * })
     */
    upsert<T extends WorkshopUpsertArgs>(args: SelectSubset<T, WorkshopUpsertArgs<ExtArgs>>): Prisma__WorkshopClient<$Result.GetResult<Prisma.$WorkshopPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Workshops.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkshopCountArgs} args - Arguments to filter Workshops to count.
     * @example
     * // Count the number of Workshops
     * const count = await prisma.workshop.count({
     *   where: {
     *     // ... the filter for the Workshops we want to count
     *   }
     * })
    **/
    count<T extends WorkshopCountArgs>(
      args?: Subset<T, WorkshopCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WorkshopCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Workshop.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkshopAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WorkshopAggregateArgs>(args: Subset<T, WorkshopAggregateArgs>): Prisma.PrismaPromise<GetWorkshopAggregateType<T>>

    /**
     * Group by Workshop.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkshopGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WorkshopGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WorkshopGroupByArgs['orderBy'] }
        : { orderBy?: WorkshopGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WorkshopGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWorkshopGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Workshop model
   */
  readonly fields: WorkshopFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Workshop.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WorkshopClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserProfileDefaultArgs<ExtArgs>>): Prisma__UserProfileClient<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    categories<T extends Workshop$categoriesArgs<ExtArgs> = {}>(args?: Subset<T, Workshop$categoriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkshopCategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    quotes<T extends Workshop$quotesArgs<ExtArgs> = {}>(args?: Subset<T, Workshop$quotesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuotePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    workOrders<T extends Workshop$workOrdersArgs<ExtArgs> = {}>(args?: Subset<T, Workshop$workOrdersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkOrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    reviews<T extends Workshop$reviewsArgs<ExtArgs> = {}>(args?: Subset<T, Workshop$reviewsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    incidentReports<T extends Workshop$incidentReportsArgs<ExtArgs> = {}>(args?: Subset<T, Workshop$incidentReportsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IncidentReportPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    verifications<T extends Workshop$verificationsArgs<ExtArgs> = {}>(args?: Subset<T, Workshop$verificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkshopVerificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Workshop model
   */
  interface WorkshopFieldRefs {
    readonly id: FieldRef<"Workshop", 'String'>
    readonly userId: FieldRef<"Workshop", 'String'>
    readonly name: FieldRef<"Workshop", 'String'>
    readonly address: FieldRef<"Workshop", 'String'>
    readonly district: FieldRef<"Workshop", 'String'>
    readonly phone: FieldRef<"Workshop", 'String'>
    readonly ruc: FieldRef<"Workshop", 'String'>
    readonly description: FieldRef<"Workshop", 'String'>
    readonly photoUrl: FieldRef<"Workshop", 'String'>
    readonly status: FieldRef<"Workshop", 'WorkshopStatus'>
    readonly transparencyAccepted: FieldRef<"Workshop", 'Boolean'>
    readonly guaranteePolicy: FieldRef<"Workshop", 'String'>
    readonly latitude: FieldRef<"Workshop", 'Float'>
    readonly longitude: FieldRef<"Workshop", 'Float'>
    readonly rating: FieldRef<"Workshop", 'Float'>
    readonly totalServices: FieldRef<"Workshop", 'Int'>
    readonly evidenceRate: FieldRef<"Workshop", 'Float'>
    readonly createdAt: FieldRef<"Workshop", 'DateTime'>
    readonly updatedAt: FieldRef<"Workshop", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Workshop findUnique
   */
  export type WorkshopFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workshop
     */
    select?: WorkshopSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Workshop
     */
    omit?: WorkshopOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkshopInclude<ExtArgs> | null
    /**
     * Filter, which Workshop to fetch.
     */
    where: WorkshopWhereUniqueInput
  }

  /**
   * Workshop findUniqueOrThrow
   */
  export type WorkshopFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workshop
     */
    select?: WorkshopSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Workshop
     */
    omit?: WorkshopOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkshopInclude<ExtArgs> | null
    /**
     * Filter, which Workshop to fetch.
     */
    where: WorkshopWhereUniqueInput
  }

  /**
   * Workshop findFirst
   */
  export type WorkshopFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workshop
     */
    select?: WorkshopSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Workshop
     */
    omit?: WorkshopOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkshopInclude<ExtArgs> | null
    /**
     * Filter, which Workshop to fetch.
     */
    where?: WorkshopWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Workshops to fetch.
     */
    orderBy?: WorkshopOrderByWithRelationInput | WorkshopOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Workshops.
     */
    cursor?: WorkshopWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Workshops from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Workshops.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Workshops.
     */
    distinct?: WorkshopScalarFieldEnum | WorkshopScalarFieldEnum[]
  }

  /**
   * Workshop findFirstOrThrow
   */
  export type WorkshopFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workshop
     */
    select?: WorkshopSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Workshop
     */
    omit?: WorkshopOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkshopInclude<ExtArgs> | null
    /**
     * Filter, which Workshop to fetch.
     */
    where?: WorkshopWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Workshops to fetch.
     */
    orderBy?: WorkshopOrderByWithRelationInput | WorkshopOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Workshops.
     */
    cursor?: WorkshopWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Workshops from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Workshops.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Workshops.
     */
    distinct?: WorkshopScalarFieldEnum | WorkshopScalarFieldEnum[]
  }

  /**
   * Workshop findMany
   */
  export type WorkshopFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workshop
     */
    select?: WorkshopSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Workshop
     */
    omit?: WorkshopOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkshopInclude<ExtArgs> | null
    /**
     * Filter, which Workshops to fetch.
     */
    where?: WorkshopWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Workshops to fetch.
     */
    orderBy?: WorkshopOrderByWithRelationInput | WorkshopOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Workshops.
     */
    cursor?: WorkshopWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Workshops from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Workshops.
     */
    skip?: number
    distinct?: WorkshopScalarFieldEnum | WorkshopScalarFieldEnum[]
  }

  /**
   * Workshop create
   */
  export type WorkshopCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workshop
     */
    select?: WorkshopSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Workshop
     */
    omit?: WorkshopOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkshopInclude<ExtArgs> | null
    /**
     * The data needed to create a Workshop.
     */
    data: XOR<WorkshopCreateInput, WorkshopUncheckedCreateInput>
  }

  /**
   * Workshop createMany
   */
  export type WorkshopCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Workshops.
     */
    data: WorkshopCreateManyInput | WorkshopCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Workshop createManyAndReturn
   */
  export type WorkshopCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workshop
     */
    select?: WorkshopSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Workshop
     */
    omit?: WorkshopOmit<ExtArgs> | null
    /**
     * The data used to create many Workshops.
     */
    data: WorkshopCreateManyInput | WorkshopCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkshopIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Workshop update
   */
  export type WorkshopUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workshop
     */
    select?: WorkshopSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Workshop
     */
    omit?: WorkshopOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkshopInclude<ExtArgs> | null
    /**
     * The data needed to update a Workshop.
     */
    data: XOR<WorkshopUpdateInput, WorkshopUncheckedUpdateInput>
    /**
     * Choose, which Workshop to update.
     */
    where: WorkshopWhereUniqueInput
  }

  /**
   * Workshop updateMany
   */
  export type WorkshopUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Workshops.
     */
    data: XOR<WorkshopUpdateManyMutationInput, WorkshopUncheckedUpdateManyInput>
    /**
     * Filter which Workshops to update
     */
    where?: WorkshopWhereInput
    /**
     * Limit how many Workshops to update.
     */
    limit?: number
  }

  /**
   * Workshop updateManyAndReturn
   */
  export type WorkshopUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workshop
     */
    select?: WorkshopSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Workshop
     */
    omit?: WorkshopOmit<ExtArgs> | null
    /**
     * The data used to update Workshops.
     */
    data: XOR<WorkshopUpdateManyMutationInput, WorkshopUncheckedUpdateManyInput>
    /**
     * Filter which Workshops to update
     */
    where?: WorkshopWhereInput
    /**
     * Limit how many Workshops to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkshopIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Workshop upsert
   */
  export type WorkshopUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workshop
     */
    select?: WorkshopSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Workshop
     */
    omit?: WorkshopOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkshopInclude<ExtArgs> | null
    /**
     * The filter to search for the Workshop to update in case it exists.
     */
    where: WorkshopWhereUniqueInput
    /**
     * In case the Workshop found by the `where` argument doesn't exist, create a new Workshop with this data.
     */
    create: XOR<WorkshopCreateInput, WorkshopUncheckedCreateInput>
    /**
     * In case the Workshop was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WorkshopUpdateInput, WorkshopUncheckedUpdateInput>
  }

  /**
   * Workshop delete
   */
  export type WorkshopDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workshop
     */
    select?: WorkshopSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Workshop
     */
    omit?: WorkshopOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkshopInclude<ExtArgs> | null
    /**
     * Filter which Workshop to delete.
     */
    where: WorkshopWhereUniqueInput
  }

  /**
   * Workshop deleteMany
   */
  export type WorkshopDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Workshops to delete
     */
    where?: WorkshopWhereInput
    /**
     * Limit how many Workshops to delete.
     */
    limit?: number
  }

  /**
   * Workshop.categories
   */
  export type Workshop$categoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkshopCategory
     */
    select?: WorkshopCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkshopCategory
     */
    omit?: WorkshopCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkshopCategoryInclude<ExtArgs> | null
    where?: WorkshopCategoryWhereInput
    orderBy?: WorkshopCategoryOrderByWithRelationInput | WorkshopCategoryOrderByWithRelationInput[]
    cursor?: WorkshopCategoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WorkshopCategoryScalarFieldEnum | WorkshopCategoryScalarFieldEnum[]
  }

  /**
   * Workshop.quotes
   */
  export type Workshop$quotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quote
     */
    select?: QuoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quote
     */
    omit?: QuoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteInclude<ExtArgs> | null
    where?: QuoteWhereInput
    orderBy?: QuoteOrderByWithRelationInput | QuoteOrderByWithRelationInput[]
    cursor?: QuoteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuoteScalarFieldEnum | QuoteScalarFieldEnum[]
  }

  /**
   * Workshop.workOrders
   */
  export type Workshop$workOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkOrder
     */
    select?: WorkOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkOrder
     */
    omit?: WorkOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkOrderInclude<ExtArgs> | null
    where?: WorkOrderWhereInput
    orderBy?: WorkOrderOrderByWithRelationInput | WorkOrderOrderByWithRelationInput[]
    cursor?: WorkOrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WorkOrderScalarFieldEnum | WorkOrderScalarFieldEnum[]
  }

  /**
   * Workshop.reviews
   */
  export type Workshop$reviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    where?: ReviewWhereInput
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    cursor?: ReviewWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }

  /**
   * Workshop.incidentReports
   */
  export type Workshop$incidentReportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IncidentReport
     */
    select?: IncidentReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IncidentReport
     */
    omit?: IncidentReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidentReportInclude<ExtArgs> | null
    where?: IncidentReportWhereInput
    orderBy?: IncidentReportOrderByWithRelationInput | IncidentReportOrderByWithRelationInput[]
    cursor?: IncidentReportWhereUniqueInput
    take?: number
    skip?: number
    distinct?: IncidentReportScalarFieldEnum | IncidentReportScalarFieldEnum[]
  }

  /**
   * Workshop.verifications
   */
  export type Workshop$verificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkshopVerification
     */
    select?: WorkshopVerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkshopVerification
     */
    omit?: WorkshopVerificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkshopVerificationInclude<ExtArgs> | null
    where?: WorkshopVerificationWhereInput
    orderBy?: WorkshopVerificationOrderByWithRelationInput | WorkshopVerificationOrderByWithRelationInput[]
    cursor?: WorkshopVerificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WorkshopVerificationScalarFieldEnum | WorkshopVerificationScalarFieldEnum[]
  }

  /**
   * Workshop without action
   */
  export type WorkshopDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workshop
     */
    select?: WorkshopSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Workshop
     */
    omit?: WorkshopOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkshopInclude<ExtArgs> | null
  }


  /**
   * Model WorkshopCategory
   */

  export type AggregateWorkshopCategory = {
    _count: WorkshopCategoryCountAggregateOutputType | null
    _min: WorkshopCategoryMinAggregateOutputType | null
    _max: WorkshopCategoryMaxAggregateOutputType | null
  }

  export type WorkshopCategoryMinAggregateOutputType = {
    id: string | null
    workshopId: string | null
    categoryId: string | null
  }

  export type WorkshopCategoryMaxAggregateOutputType = {
    id: string | null
    workshopId: string | null
    categoryId: string | null
  }

  export type WorkshopCategoryCountAggregateOutputType = {
    id: number
    workshopId: number
    categoryId: number
    _all: number
  }


  export type WorkshopCategoryMinAggregateInputType = {
    id?: true
    workshopId?: true
    categoryId?: true
  }

  export type WorkshopCategoryMaxAggregateInputType = {
    id?: true
    workshopId?: true
    categoryId?: true
  }

  export type WorkshopCategoryCountAggregateInputType = {
    id?: true
    workshopId?: true
    categoryId?: true
    _all?: true
  }

  export type WorkshopCategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WorkshopCategory to aggregate.
     */
    where?: WorkshopCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkshopCategories to fetch.
     */
    orderBy?: WorkshopCategoryOrderByWithRelationInput | WorkshopCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WorkshopCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkshopCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkshopCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WorkshopCategories
    **/
    _count?: true | WorkshopCategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WorkshopCategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WorkshopCategoryMaxAggregateInputType
  }

  export type GetWorkshopCategoryAggregateType<T extends WorkshopCategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateWorkshopCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWorkshopCategory[P]>
      : GetScalarType<T[P], AggregateWorkshopCategory[P]>
  }




  export type WorkshopCategoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkshopCategoryWhereInput
    orderBy?: WorkshopCategoryOrderByWithAggregationInput | WorkshopCategoryOrderByWithAggregationInput[]
    by: WorkshopCategoryScalarFieldEnum[] | WorkshopCategoryScalarFieldEnum
    having?: WorkshopCategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WorkshopCategoryCountAggregateInputType | true
    _min?: WorkshopCategoryMinAggregateInputType
    _max?: WorkshopCategoryMaxAggregateInputType
  }

  export type WorkshopCategoryGroupByOutputType = {
    id: string
    workshopId: string
    categoryId: string
    _count: WorkshopCategoryCountAggregateOutputType | null
    _min: WorkshopCategoryMinAggregateOutputType | null
    _max: WorkshopCategoryMaxAggregateOutputType | null
  }

  type GetWorkshopCategoryGroupByPayload<T extends WorkshopCategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WorkshopCategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WorkshopCategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WorkshopCategoryGroupByOutputType[P]>
            : GetScalarType<T[P], WorkshopCategoryGroupByOutputType[P]>
        }
      >
    >


  export type WorkshopCategorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workshopId?: boolean
    categoryId?: boolean
    workshop?: boolean | WorkshopDefaultArgs<ExtArgs>
    category?: boolean | CategoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workshopCategory"]>

  export type WorkshopCategorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workshopId?: boolean
    categoryId?: boolean
    workshop?: boolean | WorkshopDefaultArgs<ExtArgs>
    category?: boolean | CategoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workshopCategory"]>

  export type WorkshopCategorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workshopId?: boolean
    categoryId?: boolean
    workshop?: boolean | WorkshopDefaultArgs<ExtArgs>
    category?: boolean | CategoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workshopCategory"]>

  export type WorkshopCategorySelectScalar = {
    id?: boolean
    workshopId?: boolean
    categoryId?: boolean
  }

  export type WorkshopCategoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "workshopId" | "categoryId", ExtArgs["result"]["workshopCategory"]>
  export type WorkshopCategoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workshop?: boolean | WorkshopDefaultArgs<ExtArgs>
    category?: boolean | CategoryDefaultArgs<ExtArgs>
  }
  export type WorkshopCategoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workshop?: boolean | WorkshopDefaultArgs<ExtArgs>
    category?: boolean | CategoryDefaultArgs<ExtArgs>
  }
  export type WorkshopCategoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workshop?: boolean | WorkshopDefaultArgs<ExtArgs>
    category?: boolean | CategoryDefaultArgs<ExtArgs>
  }

  export type $WorkshopCategoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WorkshopCategory"
    objects: {
      workshop: Prisma.$WorkshopPayload<ExtArgs>
      category: Prisma.$CategoryPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      workshopId: string
      categoryId: string
    }, ExtArgs["result"]["workshopCategory"]>
    composites: {}
  }

  type WorkshopCategoryGetPayload<S extends boolean | null | undefined | WorkshopCategoryDefaultArgs> = $Result.GetResult<Prisma.$WorkshopCategoryPayload, S>

  type WorkshopCategoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WorkshopCategoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WorkshopCategoryCountAggregateInputType | true
    }

  export interface WorkshopCategoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WorkshopCategory'], meta: { name: 'WorkshopCategory' } }
    /**
     * Find zero or one WorkshopCategory that matches the filter.
     * @param {WorkshopCategoryFindUniqueArgs} args - Arguments to find a WorkshopCategory
     * @example
     * // Get one WorkshopCategory
     * const workshopCategory = await prisma.workshopCategory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WorkshopCategoryFindUniqueArgs>(args: SelectSubset<T, WorkshopCategoryFindUniqueArgs<ExtArgs>>): Prisma__WorkshopCategoryClient<$Result.GetResult<Prisma.$WorkshopCategoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one WorkshopCategory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WorkshopCategoryFindUniqueOrThrowArgs} args - Arguments to find a WorkshopCategory
     * @example
     * // Get one WorkshopCategory
     * const workshopCategory = await prisma.workshopCategory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WorkshopCategoryFindUniqueOrThrowArgs>(args: SelectSubset<T, WorkshopCategoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WorkshopCategoryClient<$Result.GetResult<Prisma.$WorkshopCategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WorkshopCategory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkshopCategoryFindFirstArgs} args - Arguments to find a WorkshopCategory
     * @example
     * // Get one WorkshopCategory
     * const workshopCategory = await prisma.workshopCategory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WorkshopCategoryFindFirstArgs>(args?: SelectSubset<T, WorkshopCategoryFindFirstArgs<ExtArgs>>): Prisma__WorkshopCategoryClient<$Result.GetResult<Prisma.$WorkshopCategoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WorkshopCategory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkshopCategoryFindFirstOrThrowArgs} args - Arguments to find a WorkshopCategory
     * @example
     * // Get one WorkshopCategory
     * const workshopCategory = await prisma.workshopCategory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WorkshopCategoryFindFirstOrThrowArgs>(args?: SelectSubset<T, WorkshopCategoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__WorkshopCategoryClient<$Result.GetResult<Prisma.$WorkshopCategoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more WorkshopCategories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkshopCategoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WorkshopCategories
     * const workshopCategories = await prisma.workshopCategory.findMany()
     * 
     * // Get first 10 WorkshopCategories
     * const workshopCategories = await prisma.workshopCategory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const workshopCategoryWithIdOnly = await prisma.workshopCategory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WorkshopCategoryFindManyArgs>(args?: SelectSubset<T, WorkshopCategoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkshopCategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a WorkshopCategory.
     * @param {WorkshopCategoryCreateArgs} args - Arguments to create a WorkshopCategory.
     * @example
     * // Create one WorkshopCategory
     * const WorkshopCategory = await prisma.workshopCategory.create({
     *   data: {
     *     // ... data to create a WorkshopCategory
     *   }
     * })
     * 
     */
    create<T extends WorkshopCategoryCreateArgs>(args: SelectSubset<T, WorkshopCategoryCreateArgs<ExtArgs>>): Prisma__WorkshopCategoryClient<$Result.GetResult<Prisma.$WorkshopCategoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many WorkshopCategories.
     * @param {WorkshopCategoryCreateManyArgs} args - Arguments to create many WorkshopCategories.
     * @example
     * // Create many WorkshopCategories
     * const workshopCategory = await prisma.workshopCategory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WorkshopCategoryCreateManyArgs>(args?: SelectSubset<T, WorkshopCategoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WorkshopCategories and returns the data saved in the database.
     * @param {WorkshopCategoryCreateManyAndReturnArgs} args - Arguments to create many WorkshopCategories.
     * @example
     * // Create many WorkshopCategories
     * const workshopCategory = await prisma.workshopCategory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WorkshopCategories and only return the `id`
     * const workshopCategoryWithIdOnly = await prisma.workshopCategory.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WorkshopCategoryCreateManyAndReturnArgs>(args?: SelectSubset<T, WorkshopCategoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkshopCategoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a WorkshopCategory.
     * @param {WorkshopCategoryDeleteArgs} args - Arguments to delete one WorkshopCategory.
     * @example
     * // Delete one WorkshopCategory
     * const WorkshopCategory = await prisma.workshopCategory.delete({
     *   where: {
     *     // ... filter to delete one WorkshopCategory
     *   }
     * })
     * 
     */
    delete<T extends WorkshopCategoryDeleteArgs>(args: SelectSubset<T, WorkshopCategoryDeleteArgs<ExtArgs>>): Prisma__WorkshopCategoryClient<$Result.GetResult<Prisma.$WorkshopCategoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one WorkshopCategory.
     * @param {WorkshopCategoryUpdateArgs} args - Arguments to update one WorkshopCategory.
     * @example
     * // Update one WorkshopCategory
     * const workshopCategory = await prisma.workshopCategory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WorkshopCategoryUpdateArgs>(args: SelectSubset<T, WorkshopCategoryUpdateArgs<ExtArgs>>): Prisma__WorkshopCategoryClient<$Result.GetResult<Prisma.$WorkshopCategoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more WorkshopCategories.
     * @param {WorkshopCategoryDeleteManyArgs} args - Arguments to filter WorkshopCategories to delete.
     * @example
     * // Delete a few WorkshopCategories
     * const { count } = await prisma.workshopCategory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WorkshopCategoryDeleteManyArgs>(args?: SelectSubset<T, WorkshopCategoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WorkshopCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkshopCategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WorkshopCategories
     * const workshopCategory = await prisma.workshopCategory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WorkshopCategoryUpdateManyArgs>(args: SelectSubset<T, WorkshopCategoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WorkshopCategories and returns the data updated in the database.
     * @param {WorkshopCategoryUpdateManyAndReturnArgs} args - Arguments to update many WorkshopCategories.
     * @example
     * // Update many WorkshopCategories
     * const workshopCategory = await prisma.workshopCategory.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more WorkshopCategories and only return the `id`
     * const workshopCategoryWithIdOnly = await prisma.workshopCategory.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends WorkshopCategoryUpdateManyAndReturnArgs>(args: SelectSubset<T, WorkshopCategoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkshopCategoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one WorkshopCategory.
     * @param {WorkshopCategoryUpsertArgs} args - Arguments to update or create a WorkshopCategory.
     * @example
     * // Update or create a WorkshopCategory
     * const workshopCategory = await prisma.workshopCategory.upsert({
     *   create: {
     *     // ... data to create a WorkshopCategory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WorkshopCategory we want to update
     *   }
     * })
     */
    upsert<T extends WorkshopCategoryUpsertArgs>(args: SelectSubset<T, WorkshopCategoryUpsertArgs<ExtArgs>>): Prisma__WorkshopCategoryClient<$Result.GetResult<Prisma.$WorkshopCategoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of WorkshopCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkshopCategoryCountArgs} args - Arguments to filter WorkshopCategories to count.
     * @example
     * // Count the number of WorkshopCategories
     * const count = await prisma.workshopCategory.count({
     *   where: {
     *     // ... the filter for the WorkshopCategories we want to count
     *   }
     * })
    **/
    count<T extends WorkshopCategoryCountArgs>(
      args?: Subset<T, WorkshopCategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WorkshopCategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WorkshopCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkshopCategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WorkshopCategoryAggregateArgs>(args: Subset<T, WorkshopCategoryAggregateArgs>): Prisma.PrismaPromise<GetWorkshopCategoryAggregateType<T>>

    /**
     * Group by WorkshopCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkshopCategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WorkshopCategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WorkshopCategoryGroupByArgs['orderBy'] }
        : { orderBy?: WorkshopCategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WorkshopCategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWorkshopCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WorkshopCategory model
   */
  readonly fields: WorkshopCategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WorkshopCategory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WorkshopCategoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    workshop<T extends WorkshopDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WorkshopDefaultArgs<ExtArgs>>): Prisma__WorkshopClient<$Result.GetResult<Prisma.$WorkshopPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    category<T extends CategoryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CategoryDefaultArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WorkshopCategory model
   */
  interface WorkshopCategoryFieldRefs {
    readonly id: FieldRef<"WorkshopCategory", 'String'>
    readonly workshopId: FieldRef<"WorkshopCategory", 'String'>
    readonly categoryId: FieldRef<"WorkshopCategory", 'String'>
  }
    

  // Custom InputTypes
  /**
   * WorkshopCategory findUnique
   */
  export type WorkshopCategoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkshopCategory
     */
    select?: WorkshopCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkshopCategory
     */
    omit?: WorkshopCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkshopCategoryInclude<ExtArgs> | null
    /**
     * Filter, which WorkshopCategory to fetch.
     */
    where: WorkshopCategoryWhereUniqueInput
  }

  /**
   * WorkshopCategory findUniqueOrThrow
   */
  export type WorkshopCategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkshopCategory
     */
    select?: WorkshopCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkshopCategory
     */
    omit?: WorkshopCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkshopCategoryInclude<ExtArgs> | null
    /**
     * Filter, which WorkshopCategory to fetch.
     */
    where: WorkshopCategoryWhereUniqueInput
  }

  /**
   * WorkshopCategory findFirst
   */
  export type WorkshopCategoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkshopCategory
     */
    select?: WorkshopCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkshopCategory
     */
    omit?: WorkshopCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkshopCategoryInclude<ExtArgs> | null
    /**
     * Filter, which WorkshopCategory to fetch.
     */
    where?: WorkshopCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkshopCategories to fetch.
     */
    orderBy?: WorkshopCategoryOrderByWithRelationInput | WorkshopCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorkshopCategories.
     */
    cursor?: WorkshopCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkshopCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkshopCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorkshopCategories.
     */
    distinct?: WorkshopCategoryScalarFieldEnum | WorkshopCategoryScalarFieldEnum[]
  }

  /**
   * WorkshopCategory findFirstOrThrow
   */
  export type WorkshopCategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkshopCategory
     */
    select?: WorkshopCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkshopCategory
     */
    omit?: WorkshopCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkshopCategoryInclude<ExtArgs> | null
    /**
     * Filter, which WorkshopCategory to fetch.
     */
    where?: WorkshopCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkshopCategories to fetch.
     */
    orderBy?: WorkshopCategoryOrderByWithRelationInput | WorkshopCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorkshopCategories.
     */
    cursor?: WorkshopCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkshopCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkshopCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorkshopCategories.
     */
    distinct?: WorkshopCategoryScalarFieldEnum | WorkshopCategoryScalarFieldEnum[]
  }

  /**
   * WorkshopCategory findMany
   */
  export type WorkshopCategoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkshopCategory
     */
    select?: WorkshopCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkshopCategory
     */
    omit?: WorkshopCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkshopCategoryInclude<ExtArgs> | null
    /**
     * Filter, which WorkshopCategories to fetch.
     */
    where?: WorkshopCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkshopCategories to fetch.
     */
    orderBy?: WorkshopCategoryOrderByWithRelationInput | WorkshopCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WorkshopCategories.
     */
    cursor?: WorkshopCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkshopCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkshopCategories.
     */
    skip?: number
    distinct?: WorkshopCategoryScalarFieldEnum | WorkshopCategoryScalarFieldEnum[]
  }

  /**
   * WorkshopCategory create
   */
  export type WorkshopCategoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkshopCategory
     */
    select?: WorkshopCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkshopCategory
     */
    omit?: WorkshopCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkshopCategoryInclude<ExtArgs> | null
    /**
     * The data needed to create a WorkshopCategory.
     */
    data: XOR<WorkshopCategoryCreateInput, WorkshopCategoryUncheckedCreateInput>
  }

  /**
   * WorkshopCategory createMany
   */
  export type WorkshopCategoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WorkshopCategories.
     */
    data: WorkshopCategoryCreateManyInput | WorkshopCategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WorkshopCategory createManyAndReturn
   */
  export type WorkshopCategoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkshopCategory
     */
    select?: WorkshopCategorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WorkshopCategory
     */
    omit?: WorkshopCategoryOmit<ExtArgs> | null
    /**
     * The data used to create many WorkshopCategories.
     */
    data: WorkshopCategoryCreateManyInput | WorkshopCategoryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkshopCategoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * WorkshopCategory update
   */
  export type WorkshopCategoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkshopCategory
     */
    select?: WorkshopCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkshopCategory
     */
    omit?: WorkshopCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkshopCategoryInclude<ExtArgs> | null
    /**
     * The data needed to update a WorkshopCategory.
     */
    data: XOR<WorkshopCategoryUpdateInput, WorkshopCategoryUncheckedUpdateInput>
    /**
     * Choose, which WorkshopCategory to update.
     */
    where: WorkshopCategoryWhereUniqueInput
  }

  /**
   * WorkshopCategory updateMany
   */
  export type WorkshopCategoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WorkshopCategories.
     */
    data: XOR<WorkshopCategoryUpdateManyMutationInput, WorkshopCategoryUncheckedUpdateManyInput>
    /**
     * Filter which WorkshopCategories to update
     */
    where?: WorkshopCategoryWhereInput
    /**
     * Limit how many WorkshopCategories to update.
     */
    limit?: number
  }

  /**
   * WorkshopCategory updateManyAndReturn
   */
  export type WorkshopCategoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkshopCategory
     */
    select?: WorkshopCategorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WorkshopCategory
     */
    omit?: WorkshopCategoryOmit<ExtArgs> | null
    /**
     * The data used to update WorkshopCategories.
     */
    data: XOR<WorkshopCategoryUpdateManyMutationInput, WorkshopCategoryUncheckedUpdateManyInput>
    /**
     * Filter which WorkshopCategories to update
     */
    where?: WorkshopCategoryWhereInput
    /**
     * Limit how many WorkshopCategories to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkshopCategoryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * WorkshopCategory upsert
   */
  export type WorkshopCategoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkshopCategory
     */
    select?: WorkshopCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkshopCategory
     */
    omit?: WorkshopCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkshopCategoryInclude<ExtArgs> | null
    /**
     * The filter to search for the WorkshopCategory to update in case it exists.
     */
    where: WorkshopCategoryWhereUniqueInput
    /**
     * In case the WorkshopCategory found by the `where` argument doesn't exist, create a new WorkshopCategory with this data.
     */
    create: XOR<WorkshopCategoryCreateInput, WorkshopCategoryUncheckedCreateInput>
    /**
     * In case the WorkshopCategory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WorkshopCategoryUpdateInput, WorkshopCategoryUncheckedUpdateInput>
  }

  /**
   * WorkshopCategory delete
   */
  export type WorkshopCategoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkshopCategory
     */
    select?: WorkshopCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkshopCategory
     */
    omit?: WorkshopCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkshopCategoryInclude<ExtArgs> | null
    /**
     * Filter which WorkshopCategory to delete.
     */
    where: WorkshopCategoryWhereUniqueInput
  }

  /**
   * WorkshopCategory deleteMany
   */
  export type WorkshopCategoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WorkshopCategories to delete
     */
    where?: WorkshopCategoryWhereInput
    /**
     * Limit how many WorkshopCategories to delete.
     */
    limit?: number
  }

  /**
   * WorkshopCategory without action
   */
  export type WorkshopCategoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkshopCategory
     */
    select?: WorkshopCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkshopCategory
     */
    omit?: WorkshopCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkshopCategoryInclude<ExtArgs> | null
  }


  /**
   * Model WorkshopVerification
   */

  export type AggregateWorkshopVerification = {
    _count: WorkshopVerificationCountAggregateOutputType | null
    _min: WorkshopVerificationMinAggregateOutputType | null
    _max: WorkshopVerificationMaxAggregateOutputType | null
  }

  export type WorkshopVerificationMinAggregateOutputType = {
    id: string | null
    workshopId: string | null
    adminId: string | null
    decision: $Enums.WorkshopStatus | null
    reason: string | null
    createdAt: Date | null
  }

  export type WorkshopVerificationMaxAggregateOutputType = {
    id: string | null
    workshopId: string | null
    adminId: string | null
    decision: $Enums.WorkshopStatus | null
    reason: string | null
    createdAt: Date | null
  }

  export type WorkshopVerificationCountAggregateOutputType = {
    id: number
    workshopId: number
    adminId: number
    decision: number
    reason: number
    createdAt: number
    _all: number
  }


  export type WorkshopVerificationMinAggregateInputType = {
    id?: true
    workshopId?: true
    adminId?: true
    decision?: true
    reason?: true
    createdAt?: true
  }

  export type WorkshopVerificationMaxAggregateInputType = {
    id?: true
    workshopId?: true
    adminId?: true
    decision?: true
    reason?: true
    createdAt?: true
  }

  export type WorkshopVerificationCountAggregateInputType = {
    id?: true
    workshopId?: true
    adminId?: true
    decision?: true
    reason?: true
    createdAt?: true
    _all?: true
  }

  export type WorkshopVerificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WorkshopVerification to aggregate.
     */
    where?: WorkshopVerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkshopVerifications to fetch.
     */
    orderBy?: WorkshopVerificationOrderByWithRelationInput | WorkshopVerificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WorkshopVerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkshopVerifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkshopVerifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WorkshopVerifications
    **/
    _count?: true | WorkshopVerificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WorkshopVerificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WorkshopVerificationMaxAggregateInputType
  }

  export type GetWorkshopVerificationAggregateType<T extends WorkshopVerificationAggregateArgs> = {
        [P in keyof T & keyof AggregateWorkshopVerification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWorkshopVerification[P]>
      : GetScalarType<T[P], AggregateWorkshopVerification[P]>
  }




  export type WorkshopVerificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkshopVerificationWhereInput
    orderBy?: WorkshopVerificationOrderByWithAggregationInput | WorkshopVerificationOrderByWithAggregationInput[]
    by: WorkshopVerificationScalarFieldEnum[] | WorkshopVerificationScalarFieldEnum
    having?: WorkshopVerificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WorkshopVerificationCountAggregateInputType | true
    _min?: WorkshopVerificationMinAggregateInputType
    _max?: WorkshopVerificationMaxAggregateInputType
  }

  export type WorkshopVerificationGroupByOutputType = {
    id: string
    workshopId: string
    adminId: string
    decision: $Enums.WorkshopStatus
    reason: string
    createdAt: Date
    _count: WorkshopVerificationCountAggregateOutputType | null
    _min: WorkshopVerificationMinAggregateOutputType | null
    _max: WorkshopVerificationMaxAggregateOutputType | null
  }

  type GetWorkshopVerificationGroupByPayload<T extends WorkshopVerificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WorkshopVerificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WorkshopVerificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WorkshopVerificationGroupByOutputType[P]>
            : GetScalarType<T[P], WorkshopVerificationGroupByOutputType[P]>
        }
      >
    >


  export type WorkshopVerificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workshopId?: boolean
    adminId?: boolean
    decision?: boolean
    reason?: boolean
    createdAt?: boolean
    workshop?: boolean | WorkshopDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workshopVerification"]>

  export type WorkshopVerificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workshopId?: boolean
    adminId?: boolean
    decision?: boolean
    reason?: boolean
    createdAt?: boolean
    workshop?: boolean | WorkshopDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workshopVerification"]>

  export type WorkshopVerificationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workshopId?: boolean
    adminId?: boolean
    decision?: boolean
    reason?: boolean
    createdAt?: boolean
    workshop?: boolean | WorkshopDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workshopVerification"]>

  export type WorkshopVerificationSelectScalar = {
    id?: boolean
    workshopId?: boolean
    adminId?: boolean
    decision?: boolean
    reason?: boolean
    createdAt?: boolean
  }

  export type WorkshopVerificationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "workshopId" | "adminId" | "decision" | "reason" | "createdAt", ExtArgs["result"]["workshopVerification"]>
  export type WorkshopVerificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workshop?: boolean | WorkshopDefaultArgs<ExtArgs>
  }
  export type WorkshopVerificationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workshop?: boolean | WorkshopDefaultArgs<ExtArgs>
  }
  export type WorkshopVerificationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workshop?: boolean | WorkshopDefaultArgs<ExtArgs>
  }

  export type $WorkshopVerificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WorkshopVerification"
    objects: {
      workshop: Prisma.$WorkshopPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      workshopId: string
      adminId: string
      decision: $Enums.WorkshopStatus
      reason: string
      createdAt: Date
    }, ExtArgs["result"]["workshopVerification"]>
    composites: {}
  }

  type WorkshopVerificationGetPayload<S extends boolean | null | undefined | WorkshopVerificationDefaultArgs> = $Result.GetResult<Prisma.$WorkshopVerificationPayload, S>

  type WorkshopVerificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WorkshopVerificationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WorkshopVerificationCountAggregateInputType | true
    }

  export interface WorkshopVerificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WorkshopVerification'], meta: { name: 'WorkshopVerification' } }
    /**
     * Find zero or one WorkshopVerification that matches the filter.
     * @param {WorkshopVerificationFindUniqueArgs} args - Arguments to find a WorkshopVerification
     * @example
     * // Get one WorkshopVerification
     * const workshopVerification = await prisma.workshopVerification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WorkshopVerificationFindUniqueArgs>(args: SelectSubset<T, WorkshopVerificationFindUniqueArgs<ExtArgs>>): Prisma__WorkshopVerificationClient<$Result.GetResult<Prisma.$WorkshopVerificationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one WorkshopVerification that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WorkshopVerificationFindUniqueOrThrowArgs} args - Arguments to find a WorkshopVerification
     * @example
     * // Get one WorkshopVerification
     * const workshopVerification = await prisma.workshopVerification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WorkshopVerificationFindUniqueOrThrowArgs>(args: SelectSubset<T, WorkshopVerificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WorkshopVerificationClient<$Result.GetResult<Prisma.$WorkshopVerificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WorkshopVerification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkshopVerificationFindFirstArgs} args - Arguments to find a WorkshopVerification
     * @example
     * // Get one WorkshopVerification
     * const workshopVerification = await prisma.workshopVerification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WorkshopVerificationFindFirstArgs>(args?: SelectSubset<T, WorkshopVerificationFindFirstArgs<ExtArgs>>): Prisma__WorkshopVerificationClient<$Result.GetResult<Prisma.$WorkshopVerificationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WorkshopVerification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkshopVerificationFindFirstOrThrowArgs} args - Arguments to find a WorkshopVerification
     * @example
     * // Get one WorkshopVerification
     * const workshopVerification = await prisma.workshopVerification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WorkshopVerificationFindFirstOrThrowArgs>(args?: SelectSubset<T, WorkshopVerificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__WorkshopVerificationClient<$Result.GetResult<Prisma.$WorkshopVerificationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more WorkshopVerifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkshopVerificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WorkshopVerifications
     * const workshopVerifications = await prisma.workshopVerification.findMany()
     * 
     * // Get first 10 WorkshopVerifications
     * const workshopVerifications = await prisma.workshopVerification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const workshopVerificationWithIdOnly = await prisma.workshopVerification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WorkshopVerificationFindManyArgs>(args?: SelectSubset<T, WorkshopVerificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkshopVerificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a WorkshopVerification.
     * @param {WorkshopVerificationCreateArgs} args - Arguments to create a WorkshopVerification.
     * @example
     * // Create one WorkshopVerification
     * const WorkshopVerification = await prisma.workshopVerification.create({
     *   data: {
     *     // ... data to create a WorkshopVerification
     *   }
     * })
     * 
     */
    create<T extends WorkshopVerificationCreateArgs>(args: SelectSubset<T, WorkshopVerificationCreateArgs<ExtArgs>>): Prisma__WorkshopVerificationClient<$Result.GetResult<Prisma.$WorkshopVerificationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many WorkshopVerifications.
     * @param {WorkshopVerificationCreateManyArgs} args - Arguments to create many WorkshopVerifications.
     * @example
     * // Create many WorkshopVerifications
     * const workshopVerification = await prisma.workshopVerification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WorkshopVerificationCreateManyArgs>(args?: SelectSubset<T, WorkshopVerificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WorkshopVerifications and returns the data saved in the database.
     * @param {WorkshopVerificationCreateManyAndReturnArgs} args - Arguments to create many WorkshopVerifications.
     * @example
     * // Create many WorkshopVerifications
     * const workshopVerification = await prisma.workshopVerification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WorkshopVerifications and only return the `id`
     * const workshopVerificationWithIdOnly = await prisma.workshopVerification.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WorkshopVerificationCreateManyAndReturnArgs>(args?: SelectSubset<T, WorkshopVerificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkshopVerificationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a WorkshopVerification.
     * @param {WorkshopVerificationDeleteArgs} args - Arguments to delete one WorkshopVerification.
     * @example
     * // Delete one WorkshopVerification
     * const WorkshopVerification = await prisma.workshopVerification.delete({
     *   where: {
     *     // ... filter to delete one WorkshopVerification
     *   }
     * })
     * 
     */
    delete<T extends WorkshopVerificationDeleteArgs>(args: SelectSubset<T, WorkshopVerificationDeleteArgs<ExtArgs>>): Prisma__WorkshopVerificationClient<$Result.GetResult<Prisma.$WorkshopVerificationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one WorkshopVerification.
     * @param {WorkshopVerificationUpdateArgs} args - Arguments to update one WorkshopVerification.
     * @example
     * // Update one WorkshopVerification
     * const workshopVerification = await prisma.workshopVerification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WorkshopVerificationUpdateArgs>(args: SelectSubset<T, WorkshopVerificationUpdateArgs<ExtArgs>>): Prisma__WorkshopVerificationClient<$Result.GetResult<Prisma.$WorkshopVerificationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more WorkshopVerifications.
     * @param {WorkshopVerificationDeleteManyArgs} args - Arguments to filter WorkshopVerifications to delete.
     * @example
     * // Delete a few WorkshopVerifications
     * const { count } = await prisma.workshopVerification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WorkshopVerificationDeleteManyArgs>(args?: SelectSubset<T, WorkshopVerificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WorkshopVerifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkshopVerificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WorkshopVerifications
     * const workshopVerification = await prisma.workshopVerification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WorkshopVerificationUpdateManyArgs>(args: SelectSubset<T, WorkshopVerificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WorkshopVerifications and returns the data updated in the database.
     * @param {WorkshopVerificationUpdateManyAndReturnArgs} args - Arguments to update many WorkshopVerifications.
     * @example
     * // Update many WorkshopVerifications
     * const workshopVerification = await prisma.workshopVerification.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more WorkshopVerifications and only return the `id`
     * const workshopVerificationWithIdOnly = await prisma.workshopVerification.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends WorkshopVerificationUpdateManyAndReturnArgs>(args: SelectSubset<T, WorkshopVerificationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkshopVerificationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one WorkshopVerification.
     * @param {WorkshopVerificationUpsertArgs} args - Arguments to update or create a WorkshopVerification.
     * @example
     * // Update or create a WorkshopVerification
     * const workshopVerification = await prisma.workshopVerification.upsert({
     *   create: {
     *     // ... data to create a WorkshopVerification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WorkshopVerification we want to update
     *   }
     * })
     */
    upsert<T extends WorkshopVerificationUpsertArgs>(args: SelectSubset<T, WorkshopVerificationUpsertArgs<ExtArgs>>): Prisma__WorkshopVerificationClient<$Result.GetResult<Prisma.$WorkshopVerificationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of WorkshopVerifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkshopVerificationCountArgs} args - Arguments to filter WorkshopVerifications to count.
     * @example
     * // Count the number of WorkshopVerifications
     * const count = await prisma.workshopVerification.count({
     *   where: {
     *     // ... the filter for the WorkshopVerifications we want to count
     *   }
     * })
    **/
    count<T extends WorkshopVerificationCountArgs>(
      args?: Subset<T, WorkshopVerificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WorkshopVerificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WorkshopVerification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkshopVerificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WorkshopVerificationAggregateArgs>(args: Subset<T, WorkshopVerificationAggregateArgs>): Prisma.PrismaPromise<GetWorkshopVerificationAggregateType<T>>

    /**
     * Group by WorkshopVerification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkshopVerificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WorkshopVerificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WorkshopVerificationGroupByArgs['orderBy'] }
        : { orderBy?: WorkshopVerificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WorkshopVerificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWorkshopVerificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WorkshopVerification model
   */
  readonly fields: WorkshopVerificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WorkshopVerification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WorkshopVerificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    workshop<T extends WorkshopDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WorkshopDefaultArgs<ExtArgs>>): Prisma__WorkshopClient<$Result.GetResult<Prisma.$WorkshopPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WorkshopVerification model
   */
  interface WorkshopVerificationFieldRefs {
    readonly id: FieldRef<"WorkshopVerification", 'String'>
    readonly workshopId: FieldRef<"WorkshopVerification", 'String'>
    readonly adminId: FieldRef<"WorkshopVerification", 'String'>
    readonly decision: FieldRef<"WorkshopVerification", 'WorkshopStatus'>
    readonly reason: FieldRef<"WorkshopVerification", 'String'>
    readonly createdAt: FieldRef<"WorkshopVerification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * WorkshopVerification findUnique
   */
  export type WorkshopVerificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkshopVerification
     */
    select?: WorkshopVerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkshopVerification
     */
    omit?: WorkshopVerificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkshopVerificationInclude<ExtArgs> | null
    /**
     * Filter, which WorkshopVerification to fetch.
     */
    where: WorkshopVerificationWhereUniqueInput
  }

  /**
   * WorkshopVerification findUniqueOrThrow
   */
  export type WorkshopVerificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkshopVerification
     */
    select?: WorkshopVerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkshopVerification
     */
    omit?: WorkshopVerificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkshopVerificationInclude<ExtArgs> | null
    /**
     * Filter, which WorkshopVerification to fetch.
     */
    where: WorkshopVerificationWhereUniqueInput
  }

  /**
   * WorkshopVerification findFirst
   */
  export type WorkshopVerificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkshopVerification
     */
    select?: WorkshopVerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkshopVerification
     */
    omit?: WorkshopVerificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkshopVerificationInclude<ExtArgs> | null
    /**
     * Filter, which WorkshopVerification to fetch.
     */
    where?: WorkshopVerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkshopVerifications to fetch.
     */
    orderBy?: WorkshopVerificationOrderByWithRelationInput | WorkshopVerificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorkshopVerifications.
     */
    cursor?: WorkshopVerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkshopVerifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkshopVerifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorkshopVerifications.
     */
    distinct?: WorkshopVerificationScalarFieldEnum | WorkshopVerificationScalarFieldEnum[]
  }

  /**
   * WorkshopVerification findFirstOrThrow
   */
  export type WorkshopVerificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkshopVerification
     */
    select?: WorkshopVerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkshopVerification
     */
    omit?: WorkshopVerificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkshopVerificationInclude<ExtArgs> | null
    /**
     * Filter, which WorkshopVerification to fetch.
     */
    where?: WorkshopVerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkshopVerifications to fetch.
     */
    orderBy?: WorkshopVerificationOrderByWithRelationInput | WorkshopVerificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorkshopVerifications.
     */
    cursor?: WorkshopVerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkshopVerifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkshopVerifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorkshopVerifications.
     */
    distinct?: WorkshopVerificationScalarFieldEnum | WorkshopVerificationScalarFieldEnum[]
  }

  /**
   * WorkshopVerification findMany
   */
  export type WorkshopVerificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkshopVerification
     */
    select?: WorkshopVerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkshopVerification
     */
    omit?: WorkshopVerificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkshopVerificationInclude<ExtArgs> | null
    /**
     * Filter, which WorkshopVerifications to fetch.
     */
    where?: WorkshopVerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkshopVerifications to fetch.
     */
    orderBy?: WorkshopVerificationOrderByWithRelationInput | WorkshopVerificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WorkshopVerifications.
     */
    cursor?: WorkshopVerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkshopVerifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkshopVerifications.
     */
    skip?: number
    distinct?: WorkshopVerificationScalarFieldEnum | WorkshopVerificationScalarFieldEnum[]
  }

  /**
   * WorkshopVerification create
   */
  export type WorkshopVerificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkshopVerification
     */
    select?: WorkshopVerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkshopVerification
     */
    omit?: WorkshopVerificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkshopVerificationInclude<ExtArgs> | null
    /**
     * The data needed to create a WorkshopVerification.
     */
    data: XOR<WorkshopVerificationCreateInput, WorkshopVerificationUncheckedCreateInput>
  }

  /**
   * WorkshopVerification createMany
   */
  export type WorkshopVerificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WorkshopVerifications.
     */
    data: WorkshopVerificationCreateManyInput | WorkshopVerificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WorkshopVerification createManyAndReturn
   */
  export type WorkshopVerificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkshopVerification
     */
    select?: WorkshopVerificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WorkshopVerification
     */
    omit?: WorkshopVerificationOmit<ExtArgs> | null
    /**
     * The data used to create many WorkshopVerifications.
     */
    data: WorkshopVerificationCreateManyInput | WorkshopVerificationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkshopVerificationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * WorkshopVerification update
   */
  export type WorkshopVerificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkshopVerification
     */
    select?: WorkshopVerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkshopVerification
     */
    omit?: WorkshopVerificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkshopVerificationInclude<ExtArgs> | null
    /**
     * The data needed to update a WorkshopVerification.
     */
    data: XOR<WorkshopVerificationUpdateInput, WorkshopVerificationUncheckedUpdateInput>
    /**
     * Choose, which WorkshopVerification to update.
     */
    where: WorkshopVerificationWhereUniqueInput
  }

  /**
   * WorkshopVerification updateMany
   */
  export type WorkshopVerificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WorkshopVerifications.
     */
    data: XOR<WorkshopVerificationUpdateManyMutationInput, WorkshopVerificationUncheckedUpdateManyInput>
    /**
     * Filter which WorkshopVerifications to update
     */
    where?: WorkshopVerificationWhereInput
    /**
     * Limit how many WorkshopVerifications to update.
     */
    limit?: number
  }

  /**
   * WorkshopVerification updateManyAndReturn
   */
  export type WorkshopVerificationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkshopVerification
     */
    select?: WorkshopVerificationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WorkshopVerification
     */
    omit?: WorkshopVerificationOmit<ExtArgs> | null
    /**
     * The data used to update WorkshopVerifications.
     */
    data: XOR<WorkshopVerificationUpdateManyMutationInput, WorkshopVerificationUncheckedUpdateManyInput>
    /**
     * Filter which WorkshopVerifications to update
     */
    where?: WorkshopVerificationWhereInput
    /**
     * Limit how many WorkshopVerifications to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkshopVerificationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * WorkshopVerification upsert
   */
  export type WorkshopVerificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkshopVerification
     */
    select?: WorkshopVerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkshopVerification
     */
    omit?: WorkshopVerificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkshopVerificationInclude<ExtArgs> | null
    /**
     * The filter to search for the WorkshopVerification to update in case it exists.
     */
    where: WorkshopVerificationWhereUniqueInput
    /**
     * In case the WorkshopVerification found by the `where` argument doesn't exist, create a new WorkshopVerification with this data.
     */
    create: XOR<WorkshopVerificationCreateInput, WorkshopVerificationUncheckedCreateInput>
    /**
     * In case the WorkshopVerification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WorkshopVerificationUpdateInput, WorkshopVerificationUncheckedUpdateInput>
  }

  /**
   * WorkshopVerification delete
   */
  export type WorkshopVerificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkshopVerification
     */
    select?: WorkshopVerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkshopVerification
     */
    omit?: WorkshopVerificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkshopVerificationInclude<ExtArgs> | null
    /**
     * Filter which WorkshopVerification to delete.
     */
    where: WorkshopVerificationWhereUniqueInput
  }

  /**
   * WorkshopVerification deleteMany
   */
  export type WorkshopVerificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WorkshopVerifications to delete
     */
    where?: WorkshopVerificationWhereInput
    /**
     * Limit how many WorkshopVerifications to delete.
     */
    limit?: number
  }

  /**
   * WorkshopVerification without action
   */
  export type WorkshopVerificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkshopVerification
     */
    select?: WorkshopVerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkshopVerification
     */
    omit?: WorkshopVerificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkshopVerificationInclude<ExtArgs> | null
  }


  /**
   * Model Quote
   */

  export type AggregateQuote = {
    _count: QuoteCountAggregateOutputType | null
    _avg: QuoteAvgAggregateOutputType | null
    _sum: QuoteSumAggregateOutputType | null
    _min: QuoteMinAggregateOutputType | null
    _max: QuoteMaxAggregateOutputType | null
  }

  export type QuoteAvgAggregateOutputType = {
    version: number | null
    laborCost: number | null
    totalParts: number | null
    totalCost: number | null
  }

  export type QuoteSumAggregateOutputType = {
    version: number | null
    laborCost: number | null
    totalParts: number | null
    totalCost: number | null
  }

  export type QuoteMinAggregateOutputType = {
    id: string | null
    requestId: string | null
    workshopId: string | null
    version: number | null
    diagnosis: string | null
    laborCost: number | null
    totalParts: number | null
    totalCost: number | null
    estimatedTime: string | null
    validUntil: Date | null
    notes: string | null
    status: $Enums.QuoteStatus | null
    rejectionReason: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type QuoteMaxAggregateOutputType = {
    id: string | null
    requestId: string | null
    workshopId: string | null
    version: number | null
    diagnosis: string | null
    laborCost: number | null
    totalParts: number | null
    totalCost: number | null
    estimatedTime: string | null
    validUntil: Date | null
    notes: string | null
    status: $Enums.QuoteStatus | null
    rejectionReason: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type QuoteCountAggregateOutputType = {
    id: number
    requestId: number
    workshopId: number
    version: number
    diagnosis: number
    laborCost: number
    totalParts: number
    totalCost: number
    estimatedTime: number
    validUntil: number
    notes: number
    status: number
    rejectionReason: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type QuoteAvgAggregateInputType = {
    version?: true
    laborCost?: true
    totalParts?: true
    totalCost?: true
  }

  export type QuoteSumAggregateInputType = {
    version?: true
    laborCost?: true
    totalParts?: true
    totalCost?: true
  }

  export type QuoteMinAggregateInputType = {
    id?: true
    requestId?: true
    workshopId?: true
    version?: true
    diagnosis?: true
    laborCost?: true
    totalParts?: true
    totalCost?: true
    estimatedTime?: true
    validUntil?: true
    notes?: true
    status?: true
    rejectionReason?: true
    createdAt?: true
    updatedAt?: true
  }

  export type QuoteMaxAggregateInputType = {
    id?: true
    requestId?: true
    workshopId?: true
    version?: true
    diagnosis?: true
    laborCost?: true
    totalParts?: true
    totalCost?: true
    estimatedTime?: true
    validUntil?: true
    notes?: true
    status?: true
    rejectionReason?: true
    createdAt?: true
    updatedAt?: true
  }

  export type QuoteCountAggregateInputType = {
    id?: true
    requestId?: true
    workshopId?: true
    version?: true
    diagnosis?: true
    laborCost?: true
    totalParts?: true
    totalCost?: true
    estimatedTime?: true
    validUntil?: true
    notes?: true
    status?: true
    rejectionReason?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type QuoteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Quote to aggregate.
     */
    where?: QuoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Quotes to fetch.
     */
    orderBy?: QuoteOrderByWithRelationInput | QuoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: QuoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Quotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Quotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Quotes
    **/
    _count?: true | QuoteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: QuoteAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: QuoteSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QuoteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QuoteMaxAggregateInputType
  }

  export type GetQuoteAggregateType<T extends QuoteAggregateArgs> = {
        [P in keyof T & keyof AggregateQuote]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuote[P]>
      : GetScalarType<T[P], AggregateQuote[P]>
  }




  export type QuoteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuoteWhereInput
    orderBy?: QuoteOrderByWithAggregationInput | QuoteOrderByWithAggregationInput[]
    by: QuoteScalarFieldEnum[] | QuoteScalarFieldEnum
    having?: QuoteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QuoteCountAggregateInputType | true
    _avg?: QuoteAvgAggregateInputType
    _sum?: QuoteSumAggregateInputType
    _min?: QuoteMinAggregateInputType
    _max?: QuoteMaxAggregateInputType
  }

  export type QuoteGroupByOutputType = {
    id: string
    requestId: string
    workshopId: string
    version: number
    diagnosis: string
    laborCost: number
    totalParts: number
    totalCost: number
    estimatedTime: string
    validUntil: Date
    notes: string | null
    status: $Enums.QuoteStatus
    rejectionReason: string | null
    createdAt: Date
    updatedAt: Date
    _count: QuoteCountAggregateOutputType | null
    _avg: QuoteAvgAggregateOutputType | null
    _sum: QuoteSumAggregateOutputType | null
    _min: QuoteMinAggregateOutputType | null
    _max: QuoteMaxAggregateOutputType | null
  }

  type GetQuoteGroupByPayload<T extends QuoteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<QuoteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QuoteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QuoteGroupByOutputType[P]>
            : GetScalarType<T[P], QuoteGroupByOutputType[P]>
        }
      >
    >


  export type QuoteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    requestId?: boolean
    workshopId?: boolean
    version?: boolean
    diagnosis?: boolean
    laborCost?: boolean
    totalParts?: boolean
    totalCost?: boolean
    estimatedTime?: boolean
    validUntil?: boolean
    notes?: boolean
    status?: boolean
    rejectionReason?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    request?: boolean | ServiceRequestDefaultArgs<ExtArgs>
    workshop?: boolean | WorkshopDefaultArgs<ExtArgs>
    parts?: boolean | Quote$partsArgs<ExtArgs>
    workOrder?: boolean | Quote$workOrderArgs<ExtArgs>
    aiAnalysis?: boolean | Quote$aiAnalysisArgs<ExtArgs>
    _count?: boolean | QuoteCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["quote"]>

  export type QuoteSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    requestId?: boolean
    workshopId?: boolean
    version?: boolean
    diagnosis?: boolean
    laborCost?: boolean
    totalParts?: boolean
    totalCost?: boolean
    estimatedTime?: boolean
    validUntil?: boolean
    notes?: boolean
    status?: boolean
    rejectionReason?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    request?: boolean | ServiceRequestDefaultArgs<ExtArgs>
    workshop?: boolean | WorkshopDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["quote"]>

  export type QuoteSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    requestId?: boolean
    workshopId?: boolean
    version?: boolean
    diagnosis?: boolean
    laborCost?: boolean
    totalParts?: boolean
    totalCost?: boolean
    estimatedTime?: boolean
    validUntil?: boolean
    notes?: boolean
    status?: boolean
    rejectionReason?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    request?: boolean | ServiceRequestDefaultArgs<ExtArgs>
    workshop?: boolean | WorkshopDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["quote"]>

  export type QuoteSelectScalar = {
    id?: boolean
    requestId?: boolean
    workshopId?: boolean
    version?: boolean
    diagnosis?: boolean
    laborCost?: boolean
    totalParts?: boolean
    totalCost?: boolean
    estimatedTime?: boolean
    validUntil?: boolean
    notes?: boolean
    status?: boolean
    rejectionReason?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type QuoteOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "requestId" | "workshopId" | "version" | "diagnosis" | "laborCost" | "totalParts" | "totalCost" | "estimatedTime" | "validUntil" | "notes" | "status" | "rejectionReason" | "createdAt" | "updatedAt", ExtArgs["result"]["quote"]>
  export type QuoteInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    request?: boolean | ServiceRequestDefaultArgs<ExtArgs>
    workshop?: boolean | WorkshopDefaultArgs<ExtArgs>
    parts?: boolean | Quote$partsArgs<ExtArgs>
    workOrder?: boolean | Quote$workOrderArgs<ExtArgs>
    aiAnalysis?: boolean | Quote$aiAnalysisArgs<ExtArgs>
    _count?: boolean | QuoteCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type QuoteIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    request?: boolean | ServiceRequestDefaultArgs<ExtArgs>
    workshop?: boolean | WorkshopDefaultArgs<ExtArgs>
  }
  export type QuoteIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    request?: boolean | ServiceRequestDefaultArgs<ExtArgs>
    workshop?: boolean | WorkshopDefaultArgs<ExtArgs>
  }

  export type $QuotePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Quote"
    objects: {
      request: Prisma.$ServiceRequestPayload<ExtArgs>
      workshop: Prisma.$WorkshopPayload<ExtArgs>
      parts: Prisma.$QuotePartItemPayload<ExtArgs>[]
      workOrder: Prisma.$WorkOrderPayload<ExtArgs> | null
      aiAnalysis: Prisma.$AiQuoteAnalysisPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      requestId: string
      workshopId: string
      version: number
      diagnosis: string
      laborCost: number
      totalParts: number
      totalCost: number
      estimatedTime: string
      validUntil: Date
      notes: string | null
      status: $Enums.QuoteStatus
      rejectionReason: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["quote"]>
    composites: {}
  }

  type QuoteGetPayload<S extends boolean | null | undefined | QuoteDefaultArgs> = $Result.GetResult<Prisma.$QuotePayload, S>

  type QuoteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<QuoteFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: QuoteCountAggregateInputType | true
    }

  export interface QuoteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Quote'], meta: { name: 'Quote' } }
    /**
     * Find zero or one Quote that matches the filter.
     * @param {QuoteFindUniqueArgs} args - Arguments to find a Quote
     * @example
     * // Get one Quote
     * const quote = await prisma.quote.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends QuoteFindUniqueArgs>(args: SelectSubset<T, QuoteFindUniqueArgs<ExtArgs>>): Prisma__QuoteClient<$Result.GetResult<Prisma.$QuotePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Quote that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {QuoteFindUniqueOrThrowArgs} args - Arguments to find a Quote
     * @example
     * // Get one Quote
     * const quote = await prisma.quote.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends QuoteFindUniqueOrThrowArgs>(args: SelectSubset<T, QuoteFindUniqueOrThrowArgs<ExtArgs>>): Prisma__QuoteClient<$Result.GetResult<Prisma.$QuotePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Quote that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuoteFindFirstArgs} args - Arguments to find a Quote
     * @example
     * // Get one Quote
     * const quote = await prisma.quote.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends QuoteFindFirstArgs>(args?: SelectSubset<T, QuoteFindFirstArgs<ExtArgs>>): Prisma__QuoteClient<$Result.GetResult<Prisma.$QuotePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Quote that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuoteFindFirstOrThrowArgs} args - Arguments to find a Quote
     * @example
     * // Get one Quote
     * const quote = await prisma.quote.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends QuoteFindFirstOrThrowArgs>(args?: SelectSubset<T, QuoteFindFirstOrThrowArgs<ExtArgs>>): Prisma__QuoteClient<$Result.GetResult<Prisma.$QuotePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Quotes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuoteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Quotes
     * const quotes = await prisma.quote.findMany()
     * 
     * // Get first 10 Quotes
     * const quotes = await prisma.quote.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const quoteWithIdOnly = await prisma.quote.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends QuoteFindManyArgs>(args?: SelectSubset<T, QuoteFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuotePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Quote.
     * @param {QuoteCreateArgs} args - Arguments to create a Quote.
     * @example
     * // Create one Quote
     * const Quote = await prisma.quote.create({
     *   data: {
     *     // ... data to create a Quote
     *   }
     * })
     * 
     */
    create<T extends QuoteCreateArgs>(args: SelectSubset<T, QuoteCreateArgs<ExtArgs>>): Prisma__QuoteClient<$Result.GetResult<Prisma.$QuotePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Quotes.
     * @param {QuoteCreateManyArgs} args - Arguments to create many Quotes.
     * @example
     * // Create many Quotes
     * const quote = await prisma.quote.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends QuoteCreateManyArgs>(args?: SelectSubset<T, QuoteCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Quotes and returns the data saved in the database.
     * @param {QuoteCreateManyAndReturnArgs} args - Arguments to create many Quotes.
     * @example
     * // Create many Quotes
     * const quote = await prisma.quote.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Quotes and only return the `id`
     * const quoteWithIdOnly = await prisma.quote.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends QuoteCreateManyAndReturnArgs>(args?: SelectSubset<T, QuoteCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuotePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Quote.
     * @param {QuoteDeleteArgs} args - Arguments to delete one Quote.
     * @example
     * // Delete one Quote
     * const Quote = await prisma.quote.delete({
     *   where: {
     *     // ... filter to delete one Quote
     *   }
     * })
     * 
     */
    delete<T extends QuoteDeleteArgs>(args: SelectSubset<T, QuoteDeleteArgs<ExtArgs>>): Prisma__QuoteClient<$Result.GetResult<Prisma.$QuotePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Quote.
     * @param {QuoteUpdateArgs} args - Arguments to update one Quote.
     * @example
     * // Update one Quote
     * const quote = await prisma.quote.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends QuoteUpdateArgs>(args: SelectSubset<T, QuoteUpdateArgs<ExtArgs>>): Prisma__QuoteClient<$Result.GetResult<Prisma.$QuotePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Quotes.
     * @param {QuoteDeleteManyArgs} args - Arguments to filter Quotes to delete.
     * @example
     * // Delete a few Quotes
     * const { count } = await prisma.quote.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends QuoteDeleteManyArgs>(args?: SelectSubset<T, QuoteDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Quotes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuoteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Quotes
     * const quote = await prisma.quote.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends QuoteUpdateManyArgs>(args: SelectSubset<T, QuoteUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Quotes and returns the data updated in the database.
     * @param {QuoteUpdateManyAndReturnArgs} args - Arguments to update many Quotes.
     * @example
     * // Update many Quotes
     * const quote = await prisma.quote.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Quotes and only return the `id`
     * const quoteWithIdOnly = await prisma.quote.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends QuoteUpdateManyAndReturnArgs>(args: SelectSubset<T, QuoteUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuotePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Quote.
     * @param {QuoteUpsertArgs} args - Arguments to update or create a Quote.
     * @example
     * // Update or create a Quote
     * const quote = await prisma.quote.upsert({
     *   create: {
     *     // ... data to create a Quote
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Quote we want to update
     *   }
     * })
     */
    upsert<T extends QuoteUpsertArgs>(args: SelectSubset<T, QuoteUpsertArgs<ExtArgs>>): Prisma__QuoteClient<$Result.GetResult<Prisma.$QuotePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Quotes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuoteCountArgs} args - Arguments to filter Quotes to count.
     * @example
     * // Count the number of Quotes
     * const count = await prisma.quote.count({
     *   where: {
     *     // ... the filter for the Quotes we want to count
     *   }
     * })
    **/
    count<T extends QuoteCountArgs>(
      args?: Subset<T, QuoteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QuoteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Quote.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuoteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QuoteAggregateArgs>(args: Subset<T, QuoteAggregateArgs>): Prisma.PrismaPromise<GetQuoteAggregateType<T>>

    /**
     * Group by Quote.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuoteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QuoteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QuoteGroupByArgs['orderBy'] }
        : { orderBy?: QuoteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QuoteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQuoteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Quote model
   */
  readonly fields: QuoteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Quote.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__QuoteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    request<T extends ServiceRequestDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ServiceRequestDefaultArgs<ExtArgs>>): Prisma__ServiceRequestClient<$Result.GetResult<Prisma.$ServiceRequestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    workshop<T extends WorkshopDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WorkshopDefaultArgs<ExtArgs>>): Prisma__WorkshopClient<$Result.GetResult<Prisma.$WorkshopPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    parts<T extends Quote$partsArgs<ExtArgs> = {}>(args?: Subset<T, Quote$partsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuotePartItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    workOrder<T extends Quote$workOrderArgs<ExtArgs> = {}>(args?: Subset<T, Quote$workOrderArgs<ExtArgs>>): Prisma__WorkOrderClient<$Result.GetResult<Prisma.$WorkOrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    aiAnalysis<T extends Quote$aiAnalysisArgs<ExtArgs> = {}>(args?: Subset<T, Quote$aiAnalysisArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AiQuoteAnalysisPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Quote model
   */
  interface QuoteFieldRefs {
    readonly id: FieldRef<"Quote", 'String'>
    readonly requestId: FieldRef<"Quote", 'String'>
    readonly workshopId: FieldRef<"Quote", 'String'>
    readonly version: FieldRef<"Quote", 'Int'>
    readonly diagnosis: FieldRef<"Quote", 'String'>
    readonly laborCost: FieldRef<"Quote", 'Float'>
    readonly totalParts: FieldRef<"Quote", 'Float'>
    readonly totalCost: FieldRef<"Quote", 'Float'>
    readonly estimatedTime: FieldRef<"Quote", 'String'>
    readonly validUntil: FieldRef<"Quote", 'DateTime'>
    readonly notes: FieldRef<"Quote", 'String'>
    readonly status: FieldRef<"Quote", 'QuoteStatus'>
    readonly rejectionReason: FieldRef<"Quote", 'String'>
    readonly createdAt: FieldRef<"Quote", 'DateTime'>
    readonly updatedAt: FieldRef<"Quote", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Quote findUnique
   */
  export type QuoteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quote
     */
    select?: QuoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quote
     */
    omit?: QuoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteInclude<ExtArgs> | null
    /**
     * Filter, which Quote to fetch.
     */
    where: QuoteWhereUniqueInput
  }

  /**
   * Quote findUniqueOrThrow
   */
  export type QuoteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quote
     */
    select?: QuoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quote
     */
    omit?: QuoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteInclude<ExtArgs> | null
    /**
     * Filter, which Quote to fetch.
     */
    where: QuoteWhereUniqueInput
  }

  /**
   * Quote findFirst
   */
  export type QuoteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quote
     */
    select?: QuoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quote
     */
    omit?: QuoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteInclude<ExtArgs> | null
    /**
     * Filter, which Quote to fetch.
     */
    where?: QuoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Quotes to fetch.
     */
    orderBy?: QuoteOrderByWithRelationInput | QuoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Quotes.
     */
    cursor?: QuoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Quotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Quotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Quotes.
     */
    distinct?: QuoteScalarFieldEnum | QuoteScalarFieldEnum[]
  }

  /**
   * Quote findFirstOrThrow
   */
  export type QuoteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quote
     */
    select?: QuoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quote
     */
    omit?: QuoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteInclude<ExtArgs> | null
    /**
     * Filter, which Quote to fetch.
     */
    where?: QuoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Quotes to fetch.
     */
    orderBy?: QuoteOrderByWithRelationInput | QuoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Quotes.
     */
    cursor?: QuoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Quotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Quotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Quotes.
     */
    distinct?: QuoteScalarFieldEnum | QuoteScalarFieldEnum[]
  }

  /**
   * Quote findMany
   */
  export type QuoteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quote
     */
    select?: QuoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quote
     */
    omit?: QuoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteInclude<ExtArgs> | null
    /**
     * Filter, which Quotes to fetch.
     */
    where?: QuoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Quotes to fetch.
     */
    orderBy?: QuoteOrderByWithRelationInput | QuoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Quotes.
     */
    cursor?: QuoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Quotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Quotes.
     */
    skip?: number
    distinct?: QuoteScalarFieldEnum | QuoteScalarFieldEnum[]
  }

  /**
   * Quote create
   */
  export type QuoteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quote
     */
    select?: QuoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quote
     */
    omit?: QuoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteInclude<ExtArgs> | null
    /**
     * The data needed to create a Quote.
     */
    data: XOR<QuoteCreateInput, QuoteUncheckedCreateInput>
  }

  /**
   * Quote createMany
   */
  export type QuoteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Quotes.
     */
    data: QuoteCreateManyInput | QuoteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Quote createManyAndReturn
   */
  export type QuoteCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quote
     */
    select?: QuoteSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Quote
     */
    omit?: QuoteOmit<ExtArgs> | null
    /**
     * The data used to create many Quotes.
     */
    data: QuoteCreateManyInput | QuoteCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Quote update
   */
  export type QuoteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quote
     */
    select?: QuoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quote
     */
    omit?: QuoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteInclude<ExtArgs> | null
    /**
     * The data needed to update a Quote.
     */
    data: XOR<QuoteUpdateInput, QuoteUncheckedUpdateInput>
    /**
     * Choose, which Quote to update.
     */
    where: QuoteWhereUniqueInput
  }

  /**
   * Quote updateMany
   */
  export type QuoteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Quotes.
     */
    data: XOR<QuoteUpdateManyMutationInput, QuoteUncheckedUpdateManyInput>
    /**
     * Filter which Quotes to update
     */
    where?: QuoteWhereInput
    /**
     * Limit how many Quotes to update.
     */
    limit?: number
  }

  /**
   * Quote updateManyAndReturn
   */
  export type QuoteUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quote
     */
    select?: QuoteSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Quote
     */
    omit?: QuoteOmit<ExtArgs> | null
    /**
     * The data used to update Quotes.
     */
    data: XOR<QuoteUpdateManyMutationInput, QuoteUncheckedUpdateManyInput>
    /**
     * Filter which Quotes to update
     */
    where?: QuoteWhereInput
    /**
     * Limit how many Quotes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Quote upsert
   */
  export type QuoteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quote
     */
    select?: QuoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quote
     */
    omit?: QuoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteInclude<ExtArgs> | null
    /**
     * The filter to search for the Quote to update in case it exists.
     */
    where: QuoteWhereUniqueInput
    /**
     * In case the Quote found by the `where` argument doesn't exist, create a new Quote with this data.
     */
    create: XOR<QuoteCreateInput, QuoteUncheckedCreateInput>
    /**
     * In case the Quote was found with the provided `where` argument, update it with this data.
     */
    update: XOR<QuoteUpdateInput, QuoteUncheckedUpdateInput>
  }

  /**
   * Quote delete
   */
  export type QuoteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quote
     */
    select?: QuoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quote
     */
    omit?: QuoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteInclude<ExtArgs> | null
    /**
     * Filter which Quote to delete.
     */
    where: QuoteWhereUniqueInput
  }

  /**
   * Quote deleteMany
   */
  export type QuoteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Quotes to delete
     */
    where?: QuoteWhereInput
    /**
     * Limit how many Quotes to delete.
     */
    limit?: number
  }

  /**
   * Quote.parts
   */
  export type Quote$partsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuotePartItem
     */
    select?: QuotePartItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuotePartItem
     */
    omit?: QuotePartItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuotePartItemInclude<ExtArgs> | null
    where?: QuotePartItemWhereInput
    orderBy?: QuotePartItemOrderByWithRelationInput | QuotePartItemOrderByWithRelationInput[]
    cursor?: QuotePartItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuotePartItemScalarFieldEnum | QuotePartItemScalarFieldEnum[]
  }

  /**
   * Quote.workOrder
   */
  export type Quote$workOrderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkOrder
     */
    select?: WorkOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkOrder
     */
    omit?: WorkOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkOrderInclude<ExtArgs> | null
    where?: WorkOrderWhereInput
  }

  /**
   * Quote.aiAnalysis
   */
  export type Quote$aiAnalysisArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiQuoteAnalysis
     */
    select?: AiQuoteAnalysisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiQuoteAnalysis
     */
    omit?: AiQuoteAnalysisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiQuoteAnalysisInclude<ExtArgs> | null
    where?: AiQuoteAnalysisWhereInput
    orderBy?: AiQuoteAnalysisOrderByWithRelationInput | AiQuoteAnalysisOrderByWithRelationInput[]
    cursor?: AiQuoteAnalysisWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AiQuoteAnalysisScalarFieldEnum | AiQuoteAnalysisScalarFieldEnum[]
  }

  /**
   * Quote without action
   */
  export type QuoteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quote
     */
    select?: QuoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quote
     */
    omit?: QuoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteInclude<ExtArgs> | null
  }


  /**
   * Model QuotePartItem
   */

  export type AggregateQuotePartItem = {
    _count: QuotePartItemCountAggregateOutputType | null
    _avg: QuotePartItemAvgAggregateOutputType | null
    _sum: QuotePartItemSumAggregateOutputType | null
    _min: QuotePartItemMinAggregateOutputType | null
    _max: QuotePartItemMaxAggregateOutputType | null
  }

  export type QuotePartItemAvgAggregateOutputType = {
    quantity: number | null
    unitPrice: number | null
    alternativePrice: number | null
  }

  export type QuotePartItemSumAggregateOutputType = {
    quantity: number | null
    unitPrice: number | null
    alternativePrice: number | null
  }

  export type QuotePartItemMinAggregateOutputType = {
    id: string | null
    quoteId: string | null
    name: string | null
    quantity: number | null
    unitPrice: number | null
    partType: $Enums.PartType | null
    notes: string | null
    alternativeName: string | null
    alternativePrice: number | null
    alternativeType: $Enums.PartType | null
    alternativeNotes: string | null
    selectedAlternative: boolean | null
    createdAt: Date | null
  }

  export type QuotePartItemMaxAggregateOutputType = {
    id: string | null
    quoteId: string | null
    name: string | null
    quantity: number | null
    unitPrice: number | null
    partType: $Enums.PartType | null
    notes: string | null
    alternativeName: string | null
    alternativePrice: number | null
    alternativeType: $Enums.PartType | null
    alternativeNotes: string | null
    selectedAlternative: boolean | null
    createdAt: Date | null
  }

  export type QuotePartItemCountAggregateOutputType = {
    id: number
    quoteId: number
    name: number
    quantity: number
    unitPrice: number
    partType: number
    notes: number
    alternativeName: number
    alternativePrice: number
    alternativeType: number
    alternativeNotes: number
    selectedAlternative: number
    createdAt: number
    _all: number
  }


  export type QuotePartItemAvgAggregateInputType = {
    quantity?: true
    unitPrice?: true
    alternativePrice?: true
  }

  export type QuotePartItemSumAggregateInputType = {
    quantity?: true
    unitPrice?: true
    alternativePrice?: true
  }

  export type QuotePartItemMinAggregateInputType = {
    id?: true
    quoteId?: true
    name?: true
    quantity?: true
    unitPrice?: true
    partType?: true
    notes?: true
    alternativeName?: true
    alternativePrice?: true
    alternativeType?: true
    alternativeNotes?: true
    selectedAlternative?: true
    createdAt?: true
  }

  export type QuotePartItemMaxAggregateInputType = {
    id?: true
    quoteId?: true
    name?: true
    quantity?: true
    unitPrice?: true
    partType?: true
    notes?: true
    alternativeName?: true
    alternativePrice?: true
    alternativeType?: true
    alternativeNotes?: true
    selectedAlternative?: true
    createdAt?: true
  }

  export type QuotePartItemCountAggregateInputType = {
    id?: true
    quoteId?: true
    name?: true
    quantity?: true
    unitPrice?: true
    partType?: true
    notes?: true
    alternativeName?: true
    alternativePrice?: true
    alternativeType?: true
    alternativeNotes?: true
    selectedAlternative?: true
    createdAt?: true
    _all?: true
  }

  export type QuotePartItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QuotePartItem to aggregate.
     */
    where?: QuotePartItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuotePartItems to fetch.
     */
    orderBy?: QuotePartItemOrderByWithRelationInput | QuotePartItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: QuotePartItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuotePartItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuotePartItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned QuotePartItems
    **/
    _count?: true | QuotePartItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: QuotePartItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: QuotePartItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QuotePartItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QuotePartItemMaxAggregateInputType
  }

  export type GetQuotePartItemAggregateType<T extends QuotePartItemAggregateArgs> = {
        [P in keyof T & keyof AggregateQuotePartItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuotePartItem[P]>
      : GetScalarType<T[P], AggregateQuotePartItem[P]>
  }




  export type QuotePartItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuotePartItemWhereInput
    orderBy?: QuotePartItemOrderByWithAggregationInput | QuotePartItemOrderByWithAggregationInput[]
    by: QuotePartItemScalarFieldEnum[] | QuotePartItemScalarFieldEnum
    having?: QuotePartItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QuotePartItemCountAggregateInputType | true
    _avg?: QuotePartItemAvgAggregateInputType
    _sum?: QuotePartItemSumAggregateInputType
    _min?: QuotePartItemMinAggregateInputType
    _max?: QuotePartItemMaxAggregateInputType
  }

  export type QuotePartItemGroupByOutputType = {
    id: string
    quoteId: string
    name: string
    quantity: number
    unitPrice: number
    partType: $Enums.PartType
    notes: string | null
    alternativeName: string | null
    alternativePrice: number | null
    alternativeType: $Enums.PartType | null
    alternativeNotes: string | null
    selectedAlternative: boolean
    createdAt: Date
    _count: QuotePartItemCountAggregateOutputType | null
    _avg: QuotePartItemAvgAggregateOutputType | null
    _sum: QuotePartItemSumAggregateOutputType | null
    _min: QuotePartItemMinAggregateOutputType | null
    _max: QuotePartItemMaxAggregateOutputType | null
  }

  type GetQuotePartItemGroupByPayload<T extends QuotePartItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<QuotePartItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QuotePartItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QuotePartItemGroupByOutputType[P]>
            : GetScalarType<T[P], QuotePartItemGroupByOutputType[P]>
        }
      >
    >


  export type QuotePartItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    quoteId?: boolean
    name?: boolean
    quantity?: boolean
    unitPrice?: boolean
    partType?: boolean
    notes?: boolean
    alternativeName?: boolean
    alternativePrice?: boolean
    alternativeType?: boolean
    alternativeNotes?: boolean
    selectedAlternative?: boolean
    createdAt?: boolean
    quote?: boolean | QuoteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["quotePartItem"]>

  export type QuotePartItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    quoteId?: boolean
    name?: boolean
    quantity?: boolean
    unitPrice?: boolean
    partType?: boolean
    notes?: boolean
    alternativeName?: boolean
    alternativePrice?: boolean
    alternativeType?: boolean
    alternativeNotes?: boolean
    selectedAlternative?: boolean
    createdAt?: boolean
    quote?: boolean | QuoteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["quotePartItem"]>

  export type QuotePartItemSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    quoteId?: boolean
    name?: boolean
    quantity?: boolean
    unitPrice?: boolean
    partType?: boolean
    notes?: boolean
    alternativeName?: boolean
    alternativePrice?: boolean
    alternativeType?: boolean
    alternativeNotes?: boolean
    selectedAlternative?: boolean
    createdAt?: boolean
    quote?: boolean | QuoteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["quotePartItem"]>

  export type QuotePartItemSelectScalar = {
    id?: boolean
    quoteId?: boolean
    name?: boolean
    quantity?: boolean
    unitPrice?: boolean
    partType?: boolean
    notes?: boolean
    alternativeName?: boolean
    alternativePrice?: boolean
    alternativeType?: boolean
    alternativeNotes?: boolean
    selectedAlternative?: boolean
    createdAt?: boolean
  }

  export type QuotePartItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "quoteId" | "name" | "quantity" | "unitPrice" | "partType" | "notes" | "alternativeName" | "alternativePrice" | "alternativeType" | "alternativeNotes" | "selectedAlternative" | "createdAt", ExtArgs["result"]["quotePartItem"]>
  export type QuotePartItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    quote?: boolean | QuoteDefaultArgs<ExtArgs>
  }
  export type QuotePartItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    quote?: boolean | QuoteDefaultArgs<ExtArgs>
  }
  export type QuotePartItemIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    quote?: boolean | QuoteDefaultArgs<ExtArgs>
  }

  export type $QuotePartItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "QuotePartItem"
    objects: {
      quote: Prisma.$QuotePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      quoteId: string
      name: string
      quantity: number
      unitPrice: number
      partType: $Enums.PartType
      notes: string | null
      alternativeName: string | null
      alternativePrice: number | null
      alternativeType: $Enums.PartType | null
      alternativeNotes: string | null
      selectedAlternative: boolean
      createdAt: Date
    }, ExtArgs["result"]["quotePartItem"]>
    composites: {}
  }

  type QuotePartItemGetPayload<S extends boolean | null | undefined | QuotePartItemDefaultArgs> = $Result.GetResult<Prisma.$QuotePartItemPayload, S>

  type QuotePartItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<QuotePartItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: QuotePartItemCountAggregateInputType | true
    }

  export interface QuotePartItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['QuotePartItem'], meta: { name: 'QuotePartItem' } }
    /**
     * Find zero or one QuotePartItem that matches the filter.
     * @param {QuotePartItemFindUniqueArgs} args - Arguments to find a QuotePartItem
     * @example
     * // Get one QuotePartItem
     * const quotePartItem = await prisma.quotePartItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends QuotePartItemFindUniqueArgs>(args: SelectSubset<T, QuotePartItemFindUniqueArgs<ExtArgs>>): Prisma__QuotePartItemClient<$Result.GetResult<Prisma.$QuotePartItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one QuotePartItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {QuotePartItemFindUniqueOrThrowArgs} args - Arguments to find a QuotePartItem
     * @example
     * // Get one QuotePartItem
     * const quotePartItem = await prisma.quotePartItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends QuotePartItemFindUniqueOrThrowArgs>(args: SelectSubset<T, QuotePartItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__QuotePartItemClient<$Result.GetResult<Prisma.$QuotePartItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first QuotePartItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuotePartItemFindFirstArgs} args - Arguments to find a QuotePartItem
     * @example
     * // Get one QuotePartItem
     * const quotePartItem = await prisma.quotePartItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends QuotePartItemFindFirstArgs>(args?: SelectSubset<T, QuotePartItemFindFirstArgs<ExtArgs>>): Prisma__QuotePartItemClient<$Result.GetResult<Prisma.$QuotePartItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first QuotePartItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuotePartItemFindFirstOrThrowArgs} args - Arguments to find a QuotePartItem
     * @example
     * // Get one QuotePartItem
     * const quotePartItem = await prisma.quotePartItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends QuotePartItemFindFirstOrThrowArgs>(args?: SelectSubset<T, QuotePartItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__QuotePartItemClient<$Result.GetResult<Prisma.$QuotePartItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more QuotePartItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuotePartItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all QuotePartItems
     * const quotePartItems = await prisma.quotePartItem.findMany()
     * 
     * // Get first 10 QuotePartItems
     * const quotePartItems = await prisma.quotePartItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const quotePartItemWithIdOnly = await prisma.quotePartItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends QuotePartItemFindManyArgs>(args?: SelectSubset<T, QuotePartItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuotePartItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a QuotePartItem.
     * @param {QuotePartItemCreateArgs} args - Arguments to create a QuotePartItem.
     * @example
     * // Create one QuotePartItem
     * const QuotePartItem = await prisma.quotePartItem.create({
     *   data: {
     *     // ... data to create a QuotePartItem
     *   }
     * })
     * 
     */
    create<T extends QuotePartItemCreateArgs>(args: SelectSubset<T, QuotePartItemCreateArgs<ExtArgs>>): Prisma__QuotePartItemClient<$Result.GetResult<Prisma.$QuotePartItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many QuotePartItems.
     * @param {QuotePartItemCreateManyArgs} args - Arguments to create many QuotePartItems.
     * @example
     * // Create many QuotePartItems
     * const quotePartItem = await prisma.quotePartItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends QuotePartItemCreateManyArgs>(args?: SelectSubset<T, QuotePartItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many QuotePartItems and returns the data saved in the database.
     * @param {QuotePartItemCreateManyAndReturnArgs} args - Arguments to create many QuotePartItems.
     * @example
     * // Create many QuotePartItems
     * const quotePartItem = await prisma.quotePartItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many QuotePartItems and only return the `id`
     * const quotePartItemWithIdOnly = await prisma.quotePartItem.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends QuotePartItemCreateManyAndReturnArgs>(args?: SelectSubset<T, QuotePartItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuotePartItemPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a QuotePartItem.
     * @param {QuotePartItemDeleteArgs} args - Arguments to delete one QuotePartItem.
     * @example
     * // Delete one QuotePartItem
     * const QuotePartItem = await prisma.quotePartItem.delete({
     *   where: {
     *     // ... filter to delete one QuotePartItem
     *   }
     * })
     * 
     */
    delete<T extends QuotePartItemDeleteArgs>(args: SelectSubset<T, QuotePartItemDeleteArgs<ExtArgs>>): Prisma__QuotePartItemClient<$Result.GetResult<Prisma.$QuotePartItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one QuotePartItem.
     * @param {QuotePartItemUpdateArgs} args - Arguments to update one QuotePartItem.
     * @example
     * // Update one QuotePartItem
     * const quotePartItem = await prisma.quotePartItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends QuotePartItemUpdateArgs>(args: SelectSubset<T, QuotePartItemUpdateArgs<ExtArgs>>): Prisma__QuotePartItemClient<$Result.GetResult<Prisma.$QuotePartItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more QuotePartItems.
     * @param {QuotePartItemDeleteManyArgs} args - Arguments to filter QuotePartItems to delete.
     * @example
     * // Delete a few QuotePartItems
     * const { count } = await prisma.quotePartItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends QuotePartItemDeleteManyArgs>(args?: SelectSubset<T, QuotePartItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QuotePartItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuotePartItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many QuotePartItems
     * const quotePartItem = await prisma.quotePartItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends QuotePartItemUpdateManyArgs>(args: SelectSubset<T, QuotePartItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QuotePartItems and returns the data updated in the database.
     * @param {QuotePartItemUpdateManyAndReturnArgs} args - Arguments to update many QuotePartItems.
     * @example
     * // Update many QuotePartItems
     * const quotePartItem = await prisma.quotePartItem.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more QuotePartItems and only return the `id`
     * const quotePartItemWithIdOnly = await prisma.quotePartItem.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends QuotePartItemUpdateManyAndReturnArgs>(args: SelectSubset<T, QuotePartItemUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuotePartItemPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one QuotePartItem.
     * @param {QuotePartItemUpsertArgs} args - Arguments to update or create a QuotePartItem.
     * @example
     * // Update or create a QuotePartItem
     * const quotePartItem = await prisma.quotePartItem.upsert({
     *   create: {
     *     // ... data to create a QuotePartItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the QuotePartItem we want to update
     *   }
     * })
     */
    upsert<T extends QuotePartItemUpsertArgs>(args: SelectSubset<T, QuotePartItemUpsertArgs<ExtArgs>>): Prisma__QuotePartItemClient<$Result.GetResult<Prisma.$QuotePartItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of QuotePartItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuotePartItemCountArgs} args - Arguments to filter QuotePartItems to count.
     * @example
     * // Count the number of QuotePartItems
     * const count = await prisma.quotePartItem.count({
     *   where: {
     *     // ... the filter for the QuotePartItems we want to count
     *   }
     * })
    **/
    count<T extends QuotePartItemCountArgs>(
      args?: Subset<T, QuotePartItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QuotePartItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a QuotePartItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuotePartItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QuotePartItemAggregateArgs>(args: Subset<T, QuotePartItemAggregateArgs>): Prisma.PrismaPromise<GetQuotePartItemAggregateType<T>>

    /**
     * Group by QuotePartItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuotePartItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QuotePartItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QuotePartItemGroupByArgs['orderBy'] }
        : { orderBy?: QuotePartItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QuotePartItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQuotePartItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the QuotePartItem model
   */
  readonly fields: QuotePartItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for QuotePartItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__QuotePartItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    quote<T extends QuoteDefaultArgs<ExtArgs> = {}>(args?: Subset<T, QuoteDefaultArgs<ExtArgs>>): Prisma__QuoteClient<$Result.GetResult<Prisma.$QuotePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the QuotePartItem model
   */
  interface QuotePartItemFieldRefs {
    readonly id: FieldRef<"QuotePartItem", 'String'>
    readonly quoteId: FieldRef<"QuotePartItem", 'String'>
    readonly name: FieldRef<"QuotePartItem", 'String'>
    readonly quantity: FieldRef<"QuotePartItem", 'Int'>
    readonly unitPrice: FieldRef<"QuotePartItem", 'Float'>
    readonly partType: FieldRef<"QuotePartItem", 'PartType'>
    readonly notes: FieldRef<"QuotePartItem", 'String'>
    readonly alternativeName: FieldRef<"QuotePartItem", 'String'>
    readonly alternativePrice: FieldRef<"QuotePartItem", 'Float'>
    readonly alternativeType: FieldRef<"QuotePartItem", 'PartType'>
    readonly alternativeNotes: FieldRef<"QuotePartItem", 'String'>
    readonly selectedAlternative: FieldRef<"QuotePartItem", 'Boolean'>
    readonly createdAt: FieldRef<"QuotePartItem", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * QuotePartItem findUnique
   */
  export type QuotePartItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuotePartItem
     */
    select?: QuotePartItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuotePartItem
     */
    omit?: QuotePartItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuotePartItemInclude<ExtArgs> | null
    /**
     * Filter, which QuotePartItem to fetch.
     */
    where: QuotePartItemWhereUniqueInput
  }

  /**
   * QuotePartItem findUniqueOrThrow
   */
  export type QuotePartItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuotePartItem
     */
    select?: QuotePartItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuotePartItem
     */
    omit?: QuotePartItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuotePartItemInclude<ExtArgs> | null
    /**
     * Filter, which QuotePartItem to fetch.
     */
    where: QuotePartItemWhereUniqueInput
  }

  /**
   * QuotePartItem findFirst
   */
  export type QuotePartItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuotePartItem
     */
    select?: QuotePartItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuotePartItem
     */
    omit?: QuotePartItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuotePartItemInclude<ExtArgs> | null
    /**
     * Filter, which QuotePartItem to fetch.
     */
    where?: QuotePartItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuotePartItems to fetch.
     */
    orderBy?: QuotePartItemOrderByWithRelationInput | QuotePartItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuotePartItems.
     */
    cursor?: QuotePartItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuotePartItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuotePartItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuotePartItems.
     */
    distinct?: QuotePartItemScalarFieldEnum | QuotePartItemScalarFieldEnum[]
  }

  /**
   * QuotePartItem findFirstOrThrow
   */
  export type QuotePartItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuotePartItem
     */
    select?: QuotePartItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuotePartItem
     */
    omit?: QuotePartItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuotePartItemInclude<ExtArgs> | null
    /**
     * Filter, which QuotePartItem to fetch.
     */
    where?: QuotePartItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuotePartItems to fetch.
     */
    orderBy?: QuotePartItemOrderByWithRelationInput | QuotePartItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuotePartItems.
     */
    cursor?: QuotePartItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuotePartItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuotePartItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuotePartItems.
     */
    distinct?: QuotePartItemScalarFieldEnum | QuotePartItemScalarFieldEnum[]
  }

  /**
   * QuotePartItem findMany
   */
  export type QuotePartItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuotePartItem
     */
    select?: QuotePartItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuotePartItem
     */
    omit?: QuotePartItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuotePartItemInclude<ExtArgs> | null
    /**
     * Filter, which QuotePartItems to fetch.
     */
    where?: QuotePartItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuotePartItems to fetch.
     */
    orderBy?: QuotePartItemOrderByWithRelationInput | QuotePartItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing QuotePartItems.
     */
    cursor?: QuotePartItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuotePartItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuotePartItems.
     */
    skip?: number
    distinct?: QuotePartItemScalarFieldEnum | QuotePartItemScalarFieldEnum[]
  }

  /**
   * QuotePartItem create
   */
  export type QuotePartItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuotePartItem
     */
    select?: QuotePartItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuotePartItem
     */
    omit?: QuotePartItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuotePartItemInclude<ExtArgs> | null
    /**
     * The data needed to create a QuotePartItem.
     */
    data: XOR<QuotePartItemCreateInput, QuotePartItemUncheckedCreateInput>
  }

  /**
   * QuotePartItem createMany
   */
  export type QuotePartItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many QuotePartItems.
     */
    data: QuotePartItemCreateManyInput | QuotePartItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * QuotePartItem createManyAndReturn
   */
  export type QuotePartItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuotePartItem
     */
    select?: QuotePartItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the QuotePartItem
     */
    omit?: QuotePartItemOmit<ExtArgs> | null
    /**
     * The data used to create many QuotePartItems.
     */
    data: QuotePartItemCreateManyInput | QuotePartItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuotePartItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * QuotePartItem update
   */
  export type QuotePartItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuotePartItem
     */
    select?: QuotePartItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuotePartItem
     */
    omit?: QuotePartItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuotePartItemInclude<ExtArgs> | null
    /**
     * The data needed to update a QuotePartItem.
     */
    data: XOR<QuotePartItemUpdateInput, QuotePartItemUncheckedUpdateInput>
    /**
     * Choose, which QuotePartItem to update.
     */
    where: QuotePartItemWhereUniqueInput
  }

  /**
   * QuotePartItem updateMany
   */
  export type QuotePartItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update QuotePartItems.
     */
    data: XOR<QuotePartItemUpdateManyMutationInput, QuotePartItemUncheckedUpdateManyInput>
    /**
     * Filter which QuotePartItems to update
     */
    where?: QuotePartItemWhereInput
    /**
     * Limit how many QuotePartItems to update.
     */
    limit?: number
  }

  /**
   * QuotePartItem updateManyAndReturn
   */
  export type QuotePartItemUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuotePartItem
     */
    select?: QuotePartItemSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the QuotePartItem
     */
    omit?: QuotePartItemOmit<ExtArgs> | null
    /**
     * The data used to update QuotePartItems.
     */
    data: XOR<QuotePartItemUpdateManyMutationInput, QuotePartItemUncheckedUpdateManyInput>
    /**
     * Filter which QuotePartItems to update
     */
    where?: QuotePartItemWhereInput
    /**
     * Limit how many QuotePartItems to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuotePartItemIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * QuotePartItem upsert
   */
  export type QuotePartItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuotePartItem
     */
    select?: QuotePartItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuotePartItem
     */
    omit?: QuotePartItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuotePartItemInclude<ExtArgs> | null
    /**
     * The filter to search for the QuotePartItem to update in case it exists.
     */
    where: QuotePartItemWhereUniqueInput
    /**
     * In case the QuotePartItem found by the `where` argument doesn't exist, create a new QuotePartItem with this data.
     */
    create: XOR<QuotePartItemCreateInput, QuotePartItemUncheckedCreateInput>
    /**
     * In case the QuotePartItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<QuotePartItemUpdateInput, QuotePartItemUncheckedUpdateInput>
  }

  /**
   * QuotePartItem delete
   */
  export type QuotePartItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuotePartItem
     */
    select?: QuotePartItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuotePartItem
     */
    omit?: QuotePartItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuotePartItemInclude<ExtArgs> | null
    /**
     * Filter which QuotePartItem to delete.
     */
    where: QuotePartItemWhereUniqueInput
  }

  /**
   * QuotePartItem deleteMany
   */
  export type QuotePartItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QuotePartItems to delete
     */
    where?: QuotePartItemWhereInput
    /**
     * Limit how many QuotePartItems to delete.
     */
    limit?: number
  }

  /**
   * QuotePartItem without action
   */
  export type QuotePartItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuotePartItem
     */
    select?: QuotePartItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuotePartItem
     */
    omit?: QuotePartItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuotePartItemInclude<ExtArgs> | null
  }


  /**
   * Model WorkOrder
   */

  export type AggregateWorkOrder = {
    _count: WorkOrderCountAggregateOutputType | null
    _avg: WorkOrderAvgAggregateOutputType | null
    _sum: WorkOrderSumAggregateOutputType | null
    _min: WorkOrderMinAggregateOutputType | null
    _max: WorkOrderMaxAggregateOutputType | null
  }

  export type WorkOrderAvgAggregateOutputType = {
    totalAgreed: number | null
    totalFinal: number | null
  }

  export type WorkOrderSumAggregateOutputType = {
    totalAgreed: number | null
    totalFinal: number | null
  }

  export type WorkOrderMinAggregateOutputType = {
    id: string | null
    orderNumber: string | null
    requestId: string | null
    quoteId: string | null
    workshopId: string | null
    diagnosis: string | null
    totalAgreed: number | null
    totalFinal: number | null
    status: $Enums.WorkOrderStatus | null
    userAcceptedAt: Date | null
    workshopAcceptedAt: Date | null
    startedAt: Date | null
    startNote: string | null
    completedAt: Date | null
    closedAt: Date | null
    closureChecklist: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WorkOrderMaxAggregateOutputType = {
    id: string | null
    orderNumber: string | null
    requestId: string | null
    quoteId: string | null
    workshopId: string | null
    diagnosis: string | null
    totalAgreed: number | null
    totalFinal: number | null
    status: $Enums.WorkOrderStatus | null
    userAcceptedAt: Date | null
    workshopAcceptedAt: Date | null
    startedAt: Date | null
    startNote: string | null
    completedAt: Date | null
    closedAt: Date | null
    closureChecklist: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WorkOrderCountAggregateOutputType = {
    id: number
    orderNumber: number
    requestId: number
    quoteId: number
    workshopId: number
    diagnosis: number
    totalAgreed: number
    totalFinal: number
    status: number
    userAcceptedAt: number
    workshopAcceptedAt: number
    startedAt: number
    startNote: number
    completedAt: number
    closedAt: number
    closureChecklist: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type WorkOrderAvgAggregateInputType = {
    totalAgreed?: true
    totalFinal?: true
  }

  export type WorkOrderSumAggregateInputType = {
    totalAgreed?: true
    totalFinal?: true
  }

  export type WorkOrderMinAggregateInputType = {
    id?: true
    orderNumber?: true
    requestId?: true
    quoteId?: true
    workshopId?: true
    diagnosis?: true
    totalAgreed?: true
    totalFinal?: true
    status?: true
    userAcceptedAt?: true
    workshopAcceptedAt?: true
    startedAt?: true
    startNote?: true
    completedAt?: true
    closedAt?: true
    closureChecklist?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WorkOrderMaxAggregateInputType = {
    id?: true
    orderNumber?: true
    requestId?: true
    quoteId?: true
    workshopId?: true
    diagnosis?: true
    totalAgreed?: true
    totalFinal?: true
    status?: true
    userAcceptedAt?: true
    workshopAcceptedAt?: true
    startedAt?: true
    startNote?: true
    completedAt?: true
    closedAt?: true
    closureChecklist?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WorkOrderCountAggregateInputType = {
    id?: true
    orderNumber?: true
    requestId?: true
    quoteId?: true
    workshopId?: true
    diagnosis?: true
    totalAgreed?: true
    totalFinal?: true
    status?: true
    userAcceptedAt?: true
    workshopAcceptedAt?: true
    startedAt?: true
    startNote?: true
    completedAt?: true
    closedAt?: true
    closureChecklist?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type WorkOrderAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WorkOrder to aggregate.
     */
    where?: WorkOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkOrders to fetch.
     */
    orderBy?: WorkOrderOrderByWithRelationInput | WorkOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WorkOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkOrders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WorkOrders
    **/
    _count?: true | WorkOrderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WorkOrderAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WorkOrderSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WorkOrderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WorkOrderMaxAggregateInputType
  }

  export type GetWorkOrderAggregateType<T extends WorkOrderAggregateArgs> = {
        [P in keyof T & keyof AggregateWorkOrder]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWorkOrder[P]>
      : GetScalarType<T[P], AggregateWorkOrder[P]>
  }




  export type WorkOrderGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkOrderWhereInput
    orderBy?: WorkOrderOrderByWithAggregationInput | WorkOrderOrderByWithAggregationInput[]
    by: WorkOrderScalarFieldEnum[] | WorkOrderScalarFieldEnum
    having?: WorkOrderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WorkOrderCountAggregateInputType | true
    _avg?: WorkOrderAvgAggregateInputType
    _sum?: WorkOrderSumAggregateInputType
    _min?: WorkOrderMinAggregateInputType
    _max?: WorkOrderMaxAggregateInputType
  }

  export type WorkOrderGroupByOutputType = {
    id: string
    orderNumber: string
    requestId: string
    quoteId: string
    workshopId: string
    diagnosis: string
    totalAgreed: number
    totalFinal: number | null
    status: $Enums.WorkOrderStatus
    userAcceptedAt: Date | null
    workshopAcceptedAt: Date | null
    startedAt: Date | null
    startNote: string | null
    completedAt: Date | null
    closedAt: Date | null
    closureChecklist: string | null
    createdAt: Date
    updatedAt: Date
    _count: WorkOrderCountAggregateOutputType | null
    _avg: WorkOrderAvgAggregateOutputType | null
    _sum: WorkOrderSumAggregateOutputType | null
    _min: WorkOrderMinAggregateOutputType | null
    _max: WorkOrderMaxAggregateOutputType | null
  }

  type GetWorkOrderGroupByPayload<T extends WorkOrderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WorkOrderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WorkOrderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WorkOrderGroupByOutputType[P]>
            : GetScalarType<T[P], WorkOrderGroupByOutputType[P]>
        }
      >
    >


  export type WorkOrderSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderNumber?: boolean
    requestId?: boolean
    quoteId?: boolean
    workshopId?: boolean
    diagnosis?: boolean
    totalAgreed?: boolean
    totalFinal?: boolean
    status?: boolean
    userAcceptedAt?: boolean
    workshopAcceptedAt?: boolean
    startedAt?: boolean
    startNote?: boolean
    completedAt?: boolean
    closedAt?: boolean
    closureChecklist?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    request?: boolean | ServiceRequestDefaultArgs<ExtArgs>
    quote?: boolean | QuoteDefaultArgs<ExtArgs>
    workshop?: boolean | WorkshopDefaultArgs<ExtArgs>
    changeRequests?: boolean | WorkOrder$changeRequestsArgs<ExtArgs>
    evidences?: boolean | WorkOrder$evidencesArgs<ExtArgs>
    review?: boolean | WorkOrder$reviewArgs<ExtArgs>
    receipt?: boolean | WorkOrder$receiptArgs<ExtArgs>
    _count?: boolean | WorkOrderCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workOrder"]>

  export type WorkOrderSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderNumber?: boolean
    requestId?: boolean
    quoteId?: boolean
    workshopId?: boolean
    diagnosis?: boolean
    totalAgreed?: boolean
    totalFinal?: boolean
    status?: boolean
    userAcceptedAt?: boolean
    workshopAcceptedAt?: boolean
    startedAt?: boolean
    startNote?: boolean
    completedAt?: boolean
    closedAt?: boolean
    closureChecklist?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    request?: boolean | ServiceRequestDefaultArgs<ExtArgs>
    quote?: boolean | QuoteDefaultArgs<ExtArgs>
    workshop?: boolean | WorkshopDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workOrder"]>

  export type WorkOrderSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderNumber?: boolean
    requestId?: boolean
    quoteId?: boolean
    workshopId?: boolean
    diagnosis?: boolean
    totalAgreed?: boolean
    totalFinal?: boolean
    status?: boolean
    userAcceptedAt?: boolean
    workshopAcceptedAt?: boolean
    startedAt?: boolean
    startNote?: boolean
    completedAt?: boolean
    closedAt?: boolean
    closureChecklist?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    request?: boolean | ServiceRequestDefaultArgs<ExtArgs>
    quote?: boolean | QuoteDefaultArgs<ExtArgs>
    workshop?: boolean | WorkshopDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workOrder"]>

  export type WorkOrderSelectScalar = {
    id?: boolean
    orderNumber?: boolean
    requestId?: boolean
    quoteId?: boolean
    workshopId?: boolean
    diagnosis?: boolean
    totalAgreed?: boolean
    totalFinal?: boolean
    status?: boolean
    userAcceptedAt?: boolean
    workshopAcceptedAt?: boolean
    startedAt?: boolean
    startNote?: boolean
    completedAt?: boolean
    closedAt?: boolean
    closureChecklist?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type WorkOrderOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "orderNumber" | "requestId" | "quoteId" | "workshopId" | "diagnosis" | "totalAgreed" | "totalFinal" | "status" | "userAcceptedAt" | "workshopAcceptedAt" | "startedAt" | "startNote" | "completedAt" | "closedAt" | "closureChecklist" | "createdAt" | "updatedAt", ExtArgs["result"]["workOrder"]>
  export type WorkOrderInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    request?: boolean | ServiceRequestDefaultArgs<ExtArgs>
    quote?: boolean | QuoteDefaultArgs<ExtArgs>
    workshop?: boolean | WorkshopDefaultArgs<ExtArgs>
    changeRequests?: boolean | WorkOrder$changeRequestsArgs<ExtArgs>
    evidences?: boolean | WorkOrder$evidencesArgs<ExtArgs>
    review?: boolean | WorkOrder$reviewArgs<ExtArgs>
    receipt?: boolean | WorkOrder$receiptArgs<ExtArgs>
    _count?: boolean | WorkOrderCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type WorkOrderIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    request?: boolean | ServiceRequestDefaultArgs<ExtArgs>
    quote?: boolean | QuoteDefaultArgs<ExtArgs>
    workshop?: boolean | WorkshopDefaultArgs<ExtArgs>
  }
  export type WorkOrderIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    request?: boolean | ServiceRequestDefaultArgs<ExtArgs>
    quote?: boolean | QuoteDefaultArgs<ExtArgs>
    workshop?: boolean | WorkshopDefaultArgs<ExtArgs>
  }

  export type $WorkOrderPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WorkOrder"
    objects: {
      request: Prisma.$ServiceRequestPayload<ExtArgs>
      quote: Prisma.$QuotePayload<ExtArgs>
      workshop: Prisma.$WorkshopPayload<ExtArgs>
      changeRequests: Prisma.$ChangeRequestPayload<ExtArgs>[]
      evidences: Prisma.$EvidencePayload<ExtArgs>[]
      review: Prisma.$ReviewPayload<ExtArgs> | null
      receipt: Prisma.$ReceiptPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      orderNumber: string
      requestId: string
      quoteId: string
      workshopId: string
      diagnosis: string
      totalAgreed: number
      totalFinal: number | null
      status: $Enums.WorkOrderStatus
      userAcceptedAt: Date | null
      workshopAcceptedAt: Date | null
      startedAt: Date | null
      startNote: string | null
      completedAt: Date | null
      closedAt: Date | null
      closureChecklist: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["workOrder"]>
    composites: {}
  }

  type WorkOrderGetPayload<S extends boolean | null | undefined | WorkOrderDefaultArgs> = $Result.GetResult<Prisma.$WorkOrderPayload, S>

  type WorkOrderCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WorkOrderFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WorkOrderCountAggregateInputType | true
    }

  export interface WorkOrderDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WorkOrder'], meta: { name: 'WorkOrder' } }
    /**
     * Find zero or one WorkOrder that matches the filter.
     * @param {WorkOrderFindUniqueArgs} args - Arguments to find a WorkOrder
     * @example
     * // Get one WorkOrder
     * const workOrder = await prisma.workOrder.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WorkOrderFindUniqueArgs>(args: SelectSubset<T, WorkOrderFindUniqueArgs<ExtArgs>>): Prisma__WorkOrderClient<$Result.GetResult<Prisma.$WorkOrderPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one WorkOrder that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WorkOrderFindUniqueOrThrowArgs} args - Arguments to find a WorkOrder
     * @example
     * // Get one WorkOrder
     * const workOrder = await prisma.workOrder.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WorkOrderFindUniqueOrThrowArgs>(args: SelectSubset<T, WorkOrderFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WorkOrderClient<$Result.GetResult<Prisma.$WorkOrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WorkOrder that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkOrderFindFirstArgs} args - Arguments to find a WorkOrder
     * @example
     * // Get one WorkOrder
     * const workOrder = await prisma.workOrder.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WorkOrderFindFirstArgs>(args?: SelectSubset<T, WorkOrderFindFirstArgs<ExtArgs>>): Prisma__WorkOrderClient<$Result.GetResult<Prisma.$WorkOrderPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WorkOrder that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkOrderFindFirstOrThrowArgs} args - Arguments to find a WorkOrder
     * @example
     * // Get one WorkOrder
     * const workOrder = await prisma.workOrder.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WorkOrderFindFirstOrThrowArgs>(args?: SelectSubset<T, WorkOrderFindFirstOrThrowArgs<ExtArgs>>): Prisma__WorkOrderClient<$Result.GetResult<Prisma.$WorkOrderPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more WorkOrders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkOrderFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WorkOrders
     * const workOrders = await prisma.workOrder.findMany()
     * 
     * // Get first 10 WorkOrders
     * const workOrders = await prisma.workOrder.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const workOrderWithIdOnly = await prisma.workOrder.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WorkOrderFindManyArgs>(args?: SelectSubset<T, WorkOrderFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkOrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a WorkOrder.
     * @param {WorkOrderCreateArgs} args - Arguments to create a WorkOrder.
     * @example
     * // Create one WorkOrder
     * const WorkOrder = await prisma.workOrder.create({
     *   data: {
     *     // ... data to create a WorkOrder
     *   }
     * })
     * 
     */
    create<T extends WorkOrderCreateArgs>(args: SelectSubset<T, WorkOrderCreateArgs<ExtArgs>>): Prisma__WorkOrderClient<$Result.GetResult<Prisma.$WorkOrderPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many WorkOrders.
     * @param {WorkOrderCreateManyArgs} args - Arguments to create many WorkOrders.
     * @example
     * // Create many WorkOrders
     * const workOrder = await prisma.workOrder.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WorkOrderCreateManyArgs>(args?: SelectSubset<T, WorkOrderCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WorkOrders and returns the data saved in the database.
     * @param {WorkOrderCreateManyAndReturnArgs} args - Arguments to create many WorkOrders.
     * @example
     * // Create many WorkOrders
     * const workOrder = await prisma.workOrder.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WorkOrders and only return the `id`
     * const workOrderWithIdOnly = await prisma.workOrder.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WorkOrderCreateManyAndReturnArgs>(args?: SelectSubset<T, WorkOrderCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkOrderPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a WorkOrder.
     * @param {WorkOrderDeleteArgs} args - Arguments to delete one WorkOrder.
     * @example
     * // Delete one WorkOrder
     * const WorkOrder = await prisma.workOrder.delete({
     *   where: {
     *     // ... filter to delete one WorkOrder
     *   }
     * })
     * 
     */
    delete<T extends WorkOrderDeleteArgs>(args: SelectSubset<T, WorkOrderDeleteArgs<ExtArgs>>): Prisma__WorkOrderClient<$Result.GetResult<Prisma.$WorkOrderPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one WorkOrder.
     * @param {WorkOrderUpdateArgs} args - Arguments to update one WorkOrder.
     * @example
     * // Update one WorkOrder
     * const workOrder = await prisma.workOrder.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WorkOrderUpdateArgs>(args: SelectSubset<T, WorkOrderUpdateArgs<ExtArgs>>): Prisma__WorkOrderClient<$Result.GetResult<Prisma.$WorkOrderPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more WorkOrders.
     * @param {WorkOrderDeleteManyArgs} args - Arguments to filter WorkOrders to delete.
     * @example
     * // Delete a few WorkOrders
     * const { count } = await prisma.workOrder.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WorkOrderDeleteManyArgs>(args?: SelectSubset<T, WorkOrderDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WorkOrders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkOrderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WorkOrders
     * const workOrder = await prisma.workOrder.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WorkOrderUpdateManyArgs>(args: SelectSubset<T, WorkOrderUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WorkOrders and returns the data updated in the database.
     * @param {WorkOrderUpdateManyAndReturnArgs} args - Arguments to update many WorkOrders.
     * @example
     * // Update many WorkOrders
     * const workOrder = await prisma.workOrder.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more WorkOrders and only return the `id`
     * const workOrderWithIdOnly = await prisma.workOrder.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends WorkOrderUpdateManyAndReturnArgs>(args: SelectSubset<T, WorkOrderUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkOrderPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one WorkOrder.
     * @param {WorkOrderUpsertArgs} args - Arguments to update or create a WorkOrder.
     * @example
     * // Update or create a WorkOrder
     * const workOrder = await prisma.workOrder.upsert({
     *   create: {
     *     // ... data to create a WorkOrder
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WorkOrder we want to update
     *   }
     * })
     */
    upsert<T extends WorkOrderUpsertArgs>(args: SelectSubset<T, WorkOrderUpsertArgs<ExtArgs>>): Prisma__WorkOrderClient<$Result.GetResult<Prisma.$WorkOrderPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of WorkOrders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkOrderCountArgs} args - Arguments to filter WorkOrders to count.
     * @example
     * // Count the number of WorkOrders
     * const count = await prisma.workOrder.count({
     *   where: {
     *     // ... the filter for the WorkOrders we want to count
     *   }
     * })
    **/
    count<T extends WorkOrderCountArgs>(
      args?: Subset<T, WorkOrderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WorkOrderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WorkOrder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkOrderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WorkOrderAggregateArgs>(args: Subset<T, WorkOrderAggregateArgs>): Prisma.PrismaPromise<GetWorkOrderAggregateType<T>>

    /**
     * Group by WorkOrder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkOrderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WorkOrderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WorkOrderGroupByArgs['orderBy'] }
        : { orderBy?: WorkOrderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WorkOrderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWorkOrderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WorkOrder model
   */
  readonly fields: WorkOrderFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WorkOrder.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WorkOrderClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    request<T extends ServiceRequestDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ServiceRequestDefaultArgs<ExtArgs>>): Prisma__ServiceRequestClient<$Result.GetResult<Prisma.$ServiceRequestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    quote<T extends QuoteDefaultArgs<ExtArgs> = {}>(args?: Subset<T, QuoteDefaultArgs<ExtArgs>>): Prisma__QuoteClient<$Result.GetResult<Prisma.$QuotePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    workshop<T extends WorkshopDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WorkshopDefaultArgs<ExtArgs>>): Prisma__WorkshopClient<$Result.GetResult<Prisma.$WorkshopPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    changeRequests<T extends WorkOrder$changeRequestsArgs<ExtArgs> = {}>(args?: Subset<T, WorkOrder$changeRequestsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChangeRequestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    evidences<T extends WorkOrder$evidencesArgs<ExtArgs> = {}>(args?: Subset<T, WorkOrder$evidencesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EvidencePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    review<T extends WorkOrder$reviewArgs<ExtArgs> = {}>(args?: Subset<T, WorkOrder$reviewArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    receipt<T extends WorkOrder$receiptArgs<ExtArgs> = {}>(args?: Subset<T, WorkOrder$receiptArgs<ExtArgs>>): Prisma__ReceiptClient<$Result.GetResult<Prisma.$ReceiptPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WorkOrder model
   */
  interface WorkOrderFieldRefs {
    readonly id: FieldRef<"WorkOrder", 'String'>
    readonly orderNumber: FieldRef<"WorkOrder", 'String'>
    readonly requestId: FieldRef<"WorkOrder", 'String'>
    readonly quoteId: FieldRef<"WorkOrder", 'String'>
    readonly workshopId: FieldRef<"WorkOrder", 'String'>
    readonly diagnosis: FieldRef<"WorkOrder", 'String'>
    readonly totalAgreed: FieldRef<"WorkOrder", 'Float'>
    readonly totalFinal: FieldRef<"WorkOrder", 'Float'>
    readonly status: FieldRef<"WorkOrder", 'WorkOrderStatus'>
    readonly userAcceptedAt: FieldRef<"WorkOrder", 'DateTime'>
    readonly workshopAcceptedAt: FieldRef<"WorkOrder", 'DateTime'>
    readonly startedAt: FieldRef<"WorkOrder", 'DateTime'>
    readonly startNote: FieldRef<"WorkOrder", 'String'>
    readonly completedAt: FieldRef<"WorkOrder", 'DateTime'>
    readonly closedAt: FieldRef<"WorkOrder", 'DateTime'>
    readonly closureChecklist: FieldRef<"WorkOrder", 'String'>
    readonly createdAt: FieldRef<"WorkOrder", 'DateTime'>
    readonly updatedAt: FieldRef<"WorkOrder", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * WorkOrder findUnique
   */
  export type WorkOrderFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkOrder
     */
    select?: WorkOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkOrder
     */
    omit?: WorkOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkOrderInclude<ExtArgs> | null
    /**
     * Filter, which WorkOrder to fetch.
     */
    where: WorkOrderWhereUniqueInput
  }

  /**
   * WorkOrder findUniqueOrThrow
   */
  export type WorkOrderFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkOrder
     */
    select?: WorkOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkOrder
     */
    omit?: WorkOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkOrderInclude<ExtArgs> | null
    /**
     * Filter, which WorkOrder to fetch.
     */
    where: WorkOrderWhereUniqueInput
  }

  /**
   * WorkOrder findFirst
   */
  export type WorkOrderFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkOrder
     */
    select?: WorkOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkOrder
     */
    omit?: WorkOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkOrderInclude<ExtArgs> | null
    /**
     * Filter, which WorkOrder to fetch.
     */
    where?: WorkOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkOrders to fetch.
     */
    orderBy?: WorkOrderOrderByWithRelationInput | WorkOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorkOrders.
     */
    cursor?: WorkOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkOrders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorkOrders.
     */
    distinct?: WorkOrderScalarFieldEnum | WorkOrderScalarFieldEnum[]
  }

  /**
   * WorkOrder findFirstOrThrow
   */
  export type WorkOrderFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkOrder
     */
    select?: WorkOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkOrder
     */
    omit?: WorkOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkOrderInclude<ExtArgs> | null
    /**
     * Filter, which WorkOrder to fetch.
     */
    where?: WorkOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkOrders to fetch.
     */
    orderBy?: WorkOrderOrderByWithRelationInput | WorkOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorkOrders.
     */
    cursor?: WorkOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkOrders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorkOrders.
     */
    distinct?: WorkOrderScalarFieldEnum | WorkOrderScalarFieldEnum[]
  }

  /**
   * WorkOrder findMany
   */
  export type WorkOrderFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkOrder
     */
    select?: WorkOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkOrder
     */
    omit?: WorkOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkOrderInclude<ExtArgs> | null
    /**
     * Filter, which WorkOrders to fetch.
     */
    where?: WorkOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkOrders to fetch.
     */
    orderBy?: WorkOrderOrderByWithRelationInput | WorkOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WorkOrders.
     */
    cursor?: WorkOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkOrders.
     */
    skip?: number
    distinct?: WorkOrderScalarFieldEnum | WorkOrderScalarFieldEnum[]
  }

  /**
   * WorkOrder create
   */
  export type WorkOrderCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkOrder
     */
    select?: WorkOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkOrder
     */
    omit?: WorkOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkOrderInclude<ExtArgs> | null
    /**
     * The data needed to create a WorkOrder.
     */
    data: XOR<WorkOrderCreateInput, WorkOrderUncheckedCreateInput>
  }

  /**
   * WorkOrder createMany
   */
  export type WorkOrderCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WorkOrders.
     */
    data: WorkOrderCreateManyInput | WorkOrderCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WorkOrder createManyAndReturn
   */
  export type WorkOrderCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkOrder
     */
    select?: WorkOrderSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WorkOrder
     */
    omit?: WorkOrderOmit<ExtArgs> | null
    /**
     * The data used to create many WorkOrders.
     */
    data: WorkOrderCreateManyInput | WorkOrderCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkOrderIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * WorkOrder update
   */
  export type WorkOrderUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkOrder
     */
    select?: WorkOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkOrder
     */
    omit?: WorkOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkOrderInclude<ExtArgs> | null
    /**
     * The data needed to update a WorkOrder.
     */
    data: XOR<WorkOrderUpdateInput, WorkOrderUncheckedUpdateInput>
    /**
     * Choose, which WorkOrder to update.
     */
    where: WorkOrderWhereUniqueInput
  }

  /**
   * WorkOrder updateMany
   */
  export type WorkOrderUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WorkOrders.
     */
    data: XOR<WorkOrderUpdateManyMutationInput, WorkOrderUncheckedUpdateManyInput>
    /**
     * Filter which WorkOrders to update
     */
    where?: WorkOrderWhereInput
    /**
     * Limit how many WorkOrders to update.
     */
    limit?: number
  }

  /**
   * WorkOrder updateManyAndReturn
   */
  export type WorkOrderUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkOrder
     */
    select?: WorkOrderSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WorkOrder
     */
    omit?: WorkOrderOmit<ExtArgs> | null
    /**
     * The data used to update WorkOrders.
     */
    data: XOR<WorkOrderUpdateManyMutationInput, WorkOrderUncheckedUpdateManyInput>
    /**
     * Filter which WorkOrders to update
     */
    where?: WorkOrderWhereInput
    /**
     * Limit how many WorkOrders to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkOrderIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * WorkOrder upsert
   */
  export type WorkOrderUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkOrder
     */
    select?: WorkOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkOrder
     */
    omit?: WorkOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkOrderInclude<ExtArgs> | null
    /**
     * The filter to search for the WorkOrder to update in case it exists.
     */
    where: WorkOrderWhereUniqueInput
    /**
     * In case the WorkOrder found by the `where` argument doesn't exist, create a new WorkOrder with this data.
     */
    create: XOR<WorkOrderCreateInput, WorkOrderUncheckedCreateInput>
    /**
     * In case the WorkOrder was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WorkOrderUpdateInput, WorkOrderUncheckedUpdateInput>
  }

  /**
   * WorkOrder delete
   */
  export type WorkOrderDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkOrder
     */
    select?: WorkOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkOrder
     */
    omit?: WorkOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkOrderInclude<ExtArgs> | null
    /**
     * Filter which WorkOrder to delete.
     */
    where: WorkOrderWhereUniqueInput
  }

  /**
   * WorkOrder deleteMany
   */
  export type WorkOrderDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WorkOrders to delete
     */
    where?: WorkOrderWhereInput
    /**
     * Limit how many WorkOrders to delete.
     */
    limit?: number
  }

  /**
   * WorkOrder.changeRequests
   */
  export type WorkOrder$changeRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChangeRequest
     */
    select?: ChangeRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChangeRequest
     */
    omit?: ChangeRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChangeRequestInclude<ExtArgs> | null
    where?: ChangeRequestWhereInput
    orderBy?: ChangeRequestOrderByWithRelationInput | ChangeRequestOrderByWithRelationInput[]
    cursor?: ChangeRequestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChangeRequestScalarFieldEnum | ChangeRequestScalarFieldEnum[]
  }

  /**
   * WorkOrder.evidences
   */
  export type WorkOrder$evidencesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evidence
     */
    select?: EvidenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Evidence
     */
    omit?: EvidenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvidenceInclude<ExtArgs> | null
    where?: EvidenceWhereInput
    orderBy?: EvidenceOrderByWithRelationInput | EvidenceOrderByWithRelationInput[]
    cursor?: EvidenceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EvidenceScalarFieldEnum | EvidenceScalarFieldEnum[]
  }

  /**
   * WorkOrder.review
   */
  export type WorkOrder$reviewArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    where?: ReviewWhereInput
  }

  /**
   * WorkOrder.receipt
   */
  export type WorkOrder$receiptArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Receipt
     */
    select?: ReceiptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Receipt
     */
    omit?: ReceiptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReceiptInclude<ExtArgs> | null
    where?: ReceiptWhereInput
  }

  /**
   * WorkOrder without action
   */
  export type WorkOrderDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkOrder
     */
    select?: WorkOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkOrder
     */
    omit?: WorkOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkOrderInclude<ExtArgs> | null
  }


  /**
   * Model ChangeRequest
   */

  export type AggregateChangeRequest = {
    _count: ChangeRequestCountAggregateOutputType | null
    _avg: ChangeRequestAvgAggregateOutputType | null
    _sum: ChangeRequestSumAggregateOutputType | null
    _min: ChangeRequestMinAggregateOutputType | null
    _max: ChangeRequestMaxAggregateOutputType | null
  }

  export type ChangeRequestAvgAggregateOutputType = {
    additionalCost: number | null
  }

  export type ChangeRequestSumAggregateOutputType = {
    additionalCost: number | null
  }

  export type ChangeRequestMinAggregateOutputType = {
    id: string | null
    workOrderId: string | null
    description: string | null
    justification: string | null
    additionalCost: number | null
    additionalTime: string | null
    status: $Enums.ChangeRequestStatus | null
    decidedAt: Date | null
    decidedBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ChangeRequestMaxAggregateOutputType = {
    id: string | null
    workOrderId: string | null
    description: string | null
    justification: string | null
    additionalCost: number | null
    additionalTime: string | null
    status: $Enums.ChangeRequestStatus | null
    decidedAt: Date | null
    decidedBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ChangeRequestCountAggregateOutputType = {
    id: number
    workOrderId: number
    description: number
    justification: number
    additionalCost: number
    additionalTime: number
    status: number
    decidedAt: number
    decidedBy: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ChangeRequestAvgAggregateInputType = {
    additionalCost?: true
  }

  export type ChangeRequestSumAggregateInputType = {
    additionalCost?: true
  }

  export type ChangeRequestMinAggregateInputType = {
    id?: true
    workOrderId?: true
    description?: true
    justification?: true
    additionalCost?: true
    additionalTime?: true
    status?: true
    decidedAt?: true
    decidedBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ChangeRequestMaxAggregateInputType = {
    id?: true
    workOrderId?: true
    description?: true
    justification?: true
    additionalCost?: true
    additionalTime?: true
    status?: true
    decidedAt?: true
    decidedBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ChangeRequestCountAggregateInputType = {
    id?: true
    workOrderId?: true
    description?: true
    justification?: true
    additionalCost?: true
    additionalTime?: true
    status?: true
    decidedAt?: true
    decidedBy?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ChangeRequestAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChangeRequest to aggregate.
     */
    where?: ChangeRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChangeRequests to fetch.
     */
    orderBy?: ChangeRequestOrderByWithRelationInput | ChangeRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ChangeRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChangeRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChangeRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ChangeRequests
    **/
    _count?: true | ChangeRequestCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ChangeRequestAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ChangeRequestSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChangeRequestMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChangeRequestMaxAggregateInputType
  }

  export type GetChangeRequestAggregateType<T extends ChangeRequestAggregateArgs> = {
        [P in keyof T & keyof AggregateChangeRequest]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChangeRequest[P]>
      : GetScalarType<T[P], AggregateChangeRequest[P]>
  }




  export type ChangeRequestGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChangeRequestWhereInput
    orderBy?: ChangeRequestOrderByWithAggregationInput | ChangeRequestOrderByWithAggregationInput[]
    by: ChangeRequestScalarFieldEnum[] | ChangeRequestScalarFieldEnum
    having?: ChangeRequestScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChangeRequestCountAggregateInputType | true
    _avg?: ChangeRequestAvgAggregateInputType
    _sum?: ChangeRequestSumAggregateInputType
    _min?: ChangeRequestMinAggregateInputType
    _max?: ChangeRequestMaxAggregateInputType
  }

  export type ChangeRequestGroupByOutputType = {
    id: string
    workOrderId: string
    description: string
    justification: string
    additionalCost: number
    additionalTime: string | null
    status: $Enums.ChangeRequestStatus
    decidedAt: Date | null
    decidedBy: string | null
    createdAt: Date
    updatedAt: Date
    _count: ChangeRequestCountAggregateOutputType | null
    _avg: ChangeRequestAvgAggregateOutputType | null
    _sum: ChangeRequestSumAggregateOutputType | null
    _min: ChangeRequestMinAggregateOutputType | null
    _max: ChangeRequestMaxAggregateOutputType | null
  }

  type GetChangeRequestGroupByPayload<T extends ChangeRequestGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChangeRequestGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChangeRequestGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChangeRequestGroupByOutputType[P]>
            : GetScalarType<T[P], ChangeRequestGroupByOutputType[P]>
        }
      >
    >


  export type ChangeRequestSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workOrderId?: boolean
    description?: boolean
    justification?: boolean
    additionalCost?: boolean
    additionalTime?: boolean
    status?: boolean
    decidedAt?: boolean
    decidedBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    workOrder?: boolean | WorkOrderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["changeRequest"]>

  export type ChangeRequestSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workOrderId?: boolean
    description?: boolean
    justification?: boolean
    additionalCost?: boolean
    additionalTime?: boolean
    status?: boolean
    decidedAt?: boolean
    decidedBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    workOrder?: boolean | WorkOrderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["changeRequest"]>

  export type ChangeRequestSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workOrderId?: boolean
    description?: boolean
    justification?: boolean
    additionalCost?: boolean
    additionalTime?: boolean
    status?: boolean
    decidedAt?: boolean
    decidedBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    workOrder?: boolean | WorkOrderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["changeRequest"]>

  export type ChangeRequestSelectScalar = {
    id?: boolean
    workOrderId?: boolean
    description?: boolean
    justification?: boolean
    additionalCost?: boolean
    additionalTime?: boolean
    status?: boolean
    decidedAt?: boolean
    decidedBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ChangeRequestOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "workOrderId" | "description" | "justification" | "additionalCost" | "additionalTime" | "status" | "decidedAt" | "decidedBy" | "createdAt" | "updatedAt", ExtArgs["result"]["changeRequest"]>
  export type ChangeRequestInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workOrder?: boolean | WorkOrderDefaultArgs<ExtArgs>
  }
  export type ChangeRequestIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workOrder?: boolean | WorkOrderDefaultArgs<ExtArgs>
  }
  export type ChangeRequestIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workOrder?: boolean | WorkOrderDefaultArgs<ExtArgs>
  }

  export type $ChangeRequestPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ChangeRequest"
    objects: {
      workOrder: Prisma.$WorkOrderPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      workOrderId: string
      description: string
      justification: string
      additionalCost: number
      additionalTime: string | null
      status: $Enums.ChangeRequestStatus
      decidedAt: Date | null
      decidedBy: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["changeRequest"]>
    composites: {}
  }

  type ChangeRequestGetPayload<S extends boolean | null | undefined | ChangeRequestDefaultArgs> = $Result.GetResult<Prisma.$ChangeRequestPayload, S>

  type ChangeRequestCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ChangeRequestFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ChangeRequestCountAggregateInputType | true
    }

  export interface ChangeRequestDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ChangeRequest'], meta: { name: 'ChangeRequest' } }
    /**
     * Find zero or one ChangeRequest that matches the filter.
     * @param {ChangeRequestFindUniqueArgs} args - Arguments to find a ChangeRequest
     * @example
     * // Get one ChangeRequest
     * const changeRequest = await prisma.changeRequest.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ChangeRequestFindUniqueArgs>(args: SelectSubset<T, ChangeRequestFindUniqueArgs<ExtArgs>>): Prisma__ChangeRequestClient<$Result.GetResult<Prisma.$ChangeRequestPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ChangeRequest that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ChangeRequestFindUniqueOrThrowArgs} args - Arguments to find a ChangeRequest
     * @example
     * // Get one ChangeRequest
     * const changeRequest = await prisma.changeRequest.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ChangeRequestFindUniqueOrThrowArgs>(args: SelectSubset<T, ChangeRequestFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ChangeRequestClient<$Result.GetResult<Prisma.$ChangeRequestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ChangeRequest that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChangeRequestFindFirstArgs} args - Arguments to find a ChangeRequest
     * @example
     * // Get one ChangeRequest
     * const changeRequest = await prisma.changeRequest.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ChangeRequestFindFirstArgs>(args?: SelectSubset<T, ChangeRequestFindFirstArgs<ExtArgs>>): Prisma__ChangeRequestClient<$Result.GetResult<Prisma.$ChangeRequestPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ChangeRequest that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChangeRequestFindFirstOrThrowArgs} args - Arguments to find a ChangeRequest
     * @example
     * // Get one ChangeRequest
     * const changeRequest = await prisma.changeRequest.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ChangeRequestFindFirstOrThrowArgs>(args?: SelectSubset<T, ChangeRequestFindFirstOrThrowArgs<ExtArgs>>): Prisma__ChangeRequestClient<$Result.GetResult<Prisma.$ChangeRequestPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ChangeRequests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChangeRequestFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ChangeRequests
     * const changeRequests = await prisma.changeRequest.findMany()
     * 
     * // Get first 10 ChangeRequests
     * const changeRequests = await prisma.changeRequest.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const changeRequestWithIdOnly = await prisma.changeRequest.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ChangeRequestFindManyArgs>(args?: SelectSubset<T, ChangeRequestFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChangeRequestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ChangeRequest.
     * @param {ChangeRequestCreateArgs} args - Arguments to create a ChangeRequest.
     * @example
     * // Create one ChangeRequest
     * const ChangeRequest = await prisma.changeRequest.create({
     *   data: {
     *     // ... data to create a ChangeRequest
     *   }
     * })
     * 
     */
    create<T extends ChangeRequestCreateArgs>(args: SelectSubset<T, ChangeRequestCreateArgs<ExtArgs>>): Prisma__ChangeRequestClient<$Result.GetResult<Prisma.$ChangeRequestPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ChangeRequests.
     * @param {ChangeRequestCreateManyArgs} args - Arguments to create many ChangeRequests.
     * @example
     * // Create many ChangeRequests
     * const changeRequest = await prisma.changeRequest.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ChangeRequestCreateManyArgs>(args?: SelectSubset<T, ChangeRequestCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ChangeRequests and returns the data saved in the database.
     * @param {ChangeRequestCreateManyAndReturnArgs} args - Arguments to create many ChangeRequests.
     * @example
     * // Create many ChangeRequests
     * const changeRequest = await prisma.changeRequest.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ChangeRequests and only return the `id`
     * const changeRequestWithIdOnly = await prisma.changeRequest.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ChangeRequestCreateManyAndReturnArgs>(args?: SelectSubset<T, ChangeRequestCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChangeRequestPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ChangeRequest.
     * @param {ChangeRequestDeleteArgs} args - Arguments to delete one ChangeRequest.
     * @example
     * // Delete one ChangeRequest
     * const ChangeRequest = await prisma.changeRequest.delete({
     *   where: {
     *     // ... filter to delete one ChangeRequest
     *   }
     * })
     * 
     */
    delete<T extends ChangeRequestDeleteArgs>(args: SelectSubset<T, ChangeRequestDeleteArgs<ExtArgs>>): Prisma__ChangeRequestClient<$Result.GetResult<Prisma.$ChangeRequestPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ChangeRequest.
     * @param {ChangeRequestUpdateArgs} args - Arguments to update one ChangeRequest.
     * @example
     * // Update one ChangeRequest
     * const changeRequest = await prisma.changeRequest.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ChangeRequestUpdateArgs>(args: SelectSubset<T, ChangeRequestUpdateArgs<ExtArgs>>): Prisma__ChangeRequestClient<$Result.GetResult<Prisma.$ChangeRequestPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ChangeRequests.
     * @param {ChangeRequestDeleteManyArgs} args - Arguments to filter ChangeRequests to delete.
     * @example
     * // Delete a few ChangeRequests
     * const { count } = await prisma.changeRequest.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ChangeRequestDeleteManyArgs>(args?: SelectSubset<T, ChangeRequestDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChangeRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChangeRequestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ChangeRequests
     * const changeRequest = await prisma.changeRequest.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ChangeRequestUpdateManyArgs>(args: SelectSubset<T, ChangeRequestUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChangeRequests and returns the data updated in the database.
     * @param {ChangeRequestUpdateManyAndReturnArgs} args - Arguments to update many ChangeRequests.
     * @example
     * // Update many ChangeRequests
     * const changeRequest = await prisma.changeRequest.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ChangeRequests and only return the `id`
     * const changeRequestWithIdOnly = await prisma.changeRequest.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ChangeRequestUpdateManyAndReturnArgs>(args: SelectSubset<T, ChangeRequestUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChangeRequestPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ChangeRequest.
     * @param {ChangeRequestUpsertArgs} args - Arguments to update or create a ChangeRequest.
     * @example
     * // Update or create a ChangeRequest
     * const changeRequest = await prisma.changeRequest.upsert({
     *   create: {
     *     // ... data to create a ChangeRequest
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ChangeRequest we want to update
     *   }
     * })
     */
    upsert<T extends ChangeRequestUpsertArgs>(args: SelectSubset<T, ChangeRequestUpsertArgs<ExtArgs>>): Prisma__ChangeRequestClient<$Result.GetResult<Prisma.$ChangeRequestPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ChangeRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChangeRequestCountArgs} args - Arguments to filter ChangeRequests to count.
     * @example
     * // Count the number of ChangeRequests
     * const count = await prisma.changeRequest.count({
     *   where: {
     *     // ... the filter for the ChangeRequests we want to count
     *   }
     * })
    **/
    count<T extends ChangeRequestCountArgs>(
      args?: Subset<T, ChangeRequestCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChangeRequestCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ChangeRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChangeRequestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChangeRequestAggregateArgs>(args: Subset<T, ChangeRequestAggregateArgs>): Prisma.PrismaPromise<GetChangeRequestAggregateType<T>>

    /**
     * Group by ChangeRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChangeRequestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChangeRequestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChangeRequestGroupByArgs['orderBy'] }
        : { orderBy?: ChangeRequestGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChangeRequestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChangeRequestGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ChangeRequest model
   */
  readonly fields: ChangeRequestFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ChangeRequest.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ChangeRequestClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    workOrder<T extends WorkOrderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WorkOrderDefaultArgs<ExtArgs>>): Prisma__WorkOrderClient<$Result.GetResult<Prisma.$WorkOrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ChangeRequest model
   */
  interface ChangeRequestFieldRefs {
    readonly id: FieldRef<"ChangeRequest", 'String'>
    readonly workOrderId: FieldRef<"ChangeRequest", 'String'>
    readonly description: FieldRef<"ChangeRequest", 'String'>
    readonly justification: FieldRef<"ChangeRequest", 'String'>
    readonly additionalCost: FieldRef<"ChangeRequest", 'Float'>
    readonly additionalTime: FieldRef<"ChangeRequest", 'String'>
    readonly status: FieldRef<"ChangeRequest", 'ChangeRequestStatus'>
    readonly decidedAt: FieldRef<"ChangeRequest", 'DateTime'>
    readonly decidedBy: FieldRef<"ChangeRequest", 'String'>
    readonly createdAt: FieldRef<"ChangeRequest", 'DateTime'>
    readonly updatedAt: FieldRef<"ChangeRequest", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ChangeRequest findUnique
   */
  export type ChangeRequestFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChangeRequest
     */
    select?: ChangeRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChangeRequest
     */
    omit?: ChangeRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChangeRequestInclude<ExtArgs> | null
    /**
     * Filter, which ChangeRequest to fetch.
     */
    where: ChangeRequestWhereUniqueInput
  }

  /**
   * ChangeRequest findUniqueOrThrow
   */
  export type ChangeRequestFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChangeRequest
     */
    select?: ChangeRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChangeRequest
     */
    omit?: ChangeRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChangeRequestInclude<ExtArgs> | null
    /**
     * Filter, which ChangeRequest to fetch.
     */
    where: ChangeRequestWhereUniqueInput
  }

  /**
   * ChangeRequest findFirst
   */
  export type ChangeRequestFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChangeRequest
     */
    select?: ChangeRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChangeRequest
     */
    omit?: ChangeRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChangeRequestInclude<ExtArgs> | null
    /**
     * Filter, which ChangeRequest to fetch.
     */
    where?: ChangeRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChangeRequests to fetch.
     */
    orderBy?: ChangeRequestOrderByWithRelationInput | ChangeRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChangeRequests.
     */
    cursor?: ChangeRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChangeRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChangeRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChangeRequests.
     */
    distinct?: ChangeRequestScalarFieldEnum | ChangeRequestScalarFieldEnum[]
  }

  /**
   * ChangeRequest findFirstOrThrow
   */
  export type ChangeRequestFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChangeRequest
     */
    select?: ChangeRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChangeRequest
     */
    omit?: ChangeRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChangeRequestInclude<ExtArgs> | null
    /**
     * Filter, which ChangeRequest to fetch.
     */
    where?: ChangeRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChangeRequests to fetch.
     */
    orderBy?: ChangeRequestOrderByWithRelationInput | ChangeRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChangeRequests.
     */
    cursor?: ChangeRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChangeRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChangeRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChangeRequests.
     */
    distinct?: ChangeRequestScalarFieldEnum | ChangeRequestScalarFieldEnum[]
  }

  /**
   * ChangeRequest findMany
   */
  export type ChangeRequestFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChangeRequest
     */
    select?: ChangeRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChangeRequest
     */
    omit?: ChangeRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChangeRequestInclude<ExtArgs> | null
    /**
     * Filter, which ChangeRequests to fetch.
     */
    where?: ChangeRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChangeRequests to fetch.
     */
    orderBy?: ChangeRequestOrderByWithRelationInput | ChangeRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ChangeRequests.
     */
    cursor?: ChangeRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChangeRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChangeRequests.
     */
    skip?: number
    distinct?: ChangeRequestScalarFieldEnum | ChangeRequestScalarFieldEnum[]
  }

  /**
   * ChangeRequest create
   */
  export type ChangeRequestCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChangeRequest
     */
    select?: ChangeRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChangeRequest
     */
    omit?: ChangeRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChangeRequestInclude<ExtArgs> | null
    /**
     * The data needed to create a ChangeRequest.
     */
    data: XOR<ChangeRequestCreateInput, ChangeRequestUncheckedCreateInput>
  }

  /**
   * ChangeRequest createMany
   */
  export type ChangeRequestCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ChangeRequests.
     */
    data: ChangeRequestCreateManyInput | ChangeRequestCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ChangeRequest createManyAndReturn
   */
  export type ChangeRequestCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChangeRequest
     */
    select?: ChangeRequestSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ChangeRequest
     */
    omit?: ChangeRequestOmit<ExtArgs> | null
    /**
     * The data used to create many ChangeRequests.
     */
    data: ChangeRequestCreateManyInput | ChangeRequestCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChangeRequestIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ChangeRequest update
   */
  export type ChangeRequestUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChangeRequest
     */
    select?: ChangeRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChangeRequest
     */
    omit?: ChangeRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChangeRequestInclude<ExtArgs> | null
    /**
     * The data needed to update a ChangeRequest.
     */
    data: XOR<ChangeRequestUpdateInput, ChangeRequestUncheckedUpdateInput>
    /**
     * Choose, which ChangeRequest to update.
     */
    where: ChangeRequestWhereUniqueInput
  }

  /**
   * ChangeRequest updateMany
   */
  export type ChangeRequestUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ChangeRequests.
     */
    data: XOR<ChangeRequestUpdateManyMutationInput, ChangeRequestUncheckedUpdateManyInput>
    /**
     * Filter which ChangeRequests to update
     */
    where?: ChangeRequestWhereInput
    /**
     * Limit how many ChangeRequests to update.
     */
    limit?: number
  }

  /**
   * ChangeRequest updateManyAndReturn
   */
  export type ChangeRequestUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChangeRequest
     */
    select?: ChangeRequestSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ChangeRequest
     */
    omit?: ChangeRequestOmit<ExtArgs> | null
    /**
     * The data used to update ChangeRequests.
     */
    data: XOR<ChangeRequestUpdateManyMutationInput, ChangeRequestUncheckedUpdateManyInput>
    /**
     * Filter which ChangeRequests to update
     */
    where?: ChangeRequestWhereInput
    /**
     * Limit how many ChangeRequests to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChangeRequestIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ChangeRequest upsert
   */
  export type ChangeRequestUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChangeRequest
     */
    select?: ChangeRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChangeRequest
     */
    omit?: ChangeRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChangeRequestInclude<ExtArgs> | null
    /**
     * The filter to search for the ChangeRequest to update in case it exists.
     */
    where: ChangeRequestWhereUniqueInput
    /**
     * In case the ChangeRequest found by the `where` argument doesn't exist, create a new ChangeRequest with this data.
     */
    create: XOR<ChangeRequestCreateInput, ChangeRequestUncheckedCreateInput>
    /**
     * In case the ChangeRequest was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ChangeRequestUpdateInput, ChangeRequestUncheckedUpdateInput>
  }

  /**
   * ChangeRequest delete
   */
  export type ChangeRequestDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChangeRequest
     */
    select?: ChangeRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChangeRequest
     */
    omit?: ChangeRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChangeRequestInclude<ExtArgs> | null
    /**
     * Filter which ChangeRequest to delete.
     */
    where: ChangeRequestWhereUniqueInput
  }

  /**
   * ChangeRequest deleteMany
   */
  export type ChangeRequestDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChangeRequests to delete
     */
    where?: ChangeRequestWhereInput
    /**
     * Limit how many ChangeRequests to delete.
     */
    limit?: number
  }

  /**
   * ChangeRequest without action
   */
  export type ChangeRequestDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChangeRequest
     */
    select?: ChangeRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChangeRequest
     */
    omit?: ChangeRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChangeRequestInclude<ExtArgs> | null
  }


  /**
   * Model Evidence
   */

  export type AggregateEvidence = {
    _count: EvidenceCountAggregateOutputType | null
    _min: EvidenceMinAggregateOutputType | null
    _max: EvidenceMaxAggregateOutputType | null
  }

  export type EvidenceMinAggregateOutputType = {
    id: string | null
    workOrderId: string | null
    stage: $Enums.EvidenceStage | null
    url: string | null
    mediaType: $Enums.MediaType | null
    fileName: string | null
    description: string | null
    flagged: boolean | null
    createdAt: Date | null
  }

  export type EvidenceMaxAggregateOutputType = {
    id: string | null
    workOrderId: string | null
    stage: $Enums.EvidenceStage | null
    url: string | null
    mediaType: $Enums.MediaType | null
    fileName: string | null
    description: string | null
    flagged: boolean | null
    createdAt: Date | null
  }

  export type EvidenceCountAggregateOutputType = {
    id: number
    workOrderId: number
    stage: number
    url: number
    mediaType: number
    fileName: number
    description: number
    flagged: number
    createdAt: number
    _all: number
  }


  export type EvidenceMinAggregateInputType = {
    id?: true
    workOrderId?: true
    stage?: true
    url?: true
    mediaType?: true
    fileName?: true
    description?: true
    flagged?: true
    createdAt?: true
  }

  export type EvidenceMaxAggregateInputType = {
    id?: true
    workOrderId?: true
    stage?: true
    url?: true
    mediaType?: true
    fileName?: true
    description?: true
    flagged?: true
    createdAt?: true
  }

  export type EvidenceCountAggregateInputType = {
    id?: true
    workOrderId?: true
    stage?: true
    url?: true
    mediaType?: true
    fileName?: true
    description?: true
    flagged?: true
    createdAt?: true
    _all?: true
  }

  export type EvidenceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Evidence to aggregate.
     */
    where?: EvidenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Evidences to fetch.
     */
    orderBy?: EvidenceOrderByWithRelationInput | EvidenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EvidenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Evidences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Evidences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Evidences
    **/
    _count?: true | EvidenceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EvidenceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EvidenceMaxAggregateInputType
  }

  export type GetEvidenceAggregateType<T extends EvidenceAggregateArgs> = {
        [P in keyof T & keyof AggregateEvidence]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEvidence[P]>
      : GetScalarType<T[P], AggregateEvidence[P]>
  }




  export type EvidenceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EvidenceWhereInput
    orderBy?: EvidenceOrderByWithAggregationInput | EvidenceOrderByWithAggregationInput[]
    by: EvidenceScalarFieldEnum[] | EvidenceScalarFieldEnum
    having?: EvidenceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EvidenceCountAggregateInputType | true
    _min?: EvidenceMinAggregateInputType
    _max?: EvidenceMaxAggregateInputType
  }

  export type EvidenceGroupByOutputType = {
    id: string
    workOrderId: string
    stage: $Enums.EvidenceStage
    url: string
    mediaType: $Enums.MediaType
    fileName: string | null
    description: string | null
    flagged: boolean
    createdAt: Date
    _count: EvidenceCountAggregateOutputType | null
    _min: EvidenceMinAggregateOutputType | null
    _max: EvidenceMaxAggregateOutputType | null
  }

  type GetEvidenceGroupByPayload<T extends EvidenceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EvidenceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EvidenceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EvidenceGroupByOutputType[P]>
            : GetScalarType<T[P], EvidenceGroupByOutputType[P]>
        }
      >
    >


  export type EvidenceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workOrderId?: boolean
    stage?: boolean
    url?: boolean
    mediaType?: boolean
    fileName?: boolean
    description?: boolean
    flagged?: boolean
    createdAt?: boolean
    workOrder?: boolean | WorkOrderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["evidence"]>

  export type EvidenceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workOrderId?: boolean
    stage?: boolean
    url?: boolean
    mediaType?: boolean
    fileName?: boolean
    description?: boolean
    flagged?: boolean
    createdAt?: boolean
    workOrder?: boolean | WorkOrderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["evidence"]>

  export type EvidenceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workOrderId?: boolean
    stage?: boolean
    url?: boolean
    mediaType?: boolean
    fileName?: boolean
    description?: boolean
    flagged?: boolean
    createdAt?: boolean
    workOrder?: boolean | WorkOrderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["evidence"]>

  export type EvidenceSelectScalar = {
    id?: boolean
    workOrderId?: boolean
    stage?: boolean
    url?: boolean
    mediaType?: boolean
    fileName?: boolean
    description?: boolean
    flagged?: boolean
    createdAt?: boolean
  }

  export type EvidenceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "workOrderId" | "stage" | "url" | "mediaType" | "fileName" | "description" | "flagged" | "createdAt", ExtArgs["result"]["evidence"]>
  export type EvidenceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workOrder?: boolean | WorkOrderDefaultArgs<ExtArgs>
  }
  export type EvidenceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workOrder?: boolean | WorkOrderDefaultArgs<ExtArgs>
  }
  export type EvidenceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workOrder?: boolean | WorkOrderDefaultArgs<ExtArgs>
  }

  export type $EvidencePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Evidence"
    objects: {
      workOrder: Prisma.$WorkOrderPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      workOrderId: string
      stage: $Enums.EvidenceStage
      url: string
      mediaType: $Enums.MediaType
      fileName: string | null
      description: string | null
      flagged: boolean
      createdAt: Date
    }, ExtArgs["result"]["evidence"]>
    composites: {}
  }

  type EvidenceGetPayload<S extends boolean | null | undefined | EvidenceDefaultArgs> = $Result.GetResult<Prisma.$EvidencePayload, S>

  type EvidenceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EvidenceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EvidenceCountAggregateInputType | true
    }

  export interface EvidenceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Evidence'], meta: { name: 'Evidence' } }
    /**
     * Find zero or one Evidence that matches the filter.
     * @param {EvidenceFindUniqueArgs} args - Arguments to find a Evidence
     * @example
     * // Get one Evidence
     * const evidence = await prisma.evidence.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EvidenceFindUniqueArgs>(args: SelectSubset<T, EvidenceFindUniqueArgs<ExtArgs>>): Prisma__EvidenceClient<$Result.GetResult<Prisma.$EvidencePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Evidence that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EvidenceFindUniqueOrThrowArgs} args - Arguments to find a Evidence
     * @example
     * // Get one Evidence
     * const evidence = await prisma.evidence.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EvidenceFindUniqueOrThrowArgs>(args: SelectSubset<T, EvidenceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EvidenceClient<$Result.GetResult<Prisma.$EvidencePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Evidence that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvidenceFindFirstArgs} args - Arguments to find a Evidence
     * @example
     * // Get one Evidence
     * const evidence = await prisma.evidence.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EvidenceFindFirstArgs>(args?: SelectSubset<T, EvidenceFindFirstArgs<ExtArgs>>): Prisma__EvidenceClient<$Result.GetResult<Prisma.$EvidencePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Evidence that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvidenceFindFirstOrThrowArgs} args - Arguments to find a Evidence
     * @example
     * // Get one Evidence
     * const evidence = await prisma.evidence.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EvidenceFindFirstOrThrowArgs>(args?: SelectSubset<T, EvidenceFindFirstOrThrowArgs<ExtArgs>>): Prisma__EvidenceClient<$Result.GetResult<Prisma.$EvidencePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Evidences that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvidenceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Evidences
     * const evidences = await prisma.evidence.findMany()
     * 
     * // Get first 10 Evidences
     * const evidences = await prisma.evidence.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const evidenceWithIdOnly = await prisma.evidence.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EvidenceFindManyArgs>(args?: SelectSubset<T, EvidenceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EvidencePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Evidence.
     * @param {EvidenceCreateArgs} args - Arguments to create a Evidence.
     * @example
     * // Create one Evidence
     * const Evidence = await prisma.evidence.create({
     *   data: {
     *     // ... data to create a Evidence
     *   }
     * })
     * 
     */
    create<T extends EvidenceCreateArgs>(args: SelectSubset<T, EvidenceCreateArgs<ExtArgs>>): Prisma__EvidenceClient<$Result.GetResult<Prisma.$EvidencePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Evidences.
     * @param {EvidenceCreateManyArgs} args - Arguments to create many Evidences.
     * @example
     * // Create many Evidences
     * const evidence = await prisma.evidence.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EvidenceCreateManyArgs>(args?: SelectSubset<T, EvidenceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Evidences and returns the data saved in the database.
     * @param {EvidenceCreateManyAndReturnArgs} args - Arguments to create many Evidences.
     * @example
     * // Create many Evidences
     * const evidence = await prisma.evidence.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Evidences and only return the `id`
     * const evidenceWithIdOnly = await prisma.evidence.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EvidenceCreateManyAndReturnArgs>(args?: SelectSubset<T, EvidenceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EvidencePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Evidence.
     * @param {EvidenceDeleteArgs} args - Arguments to delete one Evidence.
     * @example
     * // Delete one Evidence
     * const Evidence = await prisma.evidence.delete({
     *   where: {
     *     // ... filter to delete one Evidence
     *   }
     * })
     * 
     */
    delete<T extends EvidenceDeleteArgs>(args: SelectSubset<T, EvidenceDeleteArgs<ExtArgs>>): Prisma__EvidenceClient<$Result.GetResult<Prisma.$EvidencePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Evidence.
     * @param {EvidenceUpdateArgs} args - Arguments to update one Evidence.
     * @example
     * // Update one Evidence
     * const evidence = await prisma.evidence.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EvidenceUpdateArgs>(args: SelectSubset<T, EvidenceUpdateArgs<ExtArgs>>): Prisma__EvidenceClient<$Result.GetResult<Prisma.$EvidencePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Evidences.
     * @param {EvidenceDeleteManyArgs} args - Arguments to filter Evidences to delete.
     * @example
     * // Delete a few Evidences
     * const { count } = await prisma.evidence.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EvidenceDeleteManyArgs>(args?: SelectSubset<T, EvidenceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Evidences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvidenceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Evidences
     * const evidence = await prisma.evidence.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EvidenceUpdateManyArgs>(args: SelectSubset<T, EvidenceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Evidences and returns the data updated in the database.
     * @param {EvidenceUpdateManyAndReturnArgs} args - Arguments to update many Evidences.
     * @example
     * // Update many Evidences
     * const evidence = await prisma.evidence.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Evidences and only return the `id`
     * const evidenceWithIdOnly = await prisma.evidence.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EvidenceUpdateManyAndReturnArgs>(args: SelectSubset<T, EvidenceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EvidencePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Evidence.
     * @param {EvidenceUpsertArgs} args - Arguments to update or create a Evidence.
     * @example
     * // Update or create a Evidence
     * const evidence = await prisma.evidence.upsert({
     *   create: {
     *     // ... data to create a Evidence
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Evidence we want to update
     *   }
     * })
     */
    upsert<T extends EvidenceUpsertArgs>(args: SelectSubset<T, EvidenceUpsertArgs<ExtArgs>>): Prisma__EvidenceClient<$Result.GetResult<Prisma.$EvidencePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Evidences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvidenceCountArgs} args - Arguments to filter Evidences to count.
     * @example
     * // Count the number of Evidences
     * const count = await prisma.evidence.count({
     *   where: {
     *     // ... the filter for the Evidences we want to count
     *   }
     * })
    **/
    count<T extends EvidenceCountArgs>(
      args?: Subset<T, EvidenceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EvidenceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Evidence.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvidenceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EvidenceAggregateArgs>(args: Subset<T, EvidenceAggregateArgs>): Prisma.PrismaPromise<GetEvidenceAggregateType<T>>

    /**
     * Group by Evidence.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvidenceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EvidenceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EvidenceGroupByArgs['orderBy'] }
        : { orderBy?: EvidenceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EvidenceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEvidenceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Evidence model
   */
  readonly fields: EvidenceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Evidence.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EvidenceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    workOrder<T extends WorkOrderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WorkOrderDefaultArgs<ExtArgs>>): Prisma__WorkOrderClient<$Result.GetResult<Prisma.$WorkOrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Evidence model
   */
  interface EvidenceFieldRefs {
    readonly id: FieldRef<"Evidence", 'String'>
    readonly workOrderId: FieldRef<"Evidence", 'String'>
    readonly stage: FieldRef<"Evidence", 'EvidenceStage'>
    readonly url: FieldRef<"Evidence", 'String'>
    readonly mediaType: FieldRef<"Evidence", 'MediaType'>
    readonly fileName: FieldRef<"Evidence", 'String'>
    readonly description: FieldRef<"Evidence", 'String'>
    readonly flagged: FieldRef<"Evidence", 'Boolean'>
    readonly createdAt: FieldRef<"Evidence", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Evidence findUnique
   */
  export type EvidenceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evidence
     */
    select?: EvidenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Evidence
     */
    omit?: EvidenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvidenceInclude<ExtArgs> | null
    /**
     * Filter, which Evidence to fetch.
     */
    where: EvidenceWhereUniqueInput
  }

  /**
   * Evidence findUniqueOrThrow
   */
  export type EvidenceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evidence
     */
    select?: EvidenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Evidence
     */
    omit?: EvidenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvidenceInclude<ExtArgs> | null
    /**
     * Filter, which Evidence to fetch.
     */
    where: EvidenceWhereUniqueInput
  }

  /**
   * Evidence findFirst
   */
  export type EvidenceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evidence
     */
    select?: EvidenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Evidence
     */
    omit?: EvidenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvidenceInclude<ExtArgs> | null
    /**
     * Filter, which Evidence to fetch.
     */
    where?: EvidenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Evidences to fetch.
     */
    orderBy?: EvidenceOrderByWithRelationInput | EvidenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Evidences.
     */
    cursor?: EvidenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Evidences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Evidences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Evidences.
     */
    distinct?: EvidenceScalarFieldEnum | EvidenceScalarFieldEnum[]
  }

  /**
   * Evidence findFirstOrThrow
   */
  export type EvidenceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evidence
     */
    select?: EvidenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Evidence
     */
    omit?: EvidenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvidenceInclude<ExtArgs> | null
    /**
     * Filter, which Evidence to fetch.
     */
    where?: EvidenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Evidences to fetch.
     */
    orderBy?: EvidenceOrderByWithRelationInput | EvidenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Evidences.
     */
    cursor?: EvidenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Evidences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Evidences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Evidences.
     */
    distinct?: EvidenceScalarFieldEnum | EvidenceScalarFieldEnum[]
  }

  /**
   * Evidence findMany
   */
  export type EvidenceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evidence
     */
    select?: EvidenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Evidence
     */
    omit?: EvidenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvidenceInclude<ExtArgs> | null
    /**
     * Filter, which Evidences to fetch.
     */
    where?: EvidenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Evidences to fetch.
     */
    orderBy?: EvidenceOrderByWithRelationInput | EvidenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Evidences.
     */
    cursor?: EvidenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Evidences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Evidences.
     */
    skip?: number
    distinct?: EvidenceScalarFieldEnum | EvidenceScalarFieldEnum[]
  }

  /**
   * Evidence create
   */
  export type EvidenceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evidence
     */
    select?: EvidenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Evidence
     */
    omit?: EvidenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvidenceInclude<ExtArgs> | null
    /**
     * The data needed to create a Evidence.
     */
    data: XOR<EvidenceCreateInput, EvidenceUncheckedCreateInput>
  }

  /**
   * Evidence createMany
   */
  export type EvidenceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Evidences.
     */
    data: EvidenceCreateManyInput | EvidenceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Evidence createManyAndReturn
   */
  export type EvidenceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evidence
     */
    select?: EvidenceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Evidence
     */
    omit?: EvidenceOmit<ExtArgs> | null
    /**
     * The data used to create many Evidences.
     */
    data: EvidenceCreateManyInput | EvidenceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvidenceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Evidence update
   */
  export type EvidenceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evidence
     */
    select?: EvidenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Evidence
     */
    omit?: EvidenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvidenceInclude<ExtArgs> | null
    /**
     * The data needed to update a Evidence.
     */
    data: XOR<EvidenceUpdateInput, EvidenceUncheckedUpdateInput>
    /**
     * Choose, which Evidence to update.
     */
    where: EvidenceWhereUniqueInput
  }

  /**
   * Evidence updateMany
   */
  export type EvidenceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Evidences.
     */
    data: XOR<EvidenceUpdateManyMutationInput, EvidenceUncheckedUpdateManyInput>
    /**
     * Filter which Evidences to update
     */
    where?: EvidenceWhereInput
    /**
     * Limit how many Evidences to update.
     */
    limit?: number
  }

  /**
   * Evidence updateManyAndReturn
   */
  export type EvidenceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evidence
     */
    select?: EvidenceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Evidence
     */
    omit?: EvidenceOmit<ExtArgs> | null
    /**
     * The data used to update Evidences.
     */
    data: XOR<EvidenceUpdateManyMutationInput, EvidenceUncheckedUpdateManyInput>
    /**
     * Filter which Evidences to update
     */
    where?: EvidenceWhereInput
    /**
     * Limit how many Evidences to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvidenceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Evidence upsert
   */
  export type EvidenceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evidence
     */
    select?: EvidenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Evidence
     */
    omit?: EvidenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvidenceInclude<ExtArgs> | null
    /**
     * The filter to search for the Evidence to update in case it exists.
     */
    where: EvidenceWhereUniqueInput
    /**
     * In case the Evidence found by the `where` argument doesn't exist, create a new Evidence with this data.
     */
    create: XOR<EvidenceCreateInput, EvidenceUncheckedCreateInput>
    /**
     * In case the Evidence was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EvidenceUpdateInput, EvidenceUncheckedUpdateInput>
  }

  /**
   * Evidence delete
   */
  export type EvidenceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evidence
     */
    select?: EvidenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Evidence
     */
    omit?: EvidenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvidenceInclude<ExtArgs> | null
    /**
     * Filter which Evidence to delete.
     */
    where: EvidenceWhereUniqueInput
  }

  /**
   * Evidence deleteMany
   */
  export type EvidenceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Evidences to delete
     */
    where?: EvidenceWhereInput
    /**
     * Limit how many Evidences to delete.
     */
    limit?: number
  }

  /**
   * Evidence without action
   */
  export type EvidenceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evidence
     */
    select?: EvidenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Evidence
     */
    omit?: EvidenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvidenceInclude<ExtArgs> | null
  }


  /**
   * Model Review
   */

  export type AggregateReview = {
    _count: ReviewCountAggregateOutputType | null
    _avg: ReviewAvgAggregateOutputType | null
    _sum: ReviewSumAggregateOutputType | null
    _min: ReviewMinAggregateOutputType | null
    _max: ReviewMaxAggregateOutputType | null
  }

  export type ReviewAvgAggregateOutputType = {
    rating: number | null
  }

  export type ReviewSumAggregateOutputType = {
    rating: number | null
  }

  export type ReviewMinAggregateOutputType = {
    id: string | null
    workOrderId: string | null
    workshopId: string | null
    userId: string | null
    rating: number | null
    comment: string | null
    editableUntil: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ReviewMaxAggregateOutputType = {
    id: string | null
    workOrderId: string | null
    workshopId: string | null
    userId: string | null
    rating: number | null
    comment: string | null
    editableUntil: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ReviewCountAggregateOutputType = {
    id: number
    workOrderId: number
    workshopId: number
    userId: number
    rating: number
    comment: number
    editableUntil: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ReviewAvgAggregateInputType = {
    rating?: true
  }

  export type ReviewSumAggregateInputType = {
    rating?: true
  }

  export type ReviewMinAggregateInputType = {
    id?: true
    workOrderId?: true
    workshopId?: true
    userId?: true
    rating?: true
    comment?: true
    editableUntil?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ReviewMaxAggregateInputType = {
    id?: true
    workOrderId?: true
    workshopId?: true
    userId?: true
    rating?: true
    comment?: true
    editableUntil?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ReviewCountAggregateInputType = {
    id?: true
    workOrderId?: true
    workshopId?: true
    userId?: true
    rating?: true
    comment?: true
    editableUntil?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ReviewAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Review to aggregate.
     */
    where?: ReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reviews to fetch.
     */
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Reviews
    **/
    _count?: true | ReviewCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReviewAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReviewSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReviewMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReviewMaxAggregateInputType
  }

  export type GetReviewAggregateType<T extends ReviewAggregateArgs> = {
        [P in keyof T & keyof AggregateReview]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReview[P]>
      : GetScalarType<T[P], AggregateReview[P]>
  }




  export type ReviewGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReviewWhereInput
    orderBy?: ReviewOrderByWithAggregationInput | ReviewOrderByWithAggregationInput[]
    by: ReviewScalarFieldEnum[] | ReviewScalarFieldEnum
    having?: ReviewScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReviewCountAggregateInputType | true
    _avg?: ReviewAvgAggregateInputType
    _sum?: ReviewSumAggregateInputType
    _min?: ReviewMinAggregateInputType
    _max?: ReviewMaxAggregateInputType
  }

  export type ReviewGroupByOutputType = {
    id: string
    workOrderId: string
    workshopId: string
    userId: string
    rating: number
    comment: string | null
    editableUntil: Date
    createdAt: Date
    updatedAt: Date
    _count: ReviewCountAggregateOutputType | null
    _avg: ReviewAvgAggregateOutputType | null
    _sum: ReviewSumAggregateOutputType | null
    _min: ReviewMinAggregateOutputType | null
    _max: ReviewMaxAggregateOutputType | null
  }

  type GetReviewGroupByPayload<T extends ReviewGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReviewGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReviewGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReviewGroupByOutputType[P]>
            : GetScalarType<T[P], ReviewGroupByOutputType[P]>
        }
      >
    >


  export type ReviewSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workOrderId?: boolean
    workshopId?: boolean
    userId?: boolean
    rating?: boolean
    comment?: boolean
    editableUntil?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    workOrder?: boolean | WorkOrderDefaultArgs<ExtArgs>
    workshop?: boolean | WorkshopDefaultArgs<ExtArgs>
    user?: boolean | UserProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["review"]>

  export type ReviewSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workOrderId?: boolean
    workshopId?: boolean
    userId?: boolean
    rating?: boolean
    comment?: boolean
    editableUntil?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    workOrder?: boolean | WorkOrderDefaultArgs<ExtArgs>
    workshop?: boolean | WorkshopDefaultArgs<ExtArgs>
    user?: boolean | UserProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["review"]>

  export type ReviewSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workOrderId?: boolean
    workshopId?: boolean
    userId?: boolean
    rating?: boolean
    comment?: boolean
    editableUntil?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    workOrder?: boolean | WorkOrderDefaultArgs<ExtArgs>
    workshop?: boolean | WorkshopDefaultArgs<ExtArgs>
    user?: boolean | UserProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["review"]>

  export type ReviewSelectScalar = {
    id?: boolean
    workOrderId?: boolean
    workshopId?: boolean
    userId?: boolean
    rating?: boolean
    comment?: boolean
    editableUntil?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ReviewOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "workOrderId" | "workshopId" | "userId" | "rating" | "comment" | "editableUntil" | "createdAt" | "updatedAt", ExtArgs["result"]["review"]>
  export type ReviewInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workOrder?: boolean | WorkOrderDefaultArgs<ExtArgs>
    workshop?: boolean | WorkshopDefaultArgs<ExtArgs>
    user?: boolean | UserProfileDefaultArgs<ExtArgs>
  }
  export type ReviewIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workOrder?: boolean | WorkOrderDefaultArgs<ExtArgs>
    workshop?: boolean | WorkshopDefaultArgs<ExtArgs>
    user?: boolean | UserProfileDefaultArgs<ExtArgs>
  }
  export type ReviewIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workOrder?: boolean | WorkOrderDefaultArgs<ExtArgs>
    workshop?: boolean | WorkshopDefaultArgs<ExtArgs>
    user?: boolean | UserProfileDefaultArgs<ExtArgs>
  }

  export type $ReviewPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Review"
    objects: {
      workOrder: Prisma.$WorkOrderPayload<ExtArgs>
      workshop: Prisma.$WorkshopPayload<ExtArgs>
      user: Prisma.$UserProfilePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      workOrderId: string
      workshopId: string
      userId: string
      rating: number
      comment: string | null
      editableUntil: Date
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["review"]>
    composites: {}
  }

  type ReviewGetPayload<S extends boolean | null | undefined | ReviewDefaultArgs> = $Result.GetResult<Prisma.$ReviewPayload, S>

  type ReviewCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ReviewFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ReviewCountAggregateInputType | true
    }

  export interface ReviewDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Review'], meta: { name: 'Review' } }
    /**
     * Find zero or one Review that matches the filter.
     * @param {ReviewFindUniqueArgs} args - Arguments to find a Review
     * @example
     * // Get one Review
     * const review = await prisma.review.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReviewFindUniqueArgs>(args: SelectSubset<T, ReviewFindUniqueArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Review that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ReviewFindUniqueOrThrowArgs} args - Arguments to find a Review
     * @example
     * // Get one Review
     * const review = await prisma.review.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReviewFindUniqueOrThrowArgs>(args: SelectSubset<T, ReviewFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Review that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewFindFirstArgs} args - Arguments to find a Review
     * @example
     * // Get one Review
     * const review = await prisma.review.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReviewFindFirstArgs>(args?: SelectSubset<T, ReviewFindFirstArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Review that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewFindFirstOrThrowArgs} args - Arguments to find a Review
     * @example
     * // Get one Review
     * const review = await prisma.review.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReviewFindFirstOrThrowArgs>(args?: SelectSubset<T, ReviewFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Reviews that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Reviews
     * const reviews = await prisma.review.findMany()
     * 
     * // Get first 10 Reviews
     * const reviews = await prisma.review.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const reviewWithIdOnly = await prisma.review.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ReviewFindManyArgs>(args?: SelectSubset<T, ReviewFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Review.
     * @param {ReviewCreateArgs} args - Arguments to create a Review.
     * @example
     * // Create one Review
     * const Review = await prisma.review.create({
     *   data: {
     *     // ... data to create a Review
     *   }
     * })
     * 
     */
    create<T extends ReviewCreateArgs>(args: SelectSubset<T, ReviewCreateArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Reviews.
     * @param {ReviewCreateManyArgs} args - Arguments to create many Reviews.
     * @example
     * // Create many Reviews
     * const review = await prisma.review.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReviewCreateManyArgs>(args?: SelectSubset<T, ReviewCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Reviews and returns the data saved in the database.
     * @param {ReviewCreateManyAndReturnArgs} args - Arguments to create many Reviews.
     * @example
     * // Create many Reviews
     * const review = await prisma.review.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Reviews and only return the `id`
     * const reviewWithIdOnly = await prisma.review.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ReviewCreateManyAndReturnArgs>(args?: SelectSubset<T, ReviewCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Review.
     * @param {ReviewDeleteArgs} args - Arguments to delete one Review.
     * @example
     * // Delete one Review
     * const Review = await prisma.review.delete({
     *   where: {
     *     // ... filter to delete one Review
     *   }
     * })
     * 
     */
    delete<T extends ReviewDeleteArgs>(args: SelectSubset<T, ReviewDeleteArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Review.
     * @param {ReviewUpdateArgs} args - Arguments to update one Review.
     * @example
     * // Update one Review
     * const review = await prisma.review.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReviewUpdateArgs>(args: SelectSubset<T, ReviewUpdateArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Reviews.
     * @param {ReviewDeleteManyArgs} args - Arguments to filter Reviews to delete.
     * @example
     * // Delete a few Reviews
     * const { count } = await prisma.review.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReviewDeleteManyArgs>(args?: SelectSubset<T, ReviewDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Reviews
     * const review = await prisma.review.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReviewUpdateManyArgs>(args: SelectSubset<T, ReviewUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reviews and returns the data updated in the database.
     * @param {ReviewUpdateManyAndReturnArgs} args - Arguments to update many Reviews.
     * @example
     * // Update many Reviews
     * const review = await prisma.review.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Reviews and only return the `id`
     * const reviewWithIdOnly = await prisma.review.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ReviewUpdateManyAndReturnArgs>(args: SelectSubset<T, ReviewUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Review.
     * @param {ReviewUpsertArgs} args - Arguments to update or create a Review.
     * @example
     * // Update or create a Review
     * const review = await prisma.review.upsert({
     *   create: {
     *     // ... data to create a Review
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Review we want to update
     *   }
     * })
     */
    upsert<T extends ReviewUpsertArgs>(args: SelectSubset<T, ReviewUpsertArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Reviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewCountArgs} args - Arguments to filter Reviews to count.
     * @example
     * // Count the number of Reviews
     * const count = await prisma.review.count({
     *   where: {
     *     // ... the filter for the Reviews we want to count
     *   }
     * })
    **/
    count<T extends ReviewCountArgs>(
      args?: Subset<T, ReviewCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReviewCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Review.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReviewAggregateArgs>(args: Subset<T, ReviewAggregateArgs>): Prisma.PrismaPromise<GetReviewAggregateType<T>>

    /**
     * Group by Review.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReviewGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReviewGroupByArgs['orderBy'] }
        : { orderBy?: ReviewGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReviewGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReviewGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Review model
   */
  readonly fields: ReviewFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Review.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReviewClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    workOrder<T extends WorkOrderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WorkOrderDefaultArgs<ExtArgs>>): Prisma__WorkOrderClient<$Result.GetResult<Prisma.$WorkOrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    workshop<T extends WorkshopDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WorkshopDefaultArgs<ExtArgs>>): Prisma__WorkshopClient<$Result.GetResult<Prisma.$WorkshopPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserProfileDefaultArgs<ExtArgs>>): Prisma__UserProfileClient<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Review model
   */
  interface ReviewFieldRefs {
    readonly id: FieldRef<"Review", 'String'>
    readonly workOrderId: FieldRef<"Review", 'String'>
    readonly workshopId: FieldRef<"Review", 'String'>
    readonly userId: FieldRef<"Review", 'String'>
    readonly rating: FieldRef<"Review", 'Int'>
    readonly comment: FieldRef<"Review", 'String'>
    readonly editableUntil: FieldRef<"Review", 'DateTime'>
    readonly createdAt: FieldRef<"Review", 'DateTime'>
    readonly updatedAt: FieldRef<"Review", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Review findUnique
   */
  export type ReviewFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter, which Review to fetch.
     */
    where: ReviewWhereUniqueInput
  }

  /**
   * Review findUniqueOrThrow
   */
  export type ReviewFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter, which Review to fetch.
     */
    where: ReviewWhereUniqueInput
  }

  /**
   * Review findFirst
   */
  export type ReviewFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter, which Review to fetch.
     */
    where?: ReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reviews to fetch.
     */
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reviews.
     */
    cursor?: ReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reviews.
     */
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }

  /**
   * Review findFirstOrThrow
   */
  export type ReviewFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter, which Review to fetch.
     */
    where?: ReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reviews to fetch.
     */
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reviews.
     */
    cursor?: ReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reviews.
     */
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }

  /**
   * Review findMany
   */
  export type ReviewFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter, which Reviews to fetch.
     */
    where?: ReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reviews to fetch.
     */
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Reviews.
     */
    cursor?: ReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reviews.
     */
    skip?: number
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }

  /**
   * Review create
   */
  export type ReviewCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * The data needed to create a Review.
     */
    data: XOR<ReviewCreateInput, ReviewUncheckedCreateInput>
  }

  /**
   * Review createMany
   */
  export type ReviewCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Reviews.
     */
    data: ReviewCreateManyInput | ReviewCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Review createManyAndReturn
   */
  export type ReviewCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * The data used to create many Reviews.
     */
    data: ReviewCreateManyInput | ReviewCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Review update
   */
  export type ReviewUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * The data needed to update a Review.
     */
    data: XOR<ReviewUpdateInput, ReviewUncheckedUpdateInput>
    /**
     * Choose, which Review to update.
     */
    where: ReviewWhereUniqueInput
  }

  /**
   * Review updateMany
   */
  export type ReviewUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Reviews.
     */
    data: XOR<ReviewUpdateManyMutationInput, ReviewUncheckedUpdateManyInput>
    /**
     * Filter which Reviews to update
     */
    where?: ReviewWhereInput
    /**
     * Limit how many Reviews to update.
     */
    limit?: number
  }

  /**
   * Review updateManyAndReturn
   */
  export type ReviewUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * The data used to update Reviews.
     */
    data: XOR<ReviewUpdateManyMutationInput, ReviewUncheckedUpdateManyInput>
    /**
     * Filter which Reviews to update
     */
    where?: ReviewWhereInput
    /**
     * Limit how many Reviews to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Review upsert
   */
  export type ReviewUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * The filter to search for the Review to update in case it exists.
     */
    where: ReviewWhereUniqueInput
    /**
     * In case the Review found by the `where` argument doesn't exist, create a new Review with this data.
     */
    create: XOR<ReviewCreateInput, ReviewUncheckedCreateInput>
    /**
     * In case the Review was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReviewUpdateInput, ReviewUncheckedUpdateInput>
  }

  /**
   * Review delete
   */
  export type ReviewDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter which Review to delete.
     */
    where: ReviewWhereUniqueInput
  }

  /**
   * Review deleteMany
   */
  export type ReviewDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Reviews to delete
     */
    where?: ReviewWhereInput
    /**
     * Limit how many Reviews to delete.
     */
    limit?: number
  }

  /**
   * Review without action
   */
  export type ReviewDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
  }


  /**
   * Model Receipt
   */

  export type AggregateReceipt = {
    _count: ReceiptCountAggregateOutputType | null
    _avg: ReceiptAvgAggregateOutputType | null
    _sum: ReceiptSumAggregateOutputType | null
    _min: ReceiptMinAggregateOutputType | null
    _max: ReceiptMaxAggregateOutputType | null
  }

  export type ReceiptAvgAggregateOutputType = {
    totalOriginal: number | null
    totalChanges: number | null
    totalFinal: number | null
  }

  export type ReceiptSumAggregateOutputType = {
    totalOriginal: number | null
    totalChanges: number | null
    totalFinal: number | null
  }

  export type ReceiptMinAggregateOutputType = {
    id: string | null
    workOrderId: string | null
    totalOriginal: number | null
    totalChanges: number | null
    totalFinal: number | null
    pdfUrl: string | null
    createdAt: Date | null
  }

  export type ReceiptMaxAggregateOutputType = {
    id: string | null
    workOrderId: string | null
    totalOriginal: number | null
    totalChanges: number | null
    totalFinal: number | null
    pdfUrl: string | null
    createdAt: Date | null
  }

  export type ReceiptCountAggregateOutputType = {
    id: number
    workOrderId: number
    totalOriginal: number
    totalChanges: number
    totalFinal: number
    pdfUrl: number
    createdAt: number
    _all: number
  }


  export type ReceiptAvgAggregateInputType = {
    totalOriginal?: true
    totalChanges?: true
    totalFinal?: true
  }

  export type ReceiptSumAggregateInputType = {
    totalOriginal?: true
    totalChanges?: true
    totalFinal?: true
  }

  export type ReceiptMinAggregateInputType = {
    id?: true
    workOrderId?: true
    totalOriginal?: true
    totalChanges?: true
    totalFinal?: true
    pdfUrl?: true
    createdAt?: true
  }

  export type ReceiptMaxAggregateInputType = {
    id?: true
    workOrderId?: true
    totalOriginal?: true
    totalChanges?: true
    totalFinal?: true
    pdfUrl?: true
    createdAt?: true
  }

  export type ReceiptCountAggregateInputType = {
    id?: true
    workOrderId?: true
    totalOriginal?: true
    totalChanges?: true
    totalFinal?: true
    pdfUrl?: true
    createdAt?: true
    _all?: true
  }

  export type ReceiptAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Receipt to aggregate.
     */
    where?: ReceiptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Receipts to fetch.
     */
    orderBy?: ReceiptOrderByWithRelationInput | ReceiptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReceiptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Receipts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Receipts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Receipts
    **/
    _count?: true | ReceiptCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReceiptAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReceiptSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReceiptMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReceiptMaxAggregateInputType
  }

  export type GetReceiptAggregateType<T extends ReceiptAggregateArgs> = {
        [P in keyof T & keyof AggregateReceipt]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReceipt[P]>
      : GetScalarType<T[P], AggregateReceipt[P]>
  }




  export type ReceiptGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReceiptWhereInput
    orderBy?: ReceiptOrderByWithAggregationInput | ReceiptOrderByWithAggregationInput[]
    by: ReceiptScalarFieldEnum[] | ReceiptScalarFieldEnum
    having?: ReceiptScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReceiptCountAggregateInputType | true
    _avg?: ReceiptAvgAggregateInputType
    _sum?: ReceiptSumAggregateInputType
    _min?: ReceiptMinAggregateInputType
    _max?: ReceiptMaxAggregateInputType
  }

  export type ReceiptGroupByOutputType = {
    id: string
    workOrderId: string
    totalOriginal: number
    totalChanges: number
    totalFinal: number
    pdfUrl: string | null
    createdAt: Date
    _count: ReceiptCountAggregateOutputType | null
    _avg: ReceiptAvgAggregateOutputType | null
    _sum: ReceiptSumAggregateOutputType | null
    _min: ReceiptMinAggregateOutputType | null
    _max: ReceiptMaxAggregateOutputType | null
  }

  type GetReceiptGroupByPayload<T extends ReceiptGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReceiptGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReceiptGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReceiptGroupByOutputType[P]>
            : GetScalarType<T[P], ReceiptGroupByOutputType[P]>
        }
      >
    >


  export type ReceiptSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workOrderId?: boolean
    totalOriginal?: boolean
    totalChanges?: boolean
    totalFinal?: boolean
    pdfUrl?: boolean
    createdAt?: boolean
    workOrder?: boolean | WorkOrderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["receipt"]>

  export type ReceiptSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workOrderId?: boolean
    totalOriginal?: boolean
    totalChanges?: boolean
    totalFinal?: boolean
    pdfUrl?: boolean
    createdAt?: boolean
    workOrder?: boolean | WorkOrderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["receipt"]>

  export type ReceiptSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workOrderId?: boolean
    totalOriginal?: boolean
    totalChanges?: boolean
    totalFinal?: boolean
    pdfUrl?: boolean
    createdAt?: boolean
    workOrder?: boolean | WorkOrderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["receipt"]>

  export type ReceiptSelectScalar = {
    id?: boolean
    workOrderId?: boolean
    totalOriginal?: boolean
    totalChanges?: boolean
    totalFinal?: boolean
    pdfUrl?: boolean
    createdAt?: boolean
  }

  export type ReceiptOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "workOrderId" | "totalOriginal" | "totalChanges" | "totalFinal" | "pdfUrl" | "createdAt", ExtArgs["result"]["receipt"]>
  export type ReceiptInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workOrder?: boolean | WorkOrderDefaultArgs<ExtArgs>
  }
  export type ReceiptIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workOrder?: boolean | WorkOrderDefaultArgs<ExtArgs>
  }
  export type ReceiptIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workOrder?: boolean | WorkOrderDefaultArgs<ExtArgs>
  }

  export type $ReceiptPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Receipt"
    objects: {
      workOrder: Prisma.$WorkOrderPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      workOrderId: string
      totalOriginal: number
      totalChanges: number
      totalFinal: number
      pdfUrl: string | null
      createdAt: Date
    }, ExtArgs["result"]["receipt"]>
    composites: {}
  }

  type ReceiptGetPayload<S extends boolean | null | undefined | ReceiptDefaultArgs> = $Result.GetResult<Prisma.$ReceiptPayload, S>

  type ReceiptCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ReceiptFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ReceiptCountAggregateInputType | true
    }

  export interface ReceiptDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Receipt'], meta: { name: 'Receipt' } }
    /**
     * Find zero or one Receipt that matches the filter.
     * @param {ReceiptFindUniqueArgs} args - Arguments to find a Receipt
     * @example
     * // Get one Receipt
     * const receipt = await prisma.receipt.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReceiptFindUniqueArgs>(args: SelectSubset<T, ReceiptFindUniqueArgs<ExtArgs>>): Prisma__ReceiptClient<$Result.GetResult<Prisma.$ReceiptPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Receipt that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ReceiptFindUniqueOrThrowArgs} args - Arguments to find a Receipt
     * @example
     * // Get one Receipt
     * const receipt = await prisma.receipt.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReceiptFindUniqueOrThrowArgs>(args: SelectSubset<T, ReceiptFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReceiptClient<$Result.GetResult<Prisma.$ReceiptPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Receipt that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReceiptFindFirstArgs} args - Arguments to find a Receipt
     * @example
     * // Get one Receipt
     * const receipt = await prisma.receipt.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReceiptFindFirstArgs>(args?: SelectSubset<T, ReceiptFindFirstArgs<ExtArgs>>): Prisma__ReceiptClient<$Result.GetResult<Prisma.$ReceiptPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Receipt that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReceiptFindFirstOrThrowArgs} args - Arguments to find a Receipt
     * @example
     * // Get one Receipt
     * const receipt = await prisma.receipt.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReceiptFindFirstOrThrowArgs>(args?: SelectSubset<T, ReceiptFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReceiptClient<$Result.GetResult<Prisma.$ReceiptPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Receipts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReceiptFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Receipts
     * const receipts = await prisma.receipt.findMany()
     * 
     * // Get first 10 Receipts
     * const receipts = await prisma.receipt.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const receiptWithIdOnly = await prisma.receipt.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ReceiptFindManyArgs>(args?: SelectSubset<T, ReceiptFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReceiptPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Receipt.
     * @param {ReceiptCreateArgs} args - Arguments to create a Receipt.
     * @example
     * // Create one Receipt
     * const Receipt = await prisma.receipt.create({
     *   data: {
     *     // ... data to create a Receipt
     *   }
     * })
     * 
     */
    create<T extends ReceiptCreateArgs>(args: SelectSubset<T, ReceiptCreateArgs<ExtArgs>>): Prisma__ReceiptClient<$Result.GetResult<Prisma.$ReceiptPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Receipts.
     * @param {ReceiptCreateManyArgs} args - Arguments to create many Receipts.
     * @example
     * // Create many Receipts
     * const receipt = await prisma.receipt.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReceiptCreateManyArgs>(args?: SelectSubset<T, ReceiptCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Receipts and returns the data saved in the database.
     * @param {ReceiptCreateManyAndReturnArgs} args - Arguments to create many Receipts.
     * @example
     * // Create many Receipts
     * const receipt = await prisma.receipt.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Receipts and only return the `id`
     * const receiptWithIdOnly = await prisma.receipt.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ReceiptCreateManyAndReturnArgs>(args?: SelectSubset<T, ReceiptCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReceiptPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Receipt.
     * @param {ReceiptDeleteArgs} args - Arguments to delete one Receipt.
     * @example
     * // Delete one Receipt
     * const Receipt = await prisma.receipt.delete({
     *   where: {
     *     // ... filter to delete one Receipt
     *   }
     * })
     * 
     */
    delete<T extends ReceiptDeleteArgs>(args: SelectSubset<T, ReceiptDeleteArgs<ExtArgs>>): Prisma__ReceiptClient<$Result.GetResult<Prisma.$ReceiptPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Receipt.
     * @param {ReceiptUpdateArgs} args - Arguments to update one Receipt.
     * @example
     * // Update one Receipt
     * const receipt = await prisma.receipt.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReceiptUpdateArgs>(args: SelectSubset<T, ReceiptUpdateArgs<ExtArgs>>): Prisma__ReceiptClient<$Result.GetResult<Prisma.$ReceiptPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Receipts.
     * @param {ReceiptDeleteManyArgs} args - Arguments to filter Receipts to delete.
     * @example
     * // Delete a few Receipts
     * const { count } = await prisma.receipt.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReceiptDeleteManyArgs>(args?: SelectSubset<T, ReceiptDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Receipts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReceiptUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Receipts
     * const receipt = await prisma.receipt.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReceiptUpdateManyArgs>(args: SelectSubset<T, ReceiptUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Receipts and returns the data updated in the database.
     * @param {ReceiptUpdateManyAndReturnArgs} args - Arguments to update many Receipts.
     * @example
     * // Update many Receipts
     * const receipt = await prisma.receipt.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Receipts and only return the `id`
     * const receiptWithIdOnly = await prisma.receipt.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ReceiptUpdateManyAndReturnArgs>(args: SelectSubset<T, ReceiptUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReceiptPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Receipt.
     * @param {ReceiptUpsertArgs} args - Arguments to update or create a Receipt.
     * @example
     * // Update or create a Receipt
     * const receipt = await prisma.receipt.upsert({
     *   create: {
     *     // ... data to create a Receipt
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Receipt we want to update
     *   }
     * })
     */
    upsert<T extends ReceiptUpsertArgs>(args: SelectSubset<T, ReceiptUpsertArgs<ExtArgs>>): Prisma__ReceiptClient<$Result.GetResult<Prisma.$ReceiptPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Receipts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReceiptCountArgs} args - Arguments to filter Receipts to count.
     * @example
     * // Count the number of Receipts
     * const count = await prisma.receipt.count({
     *   where: {
     *     // ... the filter for the Receipts we want to count
     *   }
     * })
    **/
    count<T extends ReceiptCountArgs>(
      args?: Subset<T, ReceiptCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReceiptCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Receipt.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReceiptAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReceiptAggregateArgs>(args: Subset<T, ReceiptAggregateArgs>): Prisma.PrismaPromise<GetReceiptAggregateType<T>>

    /**
     * Group by Receipt.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReceiptGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReceiptGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReceiptGroupByArgs['orderBy'] }
        : { orderBy?: ReceiptGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReceiptGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReceiptGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Receipt model
   */
  readonly fields: ReceiptFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Receipt.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReceiptClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    workOrder<T extends WorkOrderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WorkOrderDefaultArgs<ExtArgs>>): Prisma__WorkOrderClient<$Result.GetResult<Prisma.$WorkOrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Receipt model
   */
  interface ReceiptFieldRefs {
    readonly id: FieldRef<"Receipt", 'String'>
    readonly workOrderId: FieldRef<"Receipt", 'String'>
    readonly totalOriginal: FieldRef<"Receipt", 'Float'>
    readonly totalChanges: FieldRef<"Receipt", 'Float'>
    readonly totalFinal: FieldRef<"Receipt", 'Float'>
    readonly pdfUrl: FieldRef<"Receipt", 'String'>
    readonly createdAt: FieldRef<"Receipt", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Receipt findUnique
   */
  export type ReceiptFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Receipt
     */
    select?: ReceiptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Receipt
     */
    omit?: ReceiptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReceiptInclude<ExtArgs> | null
    /**
     * Filter, which Receipt to fetch.
     */
    where: ReceiptWhereUniqueInput
  }

  /**
   * Receipt findUniqueOrThrow
   */
  export type ReceiptFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Receipt
     */
    select?: ReceiptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Receipt
     */
    omit?: ReceiptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReceiptInclude<ExtArgs> | null
    /**
     * Filter, which Receipt to fetch.
     */
    where: ReceiptWhereUniqueInput
  }

  /**
   * Receipt findFirst
   */
  export type ReceiptFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Receipt
     */
    select?: ReceiptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Receipt
     */
    omit?: ReceiptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReceiptInclude<ExtArgs> | null
    /**
     * Filter, which Receipt to fetch.
     */
    where?: ReceiptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Receipts to fetch.
     */
    orderBy?: ReceiptOrderByWithRelationInput | ReceiptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Receipts.
     */
    cursor?: ReceiptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Receipts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Receipts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Receipts.
     */
    distinct?: ReceiptScalarFieldEnum | ReceiptScalarFieldEnum[]
  }

  /**
   * Receipt findFirstOrThrow
   */
  export type ReceiptFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Receipt
     */
    select?: ReceiptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Receipt
     */
    omit?: ReceiptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReceiptInclude<ExtArgs> | null
    /**
     * Filter, which Receipt to fetch.
     */
    where?: ReceiptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Receipts to fetch.
     */
    orderBy?: ReceiptOrderByWithRelationInput | ReceiptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Receipts.
     */
    cursor?: ReceiptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Receipts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Receipts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Receipts.
     */
    distinct?: ReceiptScalarFieldEnum | ReceiptScalarFieldEnum[]
  }

  /**
   * Receipt findMany
   */
  export type ReceiptFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Receipt
     */
    select?: ReceiptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Receipt
     */
    omit?: ReceiptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReceiptInclude<ExtArgs> | null
    /**
     * Filter, which Receipts to fetch.
     */
    where?: ReceiptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Receipts to fetch.
     */
    orderBy?: ReceiptOrderByWithRelationInput | ReceiptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Receipts.
     */
    cursor?: ReceiptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Receipts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Receipts.
     */
    skip?: number
    distinct?: ReceiptScalarFieldEnum | ReceiptScalarFieldEnum[]
  }

  /**
   * Receipt create
   */
  export type ReceiptCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Receipt
     */
    select?: ReceiptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Receipt
     */
    omit?: ReceiptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReceiptInclude<ExtArgs> | null
    /**
     * The data needed to create a Receipt.
     */
    data: XOR<ReceiptCreateInput, ReceiptUncheckedCreateInput>
  }

  /**
   * Receipt createMany
   */
  export type ReceiptCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Receipts.
     */
    data: ReceiptCreateManyInput | ReceiptCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Receipt createManyAndReturn
   */
  export type ReceiptCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Receipt
     */
    select?: ReceiptSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Receipt
     */
    omit?: ReceiptOmit<ExtArgs> | null
    /**
     * The data used to create many Receipts.
     */
    data: ReceiptCreateManyInput | ReceiptCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReceiptIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Receipt update
   */
  export type ReceiptUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Receipt
     */
    select?: ReceiptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Receipt
     */
    omit?: ReceiptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReceiptInclude<ExtArgs> | null
    /**
     * The data needed to update a Receipt.
     */
    data: XOR<ReceiptUpdateInput, ReceiptUncheckedUpdateInput>
    /**
     * Choose, which Receipt to update.
     */
    where: ReceiptWhereUniqueInput
  }

  /**
   * Receipt updateMany
   */
  export type ReceiptUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Receipts.
     */
    data: XOR<ReceiptUpdateManyMutationInput, ReceiptUncheckedUpdateManyInput>
    /**
     * Filter which Receipts to update
     */
    where?: ReceiptWhereInput
    /**
     * Limit how many Receipts to update.
     */
    limit?: number
  }

  /**
   * Receipt updateManyAndReturn
   */
  export type ReceiptUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Receipt
     */
    select?: ReceiptSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Receipt
     */
    omit?: ReceiptOmit<ExtArgs> | null
    /**
     * The data used to update Receipts.
     */
    data: XOR<ReceiptUpdateManyMutationInput, ReceiptUncheckedUpdateManyInput>
    /**
     * Filter which Receipts to update
     */
    where?: ReceiptWhereInput
    /**
     * Limit how many Receipts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReceiptIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Receipt upsert
   */
  export type ReceiptUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Receipt
     */
    select?: ReceiptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Receipt
     */
    omit?: ReceiptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReceiptInclude<ExtArgs> | null
    /**
     * The filter to search for the Receipt to update in case it exists.
     */
    where: ReceiptWhereUniqueInput
    /**
     * In case the Receipt found by the `where` argument doesn't exist, create a new Receipt with this data.
     */
    create: XOR<ReceiptCreateInput, ReceiptUncheckedCreateInput>
    /**
     * In case the Receipt was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReceiptUpdateInput, ReceiptUncheckedUpdateInput>
  }

  /**
   * Receipt delete
   */
  export type ReceiptDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Receipt
     */
    select?: ReceiptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Receipt
     */
    omit?: ReceiptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReceiptInclude<ExtArgs> | null
    /**
     * Filter which Receipt to delete.
     */
    where: ReceiptWhereUniqueInput
  }

  /**
   * Receipt deleteMany
   */
  export type ReceiptDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Receipts to delete
     */
    where?: ReceiptWhereInput
    /**
     * Limit how many Receipts to delete.
     */
    limit?: number
  }

  /**
   * Receipt without action
   */
  export type ReceiptDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Receipt
     */
    select?: ReceiptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Receipt
     */
    omit?: ReceiptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReceiptInclude<ExtArgs> | null
  }


  /**
   * Model IncidentReport
   */

  export type AggregateIncidentReport = {
    _count: IncidentReportCountAggregateOutputType | null
    _min: IncidentReportMinAggregateOutputType | null
    _max: IncidentReportMaxAggregateOutputType | null
  }

  export type IncidentReportMinAggregateOutputType = {
    id: string | null
    reporterId: string | null
    workshopId: string | null
    type: $Enums.IncidentType | null
    description: string | null
    evidenceUrl: string | null
    status: $Enums.IncidentStatus | null
    resolution: string | null
    resolvedAt: Date | null
    resolvedBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type IncidentReportMaxAggregateOutputType = {
    id: string | null
    reporterId: string | null
    workshopId: string | null
    type: $Enums.IncidentType | null
    description: string | null
    evidenceUrl: string | null
    status: $Enums.IncidentStatus | null
    resolution: string | null
    resolvedAt: Date | null
    resolvedBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type IncidentReportCountAggregateOutputType = {
    id: number
    reporterId: number
    workshopId: number
    type: number
    description: number
    evidenceUrl: number
    status: number
    resolution: number
    resolvedAt: number
    resolvedBy: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type IncidentReportMinAggregateInputType = {
    id?: true
    reporterId?: true
    workshopId?: true
    type?: true
    description?: true
    evidenceUrl?: true
    status?: true
    resolution?: true
    resolvedAt?: true
    resolvedBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type IncidentReportMaxAggregateInputType = {
    id?: true
    reporterId?: true
    workshopId?: true
    type?: true
    description?: true
    evidenceUrl?: true
    status?: true
    resolution?: true
    resolvedAt?: true
    resolvedBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type IncidentReportCountAggregateInputType = {
    id?: true
    reporterId?: true
    workshopId?: true
    type?: true
    description?: true
    evidenceUrl?: true
    status?: true
    resolution?: true
    resolvedAt?: true
    resolvedBy?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type IncidentReportAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which IncidentReport to aggregate.
     */
    where?: IncidentReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IncidentReports to fetch.
     */
    orderBy?: IncidentReportOrderByWithRelationInput | IncidentReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: IncidentReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IncidentReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IncidentReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned IncidentReports
    **/
    _count?: true | IncidentReportCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: IncidentReportMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: IncidentReportMaxAggregateInputType
  }

  export type GetIncidentReportAggregateType<T extends IncidentReportAggregateArgs> = {
        [P in keyof T & keyof AggregateIncidentReport]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIncidentReport[P]>
      : GetScalarType<T[P], AggregateIncidentReport[P]>
  }




  export type IncidentReportGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IncidentReportWhereInput
    orderBy?: IncidentReportOrderByWithAggregationInput | IncidentReportOrderByWithAggregationInput[]
    by: IncidentReportScalarFieldEnum[] | IncidentReportScalarFieldEnum
    having?: IncidentReportScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: IncidentReportCountAggregateInputType | true
    _min?: IncidentReportMinAggregateInputType
    _max?: IncidentReportMaxAggregateInputType
  }

  export type IncidentReportGroupByOutputType = {
    id: string
    reporterId: string
    workshopId: string
    type: $Enums.IncidentType
    description: string
    evidenceUrl: string | null
    status: $Enums.IncidentStatus
    resolution: string | null
    resolvedAt: Date | null
    resolvedBy: string | null
    createdAt: Date
    updatedAt: Date
    _count: IncidentReportCountAggregateOutputType | null
    _min: IncidentReportMinAggregateOutputType | null
    _max: IncidentReportMaxAggregateOutputType | null
  }

  type GetIncidentReportGroupByPayload<T extends IncidentReportGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<IncidentReportGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof IncidentReportGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], IncidentReportGroupByOutputType[P]>
            : GetScalarType<T[P], IncidentReportGroupByOutputType[P]>
        }
      >
    >


  export type IncidentReportSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    reporterId?: boolean
    workshopId?: boolean
    type?: boolean
    description?: boolean
    evidenceUrl?: boolean
    status?: boolean
    resolution?: boolean
    resolvedAt?: boolean
    resolvedBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    reporter?: boolean | UserProfileDefaultArgs<ExtArgs>
    workshop?: boolean | WorkshopDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["incidentReport"]>

  export type IncidentReportSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    reporterId?: boolean
    workshopId?: boolean
    type?: boolean
    description?: boolean
    evidenceUrl?: boolean
    status?: boolean
    resolution?: boolean
    resolvedAt?: boolean
    resolvedBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    reporter?: boolean | UserProfileDefaultArgs<ExtArgs>
    workshop?: boolean | WorkshopDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["incidentReport"]>

  export type IncidentReportSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    reporterId?: boolean
    workshopId?: boolean
    type?: boolean
    description?: boolean
    evidenceUrl?: boolean
    status?: boolean
    resolution?: boolean
    resolvedAt?: boolean
    resolvedBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    reporter?: boolean | UserProfileDefaultArgs<ExtArgs>
    workshop?: boolean | WorkshopDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["incidentReport"]>

  export type IncidentReportSelectScalar = {
    id?: boolean
    reporterId?: boolean
    workshopId?: boolean
    type?: boolean
    description?: boolean
    evidenceUrl?: boolean
    status?: boolean
    resolution?: boolean
    resolvedAt?: boolean
    resolvedBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type IncidentReportOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "reporterId" | "workshopId" | "type" | "description" | "evidenceUrl" | "status" | "resolution" | "resolvedAt" | "resolvedBy" | "createdAt" | "updatedAt", ExtArgs["result"]["incidentReport"]>
  export type IncidentReportInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    reporter?: boolean | UserProfileDefaultArgs<ExtArgs>
    workshop?: boolean | WorkshopDefaultArgs<ExtArgs>
  }
  export type IncidentReportIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    reporter?: boolean | UserProfileDefaultArgs<ExtArgs>
    workshop?: boolean | WorkshopDefaultArgs<ExtArgs>
  }
  export type IncidentReportIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    reporter?: boolean | UserProfileDefaultArgs<ExtArgs>
    workshop?: boolean | WorkshopDefaultArgs<ExtArgs>
  }

  export type $IncidentReportPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "IncidentReport"
    objects: {
      reporter: Prisma.$UserProfilePayload<ExtArgs>
      workshop: Prisma.$WorkshopPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      reporterId: string
      workshopId: string
      type: $Enums.IncidentType
      description: string
      evidenceUrl: string | null
      status: $Enums.IncidentStatus
      resolution: string | null
      resolvedAt: Date | null
      resolvedBy: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["incidentReport"]>
    composites: {}
  }

  type IncidentReportGetPayload<S extends boolean | null | undefined | IncidentReportDefaultArgs> = $Result.GetResult<Prisma.$IncidentReportPayload, S>

  type IncidentReportCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<IncidentReportFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: IncidentReportCountAggregateInputType | true
    }

  export interface IncidentReportDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['IncidentReport'], meta: { name: 'IncidentReport' } }
    /**
     * Find zero or one IncidentReport that matches the filter.
     * @param {IncidentReportFindUniqueArgs} args - Arguments to find a IncidentReport
     * @example
     * // Get one IncidentReport
     * const incidentReport = await prisma.incidentReport.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends IncidentReportFindUniqueArgs>(args: SelectSubset<T, IncidentReportFindUniqueArgs<ExtArgs>>): Prisma__IncidentReportClient<$Result.GetResult<Prisma.$IncidentReportPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one IncidentReport that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {IncidentReportFindUniqueOrThrowArgs} args - Arguments to find a IncidentReport
     * @example
     * // Get one IncidentReport
     * const incidentReport = await prisma.incidentReport.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends IncidentReportFindUniqueOrThrowArgs>(args: SelectSubset<T, IncidentReportFindUniqueOrThrowArgs<ExtArgs>>): Prisma__IncidentReportClient<$Result.GetResult<Prisma.$IncidentReportPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first IncidentReport that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncidentReportFindFirstArgs} args - Arguments to find a IncidentReport
     * @example
     * // Get one IncidentReport
     * const incidentReport = await prisma.incidentReport.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends IncidentReportFindFirstArgs>(args?: SelectSubset<T, IncidentReportFindFirstArgs<ExtArgs>>): Prisma__IncidentReportClient<$Result.GetResult<Prisma.$IncidentReportPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first IncidentReport that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncidentReportFindFirstOrThrowArgs} args - Arguments to find a IncidentReport
     * @example
     * // Get one IncidentReport
     * const incidentReport = await prisma.incidentReport.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends IncidentReportFindFirstOrThrowArgs>(args?: SelectSubset<T, IncidentReportFindFirstOrThrowArgs<ExtArgs>>): Prisma__IncidentReportClient<$Result.GetResult<Prisma.$IncidentReportPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more IncidentReports that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncidentReportFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all IncidentReports
     * const incidentReports = await prisma.incidentReport.findMany()
     * 
     * // Get first 10 IncidentReports
     * const incidentReports = await prisma.incidentReport.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const incidentReportWithIdOnly = await prisma.incidentReport.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends IncidentReportFindManyArgs>(args?: SelectSubset<T, IncidentReportFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IncidentReportPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a IncidentReport.
     * @param {IncidentReportCreateArgs} args - Arguments to create a IncidentReport.
     * @example
     * // Create one IncidentReport
     * const IncidentReport = await prisma.incidentReport.create({
     *   data: {
     *     // ... data to create a IncidentReport
     *   }
     * })
     * 
     */
    create<T extends IncidentReportCreateArgs>(args: SelectSubset<T, IncidentReportCreateArgs<ExtArgs>>): Prisma__IncidentReportClient<$Result.GetResult<Prisma.$IncidentReportPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many IncidentReports.
     * @param {IncidentReportCreateManyArgs} args - Arguments to create many IncidentReports.
     * @example
     * // Create many IncidentReports
     * const incidentReport = await prisma.incidentReport.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends IncidentReportCreateManyArgs>(args?: SelectSubset<T, IncidentReportCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many IncidentReports and returns the data saved in the database.
     * @param {IncidentReportCreateManyAndReturnArgs} args - Arguments to create many IncidentReports.
     * @example
     * // Create many IncidentReports
     * const incidentReport = await prisma.incidentReport.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many IncidentReports and only return the `id`
     * const incidentReportWithIdOnly = await prisma.incidentReport.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends IncidentReportCreateManyAndReturnArgs>(args?: SelectSubset<T, IncidentReportCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IncidentReportPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a IncidentReport.
     * @param {IncidentReportDeleteArgs} args - Arguments to delete one IncidentReport.
     * @example
     * // Delete one IncidentReport
     * const IncidentReport = await prisma.incidentReport.delete({
     *   where: {
     *     // ... filter to delete one IncidentReport
     *   }
     * })
     * 
     */
    delete<T extends IncidentReportDeleteArgs>(args: SelectSubset<T, IncidentReportDeleteArgs<ExtArgs>>): Prisma__IncidentReportClient<$Result.GetResult<Prisma.$IncidentReportPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one IncidentReport.
     * @param {IncidentReportUpdateArgs} args - Arguments to update one IncidentReport.
     * @example
     * // Update one IncidentReport
     * const incidentReport = await prisma.incidentReport.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends IncidentReportUpdateArgs>(args: SelectSubset<T, IncidentReportUpdateArgs<ExtArgs>>): Prisma__IncidentReportClient<$Result.GetResult<Prisma.$IncidentReportPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more IncidentReports.
     * @param {IncidentReportDeleteManyArgs} args - Arguments to filter IncidentReports to delete.
     * @example
     * // Delete a few IncidentReports
     * const { count } = await prisma.incidentReport.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends IncidentReportDeleteManyArgs>(args?: SelectSubset<T, IncidentReportDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more IncidentReports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncidentReportUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many IncidentReports
     * const incidentReport = await prisma.incidentReport.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends IncidentReportUpdateManyArgs>(args: SelectSubset<T, IncidentReportUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more IncidentReports and returns the data updated in the database.
     * @param {IncidentReportUpdateManyAndReturnArgs} args - Arguments to update many IncidentReports.
     * @example
     * // Update many IncidentReports
     * const incidentReport = await prisma.incidentReport.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more IncidentReports and only return the `id`
     * const incidentReportWithIdOnly = await prisma.incidentReport.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends IncidentReportUpdateManyAndReturnArgs>(args: SelectSubset<T, IncidentReportUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IncidentReportPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one IncidentReport.
     * @param {IncidentReportUpsertArgs} args - Arguments to update or create a IncidentReport.
     * @example
     * // Update or create a IncidentReport
     * const incidentReport = await prisma.incidentReport.upsert({
     *   create: {
     *     // ... data to create a IncidentReport
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the IncidentReport we want to update
     *   }
     * })
     */
    upsert<T extends IncidentReportUpsertArgs>(args: SelectSubset<T, IncidentReportUpsertArgs<ExtArgs>>): Prisma__IncidentReportClient<$Result.GetResult<Prisma.$IncidentReportPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of IncidentReports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncidentReportCountArgs} args - Arguments to filter IncidentReports to count.
     * @example
     * // Count the number of IncidentReports
     * const count = await prisma.incidentReport.count({
     *   where: {
     *     // ... the filter for the IncidentReports we want to count
     *   }
     * })
    **/
    count<T extends IncidentReportCountArgs>(
      args?: Subset<T, IncidentReportCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], IncidentReportCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a IncidentReport.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncidentReportAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends IncidentReportAggregateArgs>(args: Subset<T, IncidentReportAggregateArgs>): Prisma.PrismaPromise<GetIncidentReportAggregateType<T>>

    /**
     * Group by IncidentReport.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncidentReportGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends IncidentReportGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: IncidentReportGroupByArgs['orderBy'] }
        : { orderBy?: IncidentReportGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, IncidentReportGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIncidentReportGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the IncidentReport model
   */
  readonly fields: IncidentReportFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for IncidentReport.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__IncidentReportClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    reporter<T extends UserProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserProfileDefaultArgs<ExtArgs>>): Prisma__UserProfileClient<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    workshop<T extends WorkshopDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WorkshopDefaultArgs<ExtArgs>>): Prisma__WorkshopClient<$Result.GetResult<Prisma.$WorkshopPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the IncidentReport model
   */
  interface IncidentReportFieldRefs {
    readonly id: FieldRef<"IncidentReport", 'String'>
    readonly reporterId: FieldRef<"IncidentReport", 'String'>
    readonly workshopId: FieldRef<"IncidentReport", 'String'>
    readonly type: FieldRef<"IncidentReport", 'IncidentType'>
    readonly description: FieldRef<"IncidentReport", 'String'>
    readonly evidenceUrl: FieldRef<"IncidentReport", 'String'>
    readonly status: FieldRef<"IncidentReport", 'IncidentStatus'>
    readonly resolution: FieldRef<"IncidentReport", 'String'>
    readonly resolvedAt: FieldRef<"IncidentReport", 'DateTime'>
    readonly resolvedBy: FieldRef<"IncidentReport", 'String'>
    readonly createdAt: FieldRef<"IncidentReport", 'DateTime'>
    readonly updatedAt: FieldRef<"IncidentReport", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * IncidentReport findUnique
   */
  export type IncidentReportFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IncidentReport
     */
    select?: IncidentReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IncidentReport
     */
    omit?: IncidentReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidentReportInclude<ExtArgs> | null
    /**
     * Filter, which IncidentReport to fetch.
     */
    where: IncidentReportWhereUniqueInput
  }

  /**
   * IncidentReport findUniqueOrThrow
   */
  export type IncidentReportFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IncidentReport
     */
    select?: IncidentReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IncidentReport
     */
    omit?: IncidentReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidentReportInclude<ExtArgs> | null
    /**
     * Filter, which IncidentReport to fetch.
     */
    where: IncidentReportWhereUniqueInput
  }

  /**
   * IncidentReport findFirst
   */
  export type IncidentReportFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IncidentReport
     */
    select?: IncidentReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IncidentReport
     */
    omit?: IncidentReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidentReportInclude<ExtArgs> | null
    /**
     * Filter, which IncidentReport to fetch.
     */
    where?: IncidentReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IncidentReports to fetch.
     */
    orderBy?: IncidentReportOrderByWithRelationInput | IncidentReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for IncidentReports.
     */
    cursor?: IncidentReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IncidentReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IncidentReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of IncidentReports.
     */
    distinct?: IncidentReportScalarFieldEnum | IncidentReportScalarFieldEnum[]
  }

  /**
   * IncidentReport findFirstOrThrow
   */
  export type IncidentReportFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IncidentReport
     */
    select?: IncidentReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IncidentReport
     */
    omit?: IncidentReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidentReportInclude<ExtArgs> | null
    /**
     * Filter, which IncidentReport to fetch.
     */
    where?: IncidentReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IncidentReports to fetch.
     */
    orderBy?: IncidentReportOrderByWithRelationInput | IncidentReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for IncidentReports.
     */
    cursor?: IncidentReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IncidentReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IncidentReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of IncidentReports.
     */
    distinct?: IncidentReportScalarFieldEnum | IncidentReportScalarFieldEnum[]
  }

  /**
   * IncidentReport findMany
   */
  export type IncidentReportFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IncidentReport
     */
    select?: IncidentReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IncidentReport
     */
    omit?: IncidentReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidentReportInclude<ExtArgs> | null
    /**
     * Filter, which IncidentReports to fetch.
     */
    where?: IncidentReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IncidentReports to fetch.
     */
    orderBy?: IncidentReportOrderByWithRelationInput | IncidentReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing IncidentReports.
     */
    cursor?: IncidentReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IncidentReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IncidentReports.
     */
    skip?: number
    distinct?: IncidentReportScalarFieldEnum | IncidentReportScalarFieldEnum[]
  }

  /**
   * IncidentReport create
   */
  export type IncidentReportCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IncidentReport
     */
    select?: IncidentReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IncidentReport
     */
    omit?: IncidentReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidentReportInclude<ExtArgs> | null
    /**
     * The data needed to create a IncidentReport.
     */
    data: XOR<IncidentReportCreateInput, IncidentReportUncheckedCreateInput>
  }

  /**
   * IncidentReport createMany
   */
  export type IncidentReportCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many IncidentReports.
     */
    data: IncidentReportCreateManyInput | IncidentReportCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * IncidentReport createManyAndReturn
   */
  export type IncidentReportCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IncidentReport
     */
    select?: IncidentReportSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the IncidentReport
     */
    omit?: IncidentReportOmit<ExtArgs> | null
    /**
     * The data used to create many IncidentReports.
     */
    data: IncidentReportCreateManyInput | IncidentReportCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidentReportIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * IncidentReport update
   */
  export type IncidentReportUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IncidentReport
     */
    select?: IncidentReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IncidentReport
     */
    omit?: IncidentReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidentReportInclude<ExtArgs> | null
    /**
     * The data needed to update a IncidentReport.
     */
    data: XOR<IncidentReportUpdateInput, IncidentReportUncheckedUpdateInput>
    /**
     * Choose, which IncidentReport to update.
     */
    where: IncidentReportWhereUniqueInput
  }

  /**
   * IncidentReport updateMany
   */
  export type IncidentReportUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update IncidentReports.
     */
    data: XOR<IncidentReportUpdateManyMutationInput, IncidentReportUncheckedUpdateManyInput>
    /**
     * Filter which IncidentReports to update
     */
    where?: IncidentReportWhereInput
    /**
     * Limit how many IncidentReports to update.
     */
    limit?: number
  }

  /**
   * IncidentReport updateManyAndReturn
   */
  export type IncidentReportUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IncidentReport
     */
    select?: IncidentReportSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the IncidentReport
     */
    omit?: IncidentReportOmit<ExtArgs> | null
    /**
     * The data used to update IncidentReports.
     */
    data: XOR<IncidentReportUpdateManyMutationInput, IncidentReportUncheckedUpdateManyInput>
    /**
     * Filter which IncidentReports to update
     */
    where?: IncidentReportWhereInput
    /**
     * Limit how many IncidentReports to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidentReportIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * IncidentReport upsert
   */
  export type IncidentReportUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IncidentReport
     */
    select?: IncidentReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IncidentReport
     */
    omit?: IncidentReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidentReportInclude<ExtArgs> | null
    /**
     * The filter to search for the IncidentReport to update in case it exists.
     */
    where: IncidentReportWhereUniqueInput
    /**
     * In case the IncidentReport found by the `where` argument doesn't exist, create a new IncidentReport with this data.
     */
    create: XOR<IncidentReportCreateInput, IncidentReportUncheckedCreateInput>
    /**
     * In case the IncidentReport was found with the provided `where` argument, update it with this data.
     */
    update: XOR<IncidentReportUpdateInput, IncidentReportUncheckedUpdateInput>
  }

  /**
   * IncidentReport delete
   */
  export type IncidentReportDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IncidentReport
     */
    select?: IncidentReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IncidentReport
     */
    omit?: IncidentReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidentReportInclude<ExtArgs> | null
    /**
     * Filter which IncidentReport to delete.
     */
    where: IncidentReportWhereUniqueInput
  }

  /**
   * IncidentReport deleteMany
   */
  export type IncidentReportDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which IncidentReports to delete
     */
    where?: IncidentReportWhereInput
    /**
     * Limit how many IncidentReports to delete.
     */
    limit?: number
  }

  /**
   * IncidentReport without action
   */
  export type IncidentReportDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IncidentReport
     */
    select?: IncidentReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IncidentReport
     */
    omit?: IncidentReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidentReportInclude<ExtArgs> | null
  }


  /**
   * Model ChatMessage
   */

  export type AggregateChatMessage = {
    _count: ChatMessageCountAggregateOutputType | null
    _min: ChatMessageMinAggregateOutputType | null
    _max: ChatMessageMaxAggregateOutputType | null
  }

  export type ChatMessageMinAggregateOutputType = {
    id: string | null
    requestId: string | null
    senderId: string | null
    content: string | null
    imageUrl: string | null
    isRead: boolean | null
    createdAt: Date | null
  }

  export type ChatMessageMaxAggregateOutputType = {
    id: string | null
    requestId: string | null
    senderId: string | null
    content: string | null
    imageUrl: string | null
    isRead: boolean | null
    createdAt: Date | null
  }

  export type ChatMessageCountAggregateOutputType = {
    id: number
    requestId: number
    senderId: number
    content: number
    imageUrl: number
    isRead: number
    createdAt: number
    _all: number
  }


  export type ChatMessageMinAggregateInputType = {
    id?: true
    requestId?: true
    senderId?: true
    content?: true
    imageUrl?: true
    isRead?: true
    createdAt?: true
  }

  export type ChatMessageMaxAggregateInputType = {
    id?: true
    requestId?: true
    senderId?: true
    content?: true
    imageUrl?: true
    isRead?: true
    createdAt?: true
  }

  export type ChatMessageCountAggregateInputType = {
    id?: true
    requestId?: true
    senderId?: true
    content?: true
    imageUrl?: true
    isRead?: true
    createdAt?: true
    _all?: true
  }

  export type ChatMessageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChatMessage to aggregate.
     */
    where?: ChatMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChatMessages to fetch.
     */
    orderBy?: ChatMessageOrderByWithRelationInput | ChatMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ChatMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChatMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChatMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ChatMessages
    **/
    _count?: true | ChatMessageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChatMessageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChatMessageMaxAggregateInputType
  }

  export type GetChatMessageAggregateType<T extends ChatMessageAggregateArgs> = {
        [P in keyof T & keyof AggregateChatMessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChatMessage[P]>
      : GetScalarType<T[P], AggregateChatMessage[P]>
  }




  export type ChatMessageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChatMessageWhereInput
    orderBy?: ChatMessageOrderByWithAggregationInput | ChatMessageOrderByWithAggregationInput[]
    by: ChatMessageScalarFieldEnum[] | ChatMessageScalarFieldEnum
    having?: ChatMessageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChatMessageCountAggregateInputType | true
    _min?: ChatMessageMinAggregateInputType
    _max?: ChatMessageMaxAggregateInputType
  }

  export type ChatMessageGroupByOutputType = {
    id: string
    requestId: string
    senderId: string
    content: string
    imageUrl: string | null
    isRead: boolean
    createdAt: Date
    _count: ChatMessageCountAggregateOutputType | null
    _min: ChatMessageMinAggregateOutputType | null
    _max: ChatMessageMaxAggregateOutputType | null
  }

  type GetChatMessageGroupByPayload<T extends ChatMessageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChatMessageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChatMessageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChatMessageGroupByOutputType[P]>
            : GetScalarType<T[P], ChatMessageGroupByOutputType[P]>
        }
      >
    >


  export type ChatMessageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    requestId?: boolean
    senderId?: boolean
    content?: boolean
    imageUrl?: boolean
    isRead?: boolean
    createdAt?: boolean
    request?: boolean | ServiceRequestDefaultArgs<ExtArgs>
    sender?: boolean | UserProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chatMessage"]>

  export type ChatMessageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    requestId?: boolean
    senderId?: boolean
    content?: boolean
    imageUrl?: boolean
    isRead?: boolean
    createdAt?: boolean
    request?: boolean | ServiceRequestDefaultArgs<ExtArgs>
    sender?: boolean | UserProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chatMessage"]>

  export type ChatMessageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    requestId?: boolean
    senderId?: boolean
    content?: boolean
    imageUrl?: boolean
    isRead?: boolean
    createdAt?: boolean
    request?: boolean | ServiceRequestDefaultArgs<ExtArgs>
    sender?: boolean | UserProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chatMessage"]>

  export type ChatMessageSelectScalar = {
    id?: boolean
    requestId?: boolean
    senderId?: boolean
    content?: boolean
    imageUrl?: boolean
    isRead?: boolean
    createdAt?: boolean
  }

  export type ChatMessageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "requestId" | "senderId" | "content" | "imageUrl" | "isRead" | "createdAt", ExtArgs["result"]["chatMessage"]>
  export type ChatMessageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    request?: boolean | ServiceRequestDefaultArgs<ExtArgs>
    sender?: boolean | UserProfileDefaultArgs<ExtArgs>
  }
  export type ChatMessageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    request?: boolean | ServiceRequestDefaultArgs<ExtArgs>
    sender?: boolean | UserProfileDefaultArgs<ExtArgs>
  }
  export type ChatMessageIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    request?: boolean | ServiceRequestDefaultArgs<ExtArgs>
    sender?: boolean | UserProfileDefaultArgs<ExtArgs>
  }

  export type $ChatMessagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ChatMessage"
    objects: {
      request: Prisma.$ServiceRequestPayload<ExtArgs>
      sender: Prisma.$UserProfilePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      requestId: string
      senderId: string
      content: string
      imageUrl: string | null
      isRead: boolean
      createdAt: Date
    }, ExtArgs["result"]["chatMessage"]>
    composites: {}
  }

  type ChatMessageGetPayload<S extends boolean | null | undefined | ChatMessageDefaultArgs> = $Result.GetResult<Prisma.$ChatMessagePayload, S>

  type ChatMessageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ChatMessageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ChatMessageCountAggregateInputType | true
    }

  export interface ChatMessageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ChatMessage'], meta: { name: 'ChatMessage' } }
    /**
     * Find zero or one ChatMessage that matches the filter.
     * @param {ChatMessageFindUniqueArgs} args - Arguments to find a ChatMessage
     * @example
     * // Get one ChatMessage
     * const chatMessage = await prisma.chatMessage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ChatMessageFindUniqueArgs>(args: SelectSubset<T, ChatMessageFindUniqueArgs<ExtArgs>>): Prisma__ChatMessageClient<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ChatMessage that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ChatMessageFindUniqueOrThrowArgs} args - Arguments to find a ChatMessage
     * @example
     * // Get one ChatMessage
     * const chatMessage = await prisma.chatMessage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ChatMessageFindUniqueOrThrowArgs>(args: SelectSubset<T, ChatMessageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ChatMessageClient<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ChatMessage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatMessageFindFirstArgs} args - Arguments to find a ChatMessage
     * @example
     * // Get one ChatMessage
     * const chatMessage = await prisma.chatMessage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ChatMessageFindFirstArgs>(args?: SelectSubset<T, ChatMessageFindFirstArgs<ExtArgs>>): Prisma__ChatMessageClient<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ChatMessage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatMessageFindFirstOrThrowArgs} args - Arguments to find a ChatMessage
     * @example
     * // Get one ChatMessage
     * const chatMessage = await prisma.chatMessage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ChatMessageFindFirstOrThrowArgs>(args?: SelectSubset<T, ChatMessageFindFirstOrThrowArgs<ExtArgs>>): Prisma__ChatMessageClient<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ChatMessages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatMessageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ChatMessages
     * const chatMessages = await prisma.chatMessage.findMany()
     * 
     * // Get first 10 ChatMessages
     * const chatMessages = await prisma.chatMessage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const chatMessageWithIdOnly = await prisma.chatMessage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ChatMessageFindManyArgs>(args?: SelectSubset<T, ChatMessageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ChatMessage.
     * @param {ChatMessageCreateArgs} args - Arguments to create a ChatMessage.
     * @example
     * // Create one ChatMessage
     * const ChatMessage = await prisma.chatMessage.create({
     *   data: {
     *     // ... data to create a ChatMessage
     *   }
     * })
     * 
     */
    create<T extends ChatMessageCreateArgs>(args: SelectSubset<T, ChatMessageCreateArgs<ExtArgs>>): Prisma__ChatMessageClient<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ChatMessages.
     * @param {ChatMessageCreateManyArgs} args - Arguments to create many ChatMessages.
     * @example
     * // Create many ChatMessages
     * const chatMessage = await prisma.chatMessage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ChatMessageCreateManyArgs>(args?: SelectSubset<T, ChatMessageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ChatMessages and returns the data saved in the database.
     * @param {ChatMessageCreateManyAndReturnArgs} args - Arguments to create many ChatMessages.
     * @example
     * // Create many ChatMessages
     * const chatMessage = await prisma.chatMessage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ChatMessages and only return the `id`
     * const chatMessageWithIdOnly = await prisma.chatMessage.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ChatMessageCreateManyAndReturnArgs>(args?: SelectSubset<T, ChatMessageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ChatMessage.
     * @param {ChatMessageDeleteArgs} args - Arguments to delete one ChatMessage.
     * @example
     * // Delete one ChatMessage
     * const ChatMessage = await prisma.chatMessage.delete({
     *   where: {
     *     // ... filter to delete one ChatMessage
     *   }
     * })
     * 
     */
    delete<T extends ChatMessageDeleteArgs>(args: SelectSubset<T, ChatMessageDeleteArgs<ExtArgs>>): Prisma__ChatMessageClient<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ChatMessage.
     * @param {ChatMessageUpdateArgs} args - Arguments to update one ChatMessage.
     * @example
     * // Update one ChatMessage
     * const chatMessage = await prisma.chatMessage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ChatMessageUpdateArgs>(args: SelectSubset<T, ChatMessageUpdateArgs<ExtArgs>>): Prisma__ChatMessageClient<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ChatMessages.
     * @param {ChatMessageDeleteManyArgs} args - Arguments to filter ChatMessages to delete.
     * @example
     * // Delete a few ChatMessages
     * const { count } = await prisma.chatMessage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ChatMessageDeleteManyArgs>(args?: SelectSubset<T, ChatMessageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChatMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatMessageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ChatMessages
     * const chatMessage = await prisma.chatMessage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ChatMessageUpdateManyArgs>(args: SelectSubset<T, ChatMessageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChatMessages and returns the data updated in the database.
     * @param {ChatMessageUpdateManyAndReturnArgs} args - Arguments to update many ChatMessages.
     * @example
     * // Update many ChatMessages
     * const chatMessage = await prisma.chatMessage.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ChatMessages and only return the `id`
     * const chatMessageWithIdOnly = await prisma.chatMessage.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ChatMessageUpdateManyAndReturnArgs>(args: SelectSubset<T, ChatMessageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ChatMessage.
     * @param {ChatMessageUpsertArgs} args - Arguments to update or create a ChatMessage.
     * @example
     * // Update or create a ChatMessage
     * const chatMessage = await prisma.chatMessage.upsert({
     *   create: {
     *     // ... data to create a ChatMessage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ChatMessage we want to update
     *   }
     * })
     */
    upsert<T extends ChatMessageUpsertArgs>(args: SelectSubset<T, ChatMessageUpsertArgs<ExtArgs>>): Prisma__ChatMessageClient<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ChatMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatMessageCountArgs} args - Arguments to filter ChatMessages to count.
     * @example
     * // Count the number of ChatMessages
     * const count = await prisma.chatMessage.count({
     *   where: {
     *     // ... the filter for the ChatMessages we want to count
     *   }
     * })
    **/
    count<T extends ChatMessageCountArgs>(
      args?: Subset<T, ChatMessageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChatMessageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ChatMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatMessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChatMessageAggregateArgs>(args: Subset<T, ChatMessageAggregateArgs>): Prisma.PrismaPromise<GetChatMessageAggregateType<T>>

    /**
     * Group by ChatMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatMessageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChatMessageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChatMessageGroupByArgs['orderBy'] }
        : { orderBy?: ChatMessageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChatMessageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChatMessageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ChatMessage model
   */
  readonly fields: ChatMessageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ChatMessage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ChatMessageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    request<T extends ServiceRequestDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ServiceRequestDefaultArgs<ExtArgs>>): Prisma__ServiceRequestClient<$Result.GetResult<Prisma.$ServiceRequestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    sender<T extends UserProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserProfileDefaultArgs<ExtArgs>>): Prisma__UserProfileClient<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ChatMessage model
   */
  interface ChatMessageFieldRefs {
    readonly id: FieldRef<"ChatMessage", 'String'>
    readonly requestId: FieldRef<"ChatMessage", 'String'>
    readonly senderId: FieldRef<"ChatMessage", 'String'>
    readonly content: FieldRef<"ChatMessage", 'String'>
    readonly imageUrl: FieldRef<"ChatMessage", 'String'>
    readonly isRead: FieldRef<"ChatMessage", 'Boolean'>
    readonly createdAt: FieldRef<"ChatMessage", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ChatMessage findUnique
   */
  export type ChatMessageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatMessage
     */
    omit?: ChatMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageInclude<ExtArgs> | null
    /**
     * Filter, which ChatMessage to fetch.
     */
    where: ChatMessageWhereUniqueInput
  }

  /**
   * ChatMessage findUniqueOrThrow
   */
  export type ChatMessageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatMessage
     */
    omit?: ChatMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageInclude<ExtArgs> | null
    /**
     * Filter, which ChatMessage to fetch.
     */
    where: ChatMessageWhereUniqueInput
  }

  /**
   * ChatMessage findFirst
   */
  export type ChatMessageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatMessage
     */
    omit?: ChatMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageInclude<ExtArgs> | null
    /**
     * Filter, which ChatMessage to fetch.
     */
    where?: ChatMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChatMessages to fetch.
     */
    orderBy?: ChatMessageOrderByWithRelationInput | ChatMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChatMessages.
     */
    cursor?: ChatMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChatMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChatMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChatMessages.
     */
    distinct?: ChatMessageScalarFieldEnum | ChatMessageScalarFieldEnum[]
  }

  /**
   * ChatMessage findFirstOrThrow
   */
  export type ChatMessageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatMessage
     */
    omit?: ChatMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageInclude<ExtArgs> | null
    /**
     * Filter, which ChatMessage to fetch.
     */
    where?: ChatMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChatMessages to fetch.
     */
    orderBy?: ChatMessageOrderByWithRelationInput | ChatMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChatMessages.
     */
    cursor?: ChatMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChatMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChatMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChatMessages.
     */
    distinct?: ChatMessageScalarFieldEnum | ChatMessageScalarFieldEnum[]
  }

  /**
   * ChatMessage findMany
   */
  export type ChatMessageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatMessage
     */
    omit?: ChatMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageInclude<ExtArgs> | null
    /**
     * Filter, which ChatMessages to fetch.
     */
    where?: ChatMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChatMessages to fetch.
     */
    orderBy?: ChatMessageOrderByWithRelationInput | ChatMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ChatMessages.
     */
    cursor?: ChatMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChatMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChatMessages.
     */
    skip?: number
    distinct?: ChatMessageScalarFieldEnum | ChatMessageScalarFieldEnum[]
  }

  /**
   * ChatMessage create
   */
  export type ChatMessageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatMessage
     */
    omit?: ChatMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageInclude<ExtArgs> | null
    /**
     * The data needed to create a ChatMessage.
     */
    data: XOR<ChatMessageCreateInput, ChatMessageUncheckedCreateInput>
  }

  /**
   * ChatMessage createMany
   */
  export type ChatMessageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ChatMessages.
     */
    data: ChatMessageCreateManyInput | ChatMessageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ChatMessage createManyAndReturn
   */
  export type ChatMessageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ChatMessage
     */
    omit?: ChatMessageOmit<ExtArgs> | null
    /**
     * The data used to create many ChatMessages.
     */
    data: ChatMessageCreateManyInput | ChatMessageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ChatMessage update
   */
  export type ChatMessageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatMessage
     */
    omit?: ChatMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageInclude<ExtArgs> | null
    /**
     * The data needed to update a ChatMessage.
     */
    data: XOR<ChatMessageUpdateInput, ChatMessageUncheckedUpdateInput>
    /**
     * Choose, which ChatMessage to update.
     */
    where: ChatMessageWhereUniqueInput
  }

  /**
   * ChatMessage updateMany
   */
  export type ChatMessageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ChatMessages.
     */
    data: XOR<ChatMessageUpdateManyMutationInput, ChatMessageUncheckedUpdateManyInput>
    /**
     * Filter which ChatMessages to update
     */
    where?: ChatMessageWhereInput
    /**
     * Limit how many ChatMessages to update.
     */
    limit?: number
  }

  /**
   * ChatMessage updateManyAndReturn
   */
  export type ChatMessageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ChatMessage
     */
    omit?: ChatMessageOmit<ExtArgs> | null
    /**
     * The data used to update ChatMessages.
     */
    data: XOR<ChatMessageUpdateManyMutationInput, ChatMessageUncheckedUpdateManyInput>
    /**
     * Filter which ChatMessages to update
     */
    where?: ChatMessageWhereInput
    /**
     * Limit how many ChatMessages to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ChatMessage upsert
   */
  export type ChatMessageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatMessage
     */
    omit?: ChatMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageInclude<ExtArgs> | null
    /**
     * The filter to search for the ChatMessage to update in case it exists.
     */
    where: ChatMessageWhereUniqueInput
    /**
     * In case the ChatMessage found by the `where` argument doesn't exist, create a new ChatMessage with this data.
     */
    create: XOR<ChatMessageCreateInput, ChatMessageUncheckedCreateInput>
    /**
     * In case the ChatMessage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ChatMessageUpdateInput, ChatMessageUncheckedUpdateInput>
  }

  /**
   * ChatMessage delete
   */
  export type ChatMessageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatMessage
     */
    omit?: ChatMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageInclude<ExtArgs> | null
    /**
     * Filter which ChatMessage to delete.
     */
    where: ChatMessageWhereUniqueInput
  }

  /**
   * ChatMessage deleteMany
   */
  export type ChatMessageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChatMessages to delete
     */
    where?: ChatMessageWhereInput
    /**
     * Limit how many ChatMessages to delete.
     */
    limit?: number
  }

  /**
   * ChatMessage without action
   */
  export type ChatMessageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatMessage
     */
    omit?: ChatMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageInclude<ExtArgs> | null
  }


  /**
   * Model Notification
   */

  export type AggregateNotification = {
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  export type NotificationMinAggregateOutputType = {
    id: string | null
    userId: string | null
    requestId: string | null
    title: string | null
    body: string | null
    channel: $Enums.NotificationChannel | null
    isRead: boolean | null
    link: string | null
    createdAt: Date | null
  }

  export type NotificationMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    requestId: string | null
    title: string | null
    body: string | null
    channel: $Enums.NotificationChannel | null
    isRead: boolean | null
    link: string | null
    createdAt: Date | null
  }

  export type NotificationCountAggregateOutputType = {
    id: number
    userId: number
    requestId: number
    title: number
    body: number
    channel: number
    isRead: number
    link: number
    createdAt: number
    _all: number
  }


  export type NotificationMinAggregateInputType = {
    id?: true
    userId?: true
    requestId?: true
    title?: true
    body?: true
    channel?: true
    isRead?: true
    link?: true
    createdAt?: true
  }

  export type NotificationMaxAggregateInputType = {
    id?: true
    userId?: true
    requestId?: true
    title?: true
    body?: true
    channel?: true
    isRead?: true
    link?: true
    createdAt?: true
  }

  export type NotificationCountAggregateInputType = {
    id?: true
    userId?: true
    requestId?: true
    title?: true
    body?: true
    channel?: true
    isRead?: true
    link?: true
    createdAt?: true
    _all?: true
  }

  export type NotificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notification to aggregate.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notifications
    **/
    _count?: true | NotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationMaxAggregateInputType
  }

  export type GetNotificationAggregateType<T extends NotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotification[P]>
      : GetScalarType<T[P], AggregateNotification[P]>
  }




  export type NotificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithAggregationInput | NotificationOrderByWithAggregationInput[]
    by: NotificationScalarFieldEnum[] | NotificationScalarFieldEnum
    having?: NotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationCountAggregateInputType | true
    _min?: NotificationMinAggregateInputType
    _max?: NotificationMaxAggregateInputType
  }

  export type NotificationGroupByOutputType = {
    id: string
    userId: string
    requestId: string | null
    title: string
    body: string
    channel: $Enums.NotificationChannel
    isRead: boolean
    link: string | null
    createdAt: Date
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  type GetNotificationGroupByPayload<T extends NotificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationGroupByOutputType[P]>
        }
      >
    >


  export type NotificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    requestId?: boolean
    title?: boolean
    body?: boolean
    channel?: boolean
    isRead?: boolean
    link?: boolean
    createdAt?: boolean
    user?: boolean | UserProfileDefaultArgs<ExtArgs>
    request?: boolean | Notification$requestArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    requestId?: boolean
    title?: boolean
    body?: boolean
    channel?: boolean
    isRead?: boolean
    link?: boolean
    createdAt?: boolean
    user?: boolean | UserProfileDefaultArgs<ExtArgs>
    request?: boolean | Notification$requestArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    requestId?: boolean
    title?: boolean
    body?: boolean
    channel?: boolean
    isRead?: boolean
    link?: boolean
    createdAt?: boolean
    user?: boolean | UserProfileDefaultArgs<ExtArgs>
    request?: boolean | Notification$requestArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectScalar = {
    id?: boolean
    userId?: boolean
    requestId?: boolean
    title?: boolean
    body?: boolean
    channel?: boolean
    isRead?: boolean
    link?: boolean
    createdAt?: boolean
  }

  export type NotificationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "requestId" | "title" | "body" | "channel" | "isRead" | "link" | "createdAt", ExtArgs["result"]["notification"]>
  export type NotificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserProfileDefaultArgs<ExtArgs>
    request?: boolean | Notification$requestArgs<ExtArgs>
  }
  export type NotificationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserProfileDefaultArgs<ExtArgs>
    request?: boolean | Notification$requestArgs<ExtArgs>
  }
  export type NotificationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserProfileDefaultArgs<ExtArgs>
    request?: boolean | Notification$requestArgs<ExtArgs>
  }

  export type $NotificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Notification"
    objects: {
      user: Prisma.$UserProfilePayload<ExtArgs>
      request: Prisma.$ServiceRequestPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      requestId: string | null
      title: string
      body: string
      channel: $Enums.NotificationChannel
      isRead: boolean
      link: string | null
      createdAt: Date
    }, ExtArgs["result"]["notification"]>
    composites: {}
  }

  type NotificationGetPayload<S extends boolean | null | undefined | NotificationDefaultArgs> = $Result.GetResult<Prisma.$NotificationPayload, S>

  type NotificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NotificationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NotificationCountAggregateInputType | true
    }

  export interface NotificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Notification'], meta: { name: 'Notification' } }
    /**
     * Find zero or one Notification that matches the filter.
     * @param {NotificationFindUniqueArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationFindUniqueArgs>(args: SelectSubset<T, NotificationFindUniqueArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Notification that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NotificationFindUniqueOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationFindFirstArgs>(args?: SelectSubset<T, NotificationFindFirstArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notification.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationWithIdOnly = await prisma.notification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationFindManyArgs>(args?: SelectSubset<T, NotificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Notification.
     * @param {NotificationCreateArgs} args - Arguments to create a Notification.
     * @example
     * // Create one Notification
     * const Notification = await prisma.notification.create({
     *   data: {
     *     // ... data to create a Notification
     *   }
     * })
     * 
     */
    create<T extends NotificationCreateArgs>(args: SelectSubset<T, NotificationCreateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Notifications.
     * @param {NotificationCreateManyArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationCreateManyArgs>(args?: SelectSubset<T, NotificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Notifications and returns the data saved in the database.
     * @param {NotificationCreateManyAndReturnArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NotificationCreateManyAndReturnArgs>(args?: SelectSubset<T, NotificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Notification.
     * @param {NotificationDeleteArgs} args - Arguments to delete one Notification.
     * @example
     * // Delete one Notification
     * const Notification = await prisma.notification.delete({
     *   where: {
     *     // ... filter to delete one Notification
     *   }
     * })
     * 
     */
    delete<T extends NotificationDeleteArgs>(args: SelectSubset<T, NotificationDeleteArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Notification.
     * @param {NotificationUpdateArgs} args - Arguments to update one Notification.
     * @example
     * // Update one Notification
     * const notification = await prisma.notification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationUpdateArgs>(args: SelectSubset<T, NotificationUpdateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Notifications.
     * @param {NotificationDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationDeleteManyArgs>(args?: SelectSubset<T, NotificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationUpdateManyArgs>(args: SelectSubset<T, NotificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications and returns the data updated in the database.
     * @param {NotificationUpdateManyAndReturnArgs} args - Arguments to update many Notifications.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends NotificationUpdateManyAndReturnArgs>(args: SelectSubset<T, NotificationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Notification.
     * @param {NotificationUpsertArgs} args - Arguments to update or create a Notification.
     * @example
     * // Update or create a Notification
     * const notification = await prisma.notification.upsert({
     *   create: {
     *     // ... data to create a Notification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notification we want to update
     *   }
     * })
     */
    upsert<T extends NotificationUpsertArgs>(args: SelectSubset<T, NotificationUpsertArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notification.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends NotificationCountArgs>(
      args?: Subset<T, NotificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationAggregateArgs>(args: Subset<T, NotificationAggregateArgs>): Prisma.PrismaPromise<GetNotificationAggregateType<T>>

    /**
     * Group by Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationGroupByArgs['orderBy'] }
        : { orderBy?: NotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Notification model
   */
  readonly fields: NotificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Notification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserProfileDefaultArgs<ExtArgs>>): Prisma__UserProfileClient<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    request<T extends Notification$requestArgs<ExtArgs> = {}>(args?: Subset<T, Notification$requestArgs<ExtArgs>>): Prisma__ServiceRequestClient<$Result.GetResult<Prisma.$ServiceRequestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Notification model
   */
  interface NotificationFieldRefs {
    readonly id: FieldRef<"Notification", 'String'>
    readonly userId: FieldRef<"Notification", 'String'>
    readonly requestId: FieldRef<"Notification", 'String'>
    readonly title: FieldRef<"Notification", 'String'>
    readonly body: FieldRef<"Notification", 'String'>
    readonly channel: FieldRef<"Notification", 'NotificationChannel'>
    readonly isRead: FieldRef<"Notification", 'Boolean'>
    readonly link: FieldRef<"Notification", 'String'>
    readonly createdAt: FieldRef<"Notification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Notification findUnique
   */
  export type NotificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findUniqueOrThrow
   */
  export type NotificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findFirst
   */
  export type NotificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findFirstOrThrow
   */
  export type NotificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findMany
   */
  export type NotificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notifications to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification create
   */
  export type NotificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to create a Notification.
     */
    data: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
  }

  /**
   * Notification createMany
   */
  export type NotificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Notification createManyAndReturn
   */
  export type NotificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notification update
   */
  export type NotificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to update a Notification.
     */
    data: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
    /**
     * Choose, which Notification to update.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification updateMany
   */
  export type NotificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to update.
     */
    limit?: number
  }

  /**
   * Notification updateManyAndReturn
   */
  export type NotificationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notification upsert
   */
  export type NotificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The filter to search for the Notification to update in case it exists.
     */
    where: NotificationWhereUniqueInput
    /**
     * In case the Notification found by the `where` argument doesn't exist, create a new Notification with this data.
     */
    create: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
    /**
     * In case the Notification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
  }

  /**
   * Notification delete
   */
  export type NotificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter which Notification to delete.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification deleteMany
   */
  export type NotificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notifications to delete
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to delete.
     */
    limit?: number
  }

  /**
   * Notification.request
   */
  export type Notification$requestArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceRequest
     */
    select?: ServiceRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceRequest
     */
    omit?: ServiceRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceRequestInclude<ExtArgs> | null
    where?: ServiceRequestWhereInput
  }

  /**
   * Notification without action
   */
  export type NotificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
  }


  /**
   * Model AuditLog
   */

  export type AggregateAuditLog = {
    _count: AuditLogCountAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  export type AuditLogMinAggregateOutputType = {
    id: string | null
    actorId: string | null
    action: $Enums.AdminActionType | null
    targetType: string | null
    targetId: string | null
    reason: string | null
    metadata: string | null
    createdAt: Date | null
  }

  export type AuditLogMaxAggregateOutputType = {
    id: string | null
    actorId: string | null
    action: $Enums.AdminActionType | null
    targetType: string | null
    targetId: string | null
    reason: string | null
    metadata: string | null
    createdAt: Date | null
  }

  export type AuditLogCountAggregateOutputType = {
    id: number
    actorId: number
    action: number
    targetType: number
    targetId: number
    reason: number
    metadata: number
    createdAt: number
    _all: number
  }


  export type AuditLogMinAggregateInputType = {
    id?: true
    actorId?: true
    action?: true
    targetType?: true
    targetId?: true
    reason?: true
    metadata?: true
    createdAt?: true
  }

  export type AuditLogMaxAggregateInputType = {
    id?: true
    actorId?: true
    action?: true
    targetType?: true
    targetId?: true
    reason?: true
    metadata?: true
    createdAt?: true
  }

  export type AuditLogCountAggregateInputType = {
    id?: true
    actorId?: true
    action?: true
    targetType?: true
    targetId?: true
    reason?: true
    metadata?: true
    createdAt?: true
    _all?: true
  }

  export type AuditLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLog to aggregate.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AuditLogs
    **/
    _count?: true | AuditLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuditLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuditLogMaxAggregateInputType
  }

  export type GetAuditLogAggregateType<T extends AuditLogAggregateArgs> = {
        [P in keyof T & keyof AggregateAuditLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuditLog[P]>
      : GetScalarType<T[P], AggregateAuditLog[P]>
  }




  export type AuditLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithAggregationInput | AuditLogOrderByWithAggregationInput[]
    by: AuditLogScalarFieldEnum[] | AuditLogScalarFieldEnum
    having?: AuditLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuditLogCountAggregateInputType | true
    _min?: AuditLogMinAggregateInputType
    _max?: AuditLogMaxAggregateInputType
  }

  export type AuditLogGroupByOutputType = {
    id: string
    actorId: string
    action: $Enums.AdminActionType
    targetType: string
    targetId: string
    reason: string | null
    metadata: string | null
    createdAt: Date
    _count: AuditLogCountAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  type GetAuditLogGroupByPayload<T extends AuditLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AuditLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuditLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
            : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
        }
      >
    >


  export type AuditLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    actorId?: boolean
    action?: boolean
    targetType?: boolean
    targetId?: boolean
    reason?: boolean
    metadata?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    actorId?: boolean
    action?: boolean
    targetType?: boolean
    targetId?: boolean
    reason?: boolean
    metadata?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    actorId?: boolean
    action?: boolean
    targetType?: boolean
    targetId?: boolean
    reason?: boolean
    metadata?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectScalar = {
    id?: boolean
    actorId?: boolean
    action?: boolean
    targetType?: boolean
    targetId?: boolean
    reason?: boolean
    metadata?: boolean
    createdAt?: boolean
  }

  export type AuditLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "actorId" | "action" | "targetType" | "targetId" | "reason" | "metadata" | "createdAt", ExtArgs["result"]["auditLog"]>

  export type $AuditLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AuditLog"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      actorId: string
      action: $Enums.AdminActionType
      targetType: string
      targetId: string
      reason: string | null
      metadata: string | null
      createdAt: Date
    }, ExtArgs["result"]["auditLog"]>
    composites: {}
  }

  type AuditLogGetPayload<S extends boolean | null | undefined | AuditLogDefaultArgs> = $Result.GetResult<Prisma.$AuditLogPayload, S>

  type AuditLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AuditLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AuditLogCountAggregateInputType | true
    }

  export interface AuditLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AuditLog'], meta: { name: 'AuditLog' } }
    /**
     * Find zero or one AuditLog that matches the filter.
     * @param {AuditLogFindUniqueArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AuditLogFindUniqueArgs>(args: SelectSubset<T, AuditLogFindUniqueArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AuditLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AuditLogFindUniqueOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AuditLogFindUniqueOrThrowArgs>(args: SelectSubset<T, AuditLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AuditLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AuditLogFindFirstArgs>(args?: SelectSubset<T, AuditLogFindFirstArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AuditLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AuditLogFindFirstOrThrowArgs>(args?: SelectSubset<T, AuditLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AuditLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AuditLogs
     * const auditLogs = await prisma.auditLog.findMany()
     * 
     * // Get first 10 AuditLogs
     * const auditLogs = await prisma.auditLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AuditLogFindManyArgs>(args?: SelectSubset<T, AuditLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AuditLog.
     * @param {AuditLogCreateArgs} args - Arguments to create a AuditLog.
     * @example
     * // Create one AuditLog
     * const AuditLog = await prisma.auditLog.create({
     *   data: {
     *     // ... data to create a AuditLog
     *   }
     * })
     * 
     */
    create<T extends AuditLogCreateArgs>(args: SelectSubset<T, AuditLogCreateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AuditLogs.
     * @param {AuditLogCreateManyArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AuditLogCreateManyArgs>(args?: SelectSubset<T, AuditLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AuditLogs and returns the data saved in the database.
     * @param {AuditLogCreateManyAndReturnArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AuditLogs and only return the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AuditLogCreateManyAndReturnArgs>(args?: SelectSubset<T, AuditLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AuditLog.
     * @param {AuditLogDeleteArgs} args - Arguments to delete one AuditLog.
     * @example
     * // Delete one AuditLog
     * const AuditLog = await prisma.auditLog.delete({
     *   where: {
     *     // ... filter to delete one AuditLog
     *   }
     * })
     * 
     */
    delete<T extends AuditLogDeleteArgs>(args: SelectSubset<T, AuditLogDeleteArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AuditLog.
     * @param {AuditLogUpdateArgs} args - Arguments to update one AuditLog.
     * @example
     * // Update one AuditLog
     * const auditLog = await prisma.auditLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AuditLogUpdateArgs>(args: SelectSubset<T, AuditLogUpdateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AuditLogs.
     * @param {AuditLogDeleteManyArgs} args - Arguments to filter AuditLogs to delete.
     * @example
     * // Delete a few AuditLogs
     * const { count } = await prisma.auditLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AuditLogDeleteManyArgs>(args?: SelectSubset<T, AuditLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AuditLogs
     * const auditLog = await prisma.auditLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AuditLogUpdateManyArgs>(args: SelectSubset<T, AuditLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditLogs and returns the data updated in the database.
     * @param {AuditLogUpdateManyAndReturnArgs} args - Arguments to update many AuditLogs.
     * @example
     * // Update many AuditLogs
     * const auditLog = await prisma.auditLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AuditLogs and only return the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AuditLogUpdateManyAndReturnArgs>(args: SelectSubset<T, AuditLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AuditLog.
     * @param {AuditLogUpsertArgs} args - Arguments to update or create a AuditLog.
     * @example
     * // Update or create a AuditLog
     * const auditLog = await prisma.auditLog.upsert({
     *   create: {
     *     // ... data to create a AuditLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AuditLog we want to update
     *   }
     * })
     */
    upsert<T extends AuditLogUpsertArgs>(args: SelectSubset<T, AuditLogUpsertArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogCountArgs} args - Arguments to filter AuditLogs to count.
     * @example
     * // Count the number of AuditLogs
     * const count = await prisma.auditLog.count({
     *   where: {
     *     // ... the filter for the AuditLogs we want to count
     *   }
     * })
    **/
    count<T extends AuditLogCountArgs>(
      args?: Subset<T, AuditLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuditLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuditLogAggregateArgs>(args: Subset<T, AuditLogAggregateArgs>): Prisma.PrismaPromise<GetAuditLogAggregateType<T>>

    /**
     * Group by AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AuditLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AuditLogGroupByArgs['orderBy'] }
        : { orderBy?: AuditLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AuditLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuditLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AuditLog model
   */
  readonly fields: AuditLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AuditLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AuditLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AuditLog model
   */
  interface AuditLogFieldRefs {
    readonly id: FieldRef<"AuditLog", 'String'>
    readonly actorId: FieldRef<"AuditLog", 'String'>
    readonly action: FieldRef<"AuditLog", 'AdminActionType'>
    readonly targetType: FieldRef<"AuditLog", 'String'>
    readonly targetId: FieldRef<"AuditLog", 'String'>
    readonly reason: FieldRef<"AuditLog", 'String'>
    readonly metadata: FieldRef<"AuditLog", 'String'>
    readonly createdAt: FieldRef<"AuditLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AuditLog findUnique
   */
  export type AuditLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findUniqueOrThrow
   */
  export type AuditLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findFirst
   */
  export type AuditLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findFirstOrThrow
   */
  export type AuditLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findMany
   */
  export type AuditLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Filter, which AuditLogs to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog create
   */
  export type AuditLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * The data needed to create a AuditLog.
     */
    data: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
  }

  /**
   * AuditLog createMany
   */
  export type AuditLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AuditLog createManyAndReturn
   */
  export type AuditLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AuditLog update
   */
  export type AuditLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * The data needed to update a AuditLog.
     */
    data: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
    /**
     * Choose, which AuditLog to update.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog updateMany
   */
  export type AuditLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AuditLogs.
     */
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyInput>
    /**
     * Filter which AuditLogs to update
     */
    where?: AuditLogWhereInput
    /**
     * Limit how many AuditLogs to update.
     */
    limit?: number
  }

  /**
   * AuditLog updateManyAndReturn
   */
  export type AuditLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * The data used to update AuditLogs.
     */
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyInput>
    /**
     * Filter which AuditLogs to update
     */
    where?: AuditLogWhereInput
    /**
     * Limit how many AuditLogs to update.
     */
    limit?: number
  }

  /**
   * AuditLog upsert
   */
  export type AuditLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * The filter to search for the AuditLog to update in case it exists.
     */
    where: AuditLogWhereUniqueInput
    /**
     * In case the AuditLog found by the `where` argument doesn't exist, create a new AuditLog with this data.
     */
    create: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
    /**
     * In case the AuditLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
  }

  /**
   * AuditLog delete
   */
  export type AuditLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Filter which AuditLog to delete.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog deleteMany
   */
  export type AuditLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLogs to delete
     */
    where?: AuditLogWhereInput
    /**
     * Limit how many AuditLogs to delete.
     */
    limit?: number
  }

  /**
   * AuditLog without action
   */
  export type AuditLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
  }


  /**
   * Model FeatureFlag
   */

  export type AggregateFeatureFlag = {
    _count: FeatureFlagCountAggregateOutputType | null
    _min: FeatureFlagMinAggregateOutputType | null
    _max: FeatureFlagMaxAggregateOutputType | null
  }

  export type FeatureFlagMinAggregateOutputType = {
    id: string | null
    key: string | null
    name: string | null
    description: string | null
    enabled: boolean | null
    isMvp: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FeatureFlagMaxAggregateOutputType = {
    id: string | null
    key: string | null
    name: string | null
    description: string | null
    enabled: boolean | null
    isMvp: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FeatureFlagCountAggregateOutputType = {
    id: number
    key: number
    name: number
    description: number
    enabled: number
    isMvp: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type FeatureFlagMinAggregateInputType = {
    id?: true
    key?: true
    name?: true
    description?: true
    enabled?: true
    isMvp?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FeatureFlagMaxAggregateInputType = {
    id?: true
    key?: true
    name?: true
    description?: true
    enabled?: true
    isMvp?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FeatureFlagCountAggregateInputType = {
    id?: true
    key?: true
    name?: true
    description?: true
    enabled?: true
    isMvp?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type FeatureFlagAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FeatureFlag to aggregate.
     */
    where?: FeatureFlagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeatureFlags to fetch.
     */
    orderBy?: FeatureFlagOrderByWithRelationInput | FeatureFlagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FeatureFlagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeatureFlags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeatureFlags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FeatureFlags
    **/
    _count?: true | FeatureFlagCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FeatureFlagMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FeatureFlagMaxAggregateInputType
  }

  export type GetFeatureFlagAggregateType<T extends FeatureFlagAggregateArgs> = {
        [P in keyof T & keyof AggregateFeatureFlag]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFeatureFlag[P]>
      : GetScalarType<T[P], AggregateFeatureFlag[P]>
  }




  export type FeatureFlagGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FeatureFlagWhereInput
    orderBy?: FeatureFlagOrderByWithAggregationInput | FeatureFlagOrderByWithAggregationInput[]
    by: FeatureFlagScalarFieldEnum[] | FeatureFlagScalarFieldEnum
    having?: FeatureFlagScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FeatureFlagCountAggregateInputType | true
    _min?: FeatureFlagMinAggregateInputType
    _max?: FeatureFlagMaxAggregateInputType
  }

  export type FeatureFlagGroupByOutputType = {
    id: string
    key: string
    name: string
    description: string | null
    enabled: boolean
    isMvp: boolean
    createdAt: Date
    updatedAt: Date
    _count: FeatureFlagCountAggregateOutputType | null
    _min: FeatureFlagMinAggregateOutputType | null
    _max: FeatureFlagMaxAggregateOutputType | null
  }

  type GetFeatureFlagGroupByPayload<T extends FeatureFlagGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FeatureFlagGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FeatureFlagGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FeatureFlagGroupByOutputType[P]>
            : GetScalarType<T[P], FeatureFlagGroupByOutputType[P]>
        }
      >
    >


  export type FeatureFlagSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    name?: boolean
    description?: boolean
    enabled?: boolean
    isMvp?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["featureFlag"]>

  export type FeatureFlagSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    name?: boolean
    description?: boolean
    enabled?: boolean
    isMvp?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["featureFlag"]>

  export type FeatureFlagSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    name?: boolean
    description?: boolean
    enabled?: boolean
    isMvp?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["featureFlag"]>

  export type FeatureFlagSelectScalar = {
    id?: boolean
    key?: boolean
    name?: boolean
    description?: boolean
    enabled?: boolean
    isMvp?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type FeatureFlagOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "key" | "name" | "description" | "enabled" | "isMvp" | "createdAt" | "updatedAt", ExtArgs["result"]["featureFlag"]>

  export type $FeatureFlagPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FeatureFlag"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      key: string
      name: string
      description: string | null
      enabled: boolean
      isMvp: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["featureFlag"]>
    composites: {}
  }

  type FeatureFlagGetPayload<S extends boolean | null | undefined | FeatureFlagDefaultArgs> = $Result.GetResult<Prisma.$FeatureFlagPayload, S>

  type FeatureFlagCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FeatureFlagFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FeatureFlagCountAggregateInputType | true
    }

  export interface FeatureFlagDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FeatureFlag'], meta: { name: 'FeatureFlag' } }
    /**
     * Find zero or one FeatureFlag that matches the filter.
     * @param {FeatureFlagFindUniqueArgs} args - Arguments to find a FeatureFlag
     * @example
     * // Get one FeatureFlag
     * const featureFlag = await prisma.featureFlag.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FeatureFlagFindUniqueArgs>(args: SelectSubset<T, FeatureFlagFindUniqueArgs<ExtArgs>>): Prisma__FeatureFlagClient<$Result.GetResult<Prisma.$FeatureFlagPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FeatureFlag that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FeatureFlagFindUniqueOrThrowArgs} args - Arguments to find a FeatureFlag
     * @example
     * // Get one FeatureFlag
     * const featureFlag = await prisma.featureFlag.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FeatureFlagFindUniqueOrThrowArgs>(args: SelectSubset<T, FeatureFlagFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FeatureFlagClient<$Result.GetResult<Prisma.$FeatureFlagPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FeatureFlag that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeatureFlagFindFirstArgs} args - Arguments to find a FeatureFlag
     * @example
     * // Get one FeatureFlag
     * const featureFlag = await prisma.featureFlag.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FeatureFlagFindFirstArgs>(args?: SelectSubset<T, FeatureFlagFindFirstArgs<ExtArgs>>): Prisma__FeatureFlagClient<$Result.GetResult<Prisma.$FeatureFlagPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FeatureFlag that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeatureFlagFindFirstOrThrowArgs} args - Arguments to find a FeatureFlag
     * @example
     * // Get one FeatureFlag
     * const featureFlag = await prisma.featureFlag.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FeatureFlagFindFirstOrThrowArgs>(args?: SelectSubset<T, FeatureFlagFindFirstOrThrowArgs<ExtArgs>>): Prisma__FeatureFlagClient<$Result.GetResult<Prisma.$FeatureFlagPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FeatureFlags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeatureFlagFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FeatureFlags
     * const featureFlags = await prisma.featureFlag.findMany()
     * 
     * // Get first 10 FeatureFlags
     * const featureFlags = await prisma.featureFlag.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const featureFlagWithIdOnly = await prisma.featureFlag.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FeatureFlagFindManyArgs>(args?: SelectSubset<T, FeatureFlagFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeatureFlagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FeatureFlag.
     * @param {FeatureFlagCreateArgs} args - Arguments to create a FeatureFlag.
     * @example
     * // Create one FeatureFlag
     * const FeatureFlag = await prisma.featureFlag.create({
     *   data: {
     *     // ... data to create a FeatureFlag
     *   }
     * })
     * 
     */
    create<T extends FeatureFlagCreateArgs>(args: SelectSubset<T, FeatureFlagCreateArgs<ExtArgs>>): Prisma__FeatureFlagClient<$Result.GetResult<Prisma.$FeatureFlagPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FeatureFlags.
     * @param {FeatureFlagCreateManyArgs} args - Arguments to create many FeatureFlags.
     * @example
     * // Create many FeatureFlags
     * const featureFlag = await prisma.featureFlag.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FeatureFlagCreateManyArgs>(args?: SelectSubset<T, FeatureFlagCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FeatureFlags and returns the data saved in the database.
     * @param {FeatureFlagCreateManyAndReturnArgs} args - Arguments to create many FeatureFlags.
     * @example
     * // Create many FeatureFlags
     * const featureFlag = await prisma.featureFlag.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FeatureFlags and only return the `id`
     * const featureFlagWithIdOnly = await prisma.featureFlag.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FeatureFlagCreateManyAndReturnArgs>(args?: SelectSubset<T, FeatureFlagCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeatureFlagPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a FeatureFlag.
     * @param {FeatureFlagDeleteArgs} args - Arguments to delete one FeatureFlag.
     * @example
     * // Delete one FeatureFlag
     * const FeatureFlag = await prisma.featureFlag.delete({
     *   where: {
     *     // ... filter to delete one FeatureFlag
     *   }
     * })
     * 
     */
    delete<T extends FeatureFlagDeleteArgs>(args: SelectSubset<T, FeatureFlagDeleteArgs<ExtArgs>>): Prisma__FeatureFlagClient<$Result.GetResult<Prisma.$FeatureFlagPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FeatureFlag.
     * @param {FeatureFlagUpdateArgs} args - Arguments to update one FeatureFlag.
     * @example
     * // Update one FeatureFlag
     * const featureFlag = await prisma.featureFlag.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FeatureFlagUpdateArgs>(args: SelectSubset<T, FeatureFlagUpdateArgs<ExtArgs>>): Prisma__FeatureFlagClient<$Result.GetResult<Prisma.$FeatureFlagPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FeatureFlags.
     * @param {FeatureFlagDeleteManyArgs} args - Arguments to filter FeatureFlags to delete.
     * @example
     * // Delete a few FeatureFlags
     * const { count } = await prisma.featureFlag.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FeatureFlagDeleteManyArgs>(args?: SelectSubset<T, FeatureFlagDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FeatureFlags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeatureFlagUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FeatureFlags
     * const featureFlag = await prisma.featureFlag.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FeatureFlagUpdateManyArgs>(args: SelectSubset<T, FeatureFlagUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FeatureFlags and returns the data updated in the database.
     * @param {FeatureFlagUpdateManyAndReturnArgs} args - Arguments to update many FeatureFlags.
     * @example
     * // Update many FeatureFlags
     * const featureFlag = await prisma.featureFlag.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more FeatureFlags and only return the `id`
     * const featureFlagWithIdOnly = await prisma.featureFlag.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FeatureFlagUpdateManyAndReturnArgs>(args: SelectSubset<T, FeatureFlagUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeatureFlagPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one FeatureFlag.
     * @param {FeatureFlagUpsertArgs} args - Arguments to update or create a FeatureFlag.
     * @example
     * // Update or create a FeatureFlag
     * const featureFlag = await prisma.featureFlag.upsert({
     *   create: {
     *     // ... data to create a FeatureFlag
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FeatureFlag we want to update
     *   }
     * })
     */
    upsert<T extends FeatureFlagUpsertArgs>(args: SelectSubset<T, FeatureFlagUpsertArgs<ExtArgs>>): Prisma__FeatureFlagClient<$Result.GetResult<Prisma.$FeatureFlagPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of FeatureFlags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeatureFlagCountArgs} args - Arguments to filter FeatureFlags to count.
     * @example
     * // Count the number of FeatureFlags
     * const count = await prisma.featureFlag.count({
     *   where: {
     *     // ... the filter for the FeatureFlags we want to count
     *   }
     * })
    **/
    count<T extends FeatureFlagCountArgs>(
      args?: Subset<T, FeatureFlagCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FeatureFlagCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FeatureFlag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeatureFlagAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FeatureFlagAggregateArgs>(args: Subset<T, FeatureFlagAggregateArgs>): Prisma.PrismaPromise<GetFeatureFlagAggregateType<T>>

    /**
     * Group by FeatureFlag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeatureFlagGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FeatureFlagGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FeatureFlagGroupByArgs['orderBy'] }
        : { orderBy?: FeatureFlagGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FeatureFlagGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFeatureFlagGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FeatureFlag model
   */
  readonly fields: FeatureFlagFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FeatureFlag.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FeatureFlagClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FeatureFlag model
   */
  interface FeatureFlagFieldRefs {
    readonly id: FieldRef<"FeatureFlag", 'String'>
    readonly key: FieldRef<"FeatureFlag", 'String'>
    readonly name: FieldRef<"FeatureFlag", 'String'>
    readonly description: FieldRef<"FeatureFlag", 'String'>
    readonly enabled: FieldRef<"FeatureFlag", 'Boolean'>
    readonly isMvp: FieldRef<"FeatureFlag", 'Boolean'>
    readonly createdAt: FieldRef<"FeatureFlag", 'DateTime'>
    readonly updatedAt: FieldRef<"FeatureFlag", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * FeatureFlag findUnique
   */
  export type FeatureFlagFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeatureFlag
     */
    select?: FeatureFlagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeatureFlag
     */
    omit?: FeatureFlagOmit<ExtArgs> | null
    /**
     * Filter, which FeatureFlag to fetch.
     */
    where: FeatureFlagWhereUniqueInput
  }

  /**
   * FeatureFlag findUniqueOrThrow
   */
  export type FeatureFlagFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeatureFlag
     */
    select?: FeatureFlagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeatureFlag
     */
    omit?: FeatureFlagOmit<ExtArgs> | null
    /**
     * Filter, which FeatureFlag to fetch.
     */
    where: FeatureFlagWhereUniqueInput
  }

  /**
   * FeatureFlag findFirst
   */
  export type FeatureFlagFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeatureFlag
     */
    select?: FeatureFlagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeatureFlag
     */
    omit?: FeatureFlagOmit<ExtArgs> | null
    /**
     * Filter, which FeatureFlag to fetch.
     */
    where?: FeatureFlagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeatureFlags to fetch.
     */
    orderBy?: FeatureFlagOrderByWithRelationInput | FeatureFlagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FeatureFlags.
     */
    cursor?: FeatureFlagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeatureFlags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeatureFlags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FeatureFlags.
     */
    distinct?: FeatureFlagScalarFieldEnum | FeatureFlagScalarFieldEnum[]
  }

  /**
   * FeatureFlag findFirstOrThrow
   */
  export type FeatureFlagFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeatureFlag
     */
    select?: FeatureFlagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeatureFlag
     */
    omit?: FeatureFlagOmit<ExtArgs> | null
    /**
     * Filter, which FeatureFlag to fetch.
     */
    where?: FeatureFlagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeatureFlags to fetch.
     */
    orderBy?: FeatureFlagOrderByWithRelationInput | FeatureFlagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FeatureFlags.
     */
    cursor?: FeatureFlagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeatureFlags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeatureFlags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FeatureFlags.
     */
    distinct?: FeatureFlagScalarFieldEnum | FeatureFlagScalarFieldEnum[]
  }

  /**
   * FeatureFlag findMany
   */
  export type FeatureFlagFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeatureFlag
     */
    select?: FeatureFlagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeatureFlag
     */
    omit?: FeatureFlagOmit<ExtArgs> | null
    /**
     * Filter, which FeatureFlags to fetch.
     */
    where?: FeatureFlagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeatureFlags to fetch.
     */
    orderBy?: FeatureFlagOrderByWithRelationInput | FeatureFlagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FeatureFlags.
     */
    cursor?: FeatureFlagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeatureFlags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeatureFlags.
     */
    skip?: number
    distinct?: FeatureFlagScalarFieldEnum | FeatureFlagScalarFieldEnum[]
  }

  /**
   * FeatureFlag create
   */
  export type FeatureFlagCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeatureFlag
     */
    select?: FeatureFlagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeatureFlag
     */
    omit?: FeatureFlagOmit<ExtArgs> | null
    /**
     * The data needed to create a FeatureFlag.
     */
    data: XOR<FeatureFlagCreateInput, FeatureFlagUncheckedCreateInput>
  }

  /**
   * FeatureFlag createMany
   */
  export type FeatureFlagCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FeatureFlags.
     */
    data: FeatureFlagCreateManyInput | FeatureFlagCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FeatureFlag createManyAndReturn
   */
  export type FeatureFlagCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeatureFlag
     */
    select?: FeatureFlagSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FeatureFlag
     */
    omit?: FeatureFlagOmit<ExtArgs> | null
    /**
     * The data used to create many FeatureFlags.
     */
    data: FeatureFlagCreateManyInput | FeatureFlagCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FeatureFlag update
   */
  export type FeatureFlagUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeatureFlag
     */
    select?: FeatureFlagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeatureFlag
     */
    omit?: FeatureFlagOmit<ExtArgs> | null
    /**
     * The data needed to update a FeatureFlag.
     */
    data: XOR<FeatureFlagUpdateInput, FeatureFlagUncheckedUpdateInput>
    /**
     * Choose, which FeatureFlag to update.
     */
    where: FeatureFlagWhereUniqueInput
  }

  /**
   * FeatureFlag updateMany
   */
  export type FeatureFlagUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FeatureFlags.
     */
    data: XOR<FeatureFlagUpdateManyMutationInput, FeatureFlagUncheckedUpdateManyInput>
    /**
     * Filter which FeatureFlags to update
     */
    where?: FeatureFlagWhereInput
    /**
     * Limit how many FeatureFlags to update.
     */
    limit?: number
  }

  /**
   * FeatureFlag updateManyAndReturn
   */
  export type FeatureFlagUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeatureFlag
     */
    select?: FeatureFlagSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FeatureFlag
     */
    omit?: FeatureFlagOmit<ExtArgs> | null
    /**
     * The data used to update FeatureFlags.
     */
    data: XOR<FeatureFlagUpdateManyMutationInput, FeatureFlagUncheckedUpdateManyInput>
    /**
     * Filter which FeatureFlags to update
     */
    where?: FeatureFlagWhereInput
    /**
     * Limit how many FeatureFlags to update.
     */
    limit?: number
  }

  /**
   * FeatureFlag upsert
   */
  export type FeatureFlagUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeatureFlag
     */
    select?: FeatureFlagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeatureFlag
     */
    omit?: FeatureFlagOmit<ExtArgs> | null
    /**
     * The filter to search for the FeatureFlag to update in case it exists.
     */
    where: FeatureFlagWhereUniqueInput
    /**
     * In case the FeatureFlag found by the `where` argument doesn't exist, create a new FeatureFlag with this data.
     */
    create: XOR<FeatureFlagCreateInput, FeatureFlagUncheckedCreateInput>
    /**
     * In case the FeatureFlag was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FeatureFlagUpdateInput, FeatureFlagUncheckedUpdateInput>
  }

  /**
   * FeatureFlag delete
   */
  export type FeatureFlagDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeatureFlag
     */
    select?: FeatureFlagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeatureFlag
     */
    omit?: FeatureFlagOmit<ExtArgs> | null
    /**
     * Filter which FeatureFlag to delete.
     */
    where: FeatureFlagWhereUniqueInput
  }

  /**
   * FeatureFlag deleteMany
   */
  export type FeatureFlagDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FeatureFlags to delete
     */
    where?: FeatureFlagWhereInput
    /**
     * Limit how many FeatureFlags to delete.
     */
    limit?: number
  }

  /**
   * FeatureFlag without action
   */
  export type FeatureFlagDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeatureFlag
     */
    select?: FeatureFlagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeatureFlag
     */
    omit?: FeatureFlagOmit<ExtArgs> | null
  }


  /**
   * Model AiSuggestion
   */

  export type AggregateAiSuggestion = {
    _count: AiSuggestionCountAggregateOutputType | null
    _avg: AiSuggestionAvgAggregateOutputType | null
    _sum: AiSuggestionSumAggregateOutputType | null
    _min: AiSuggestionMinAggregateOutputType | null
    _max: AiSuggestionMaxAggregateOutputType | null
  }

  export type AiSuggestionAvgAggregateOutputType = {
    confidence: number | null
  }

  export type AiSuggestionSumAggregateOutputType = {
    confidence: number | null
  }

  export type AiSuggestionMinAggregateOutputType = {
    id: string | null
    requestId: string | null
    type: string | null
    input: string | null
    output: string | null
    confidence: number | null
    modelVersion: string | null
    isConclusive: boolean | null
    disclaimer: string | null
    createdAt: Date | null
  }

  export type AiSuggestionMaxAggregateOutputType = {
    id: string | null
    requestId: string | null
    type: string | null
    input: string | null
    output: string | null
    confidence: number | null
    modelVersion: string | null
    isConclusive: boolean | null
    disclaimer: string | null
    createdAt: Date | null
  }

  export type AiSuggestionCountAggregateOutputType = {
    id: number
    requestId: number
    type: number
    input: number
    output: number
    confidence: number
    modelVersion: number
    isConclusive: number
    disclaimer: number
    createdAt: number
    _all: number
  }


  export type AiSuggestionAvgAggregateInputType = {
    confidence?: true
  }

  export type AiSuggestionSumAggregateInputType = {
    confidence?: true
  }

  export type AiSuggestionMinAggregateInputType = {
    id?: true
    requestId?: true
    type?: true
    input?: true
    output?: true
    confidence?: true
    modelVersion?: true
    isConclusive?: true
    disclaimer?: true
    createdAt?: true
  }

  export type AiSuggestionMaxAggregateInputType = {
    id?: true
    requestId?: true
    type?: true
    input?: true
    output?: true
    confidence?: true
    modelVersion?: true
    isConclusive?: true
    disclaimer?: true
    createdAt?: true
  }

  export type AiSuggestionCountAggregateInputType = {
    id?: true
    requestId?: true
    type?: true
    input?: true
    output?: true
    confidence?: true
    modelVersion?: true
    isConclusive?: true
    disclaimer?: true
    createdAt?: true
    _all?: true
  }

  export type AiSuggestionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AiSuggestion to aggregate.
     */
    where?: AiSuggestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AiSuggestions to fetch.
     */
    orderBy?: AiSuggestionOrderByWithRelationInput | AiSuggestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AiSuggestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AiSuggestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AiSuggestions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AiSuggestions
    **/
    _count?: true | AiSuggestionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AiSuggestionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AiSuggestionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AiSuggestionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AiSuggestionMaxAggregateInputType
  }

  export type GetAiSuggestionAggregateType<T extends AiSuggestionAggregateArgs> = {
        [P in keyof T & keyof AggregateAiSuggestion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAiSuggestion[P]>
      : GetScalarType<T[P], AggregateAiSuggestion[P]>
  }




  export type AiSuggestionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AiSuggestionWhereInput
    orderBy?: AiSuggestionOrderByWithAggregationInput | AiSuggestionOrderByWithAggregationInput[]
    by: AiSuggestionScalarFieldEnum[] | AiSuggestionScalarFieldEnum
    having?: AiSuggestionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AiSuggestionCountAggregateInputType | true
    _avg?: AiSuggestionAvgAggregateInputType
    _sum?: AiSuggestionSumAggregateInputType
    _min?: AiSuggestionMinAggregateInputType
    _max?: AiSuggestionMaxAggregateInputType
  }

  export type AiSuggestionGroupByOutputType = {
    id: string
    requestId: string
    type: string
    input: string | null
    output: string | null
    confidence: number | null
    modelVersion: string | null
    isConclusive: boolean
    disclaimer: string | null
    createdAt: Date
    _count: AiSuggestionCountAggregateOutputType | null
    _avg: AiSuggestionAvgAggregateOutputType | null
    _sum: AiSuggestionSumAggregateOutputType | null
    _min: AiSuggestionMinAggregateOutputType | null
    _max: AiSuggestionMaxAggregateOutputType | null
  }

  type GetAiSuggestionGroupByPayload<T extends AiSuggestionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AiSuggestionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AiSuggestionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AiSuggestionGroupByOutputType[P]>
            : GetScalarType<T[P], AiSuggestionGroupByOutputType[P]>
        }
      >
    >


  export type AiSuggestionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    requestId?: boolean
    type?: boolean
    input?: boolean
    output?: boolean
    confidence?: boolean
    modelVersion?: boolean
    isConclusive?: boolean
    disclaimer?: boolean
    createdAt?: boolean
    request?: boolean | ServiceRequestDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aiSuggestion"]>

  export type AiSuggestionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    requestId?: boolean
    type?: boolean
    input?: boolean
    output?: boolean
    confidence?: boolean
    modelVersion?: boolean
    isConclusive?: boolean
    disclaimer?: boolean
    createdAt?: boolean
    request?: boolean | ServiceRequestDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aiSuggestion"]>

  export type AiSuggestionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    requestId?: boolean
    type?: boolean
    input?: boolean
    output?: boolean
    confidence?: boolean
    modelVersion?: boolean
    isConclusive?: boolean
    disclaimer?: boolean
    createdAt?: boolean
    request?: boolean | ServiceRequestDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aiSuggestion"]>

  export type AiSuggestionSelectScalar = {
    id?: boolean
    requestId?: boolean
    type?: boolean
    input?: boolean
    output?: boolean
    confidence?: boolean
    modelVersion?: boolean
    isConclusive?: boolean
    disclaimer?: boolean
    createdAt?: boolean
  }

  export type AiSuggestionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "requestId" | "type" | "input" | "output" | "confidence" | "modelVersion" | "isConclusive" | "disclaimer" | "createdAt", ExtArgs["result"]["aiSuggestion"]>
  export type AiSuggestionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    request?: boolean | ServiceRequestDefaultArgs<ExtArgs>
  }
  export type AiSuggestionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    request?: boolean | ServiceRequestDefaultArgs<ExtArgs>
  }
  export type AiSuggestionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    request?: boolean | ServiceRequestDefaultArgs<ExtArgs>
  }

  export type $AiSuggestionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AiSuggestion"
    objects: {
      request: Prisma.$ServiceRequestPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      requestId: string
      type: string
      input: string | null
      output: string | null
      confidence: number | null
      modelVersion: string | null
      isConclusive: boolean
      disclaimer: string | null
      createdAt: Date
    }, ExtArgs["result"]["aiSuggestion"]>
    composites: {}
  }

  type AiSuggestionGetPayload<S extends boolean | null | undefined | AiSuggestionDefaultArgs> = $Result.GetResult<Prisma.$AiSuggestionPayload, S>

  type AiSuggestionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AiSuggestionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AiSuggestionCountAggregateInputType | true
    }

  export interface AiSuggestionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AiSuggestion'], meta: { name: 'AiSuggestion' } }
    /**
     * Find zero or one AiSuggestion that matches the filter.
     * @param {AiSuggestionFindUniqueArgs} args - Arguments to find a AiSuggestion
     * @example
     * // Get one AiSuggestion
     * const aiSuggestion = await prisma.aiSuggestion.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AiSuggestionFindUniqueArgs>(args: SelectSubset<T, AiSuggestionFindUniqueArgs<ExtArgs>>): Prisma__AiSuggestionClient<$Result.GetResult<Prisma.$AiSuggestionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AiSuggestion that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AiSuggestionFindUniqueOrThrowArgs} args - Arguments to find a AiSuggestion
     * @example
     * // Get one AiSuggestion
     * const aiSuggestion = await prisma.aiSuggestion.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AiSuggestionFindUniqueOrThrowArgs>(args: SelectSubset<T, AiSuggestionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AiSuggestionClient<$Result.GetResult<Prisma.$AiSuggestionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AiSuggestion that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiSuggestionFindFirstArgs} args - Arguments to find a AiSuggestion
     * @example
     * // Get one AiSuggestion
     * const aiSuggestion = await prisma.aiSuggestion.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AiSuggestionFindFirstArgs>(args?: SelectSubset<T, AiSuggestionFindFirstArgs<ExtArgs>>): Prisma__AiSuggestionClient<$Result.GetResult<Prisma.$AiSuggestionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AiSuggestion that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiSuggestionFindFirstOrThrowArgs} args - Arguments to find a AiSuggestion
     * @example
     * // Get one AiSuggestion
     * const aiSuggestion = await prisma.aiSuggestion.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AiSuggestionFindFirstOrThrowArgs>(args?: SelectSubset<T, AiSuggestionFindFirstOrThrowArgs<ExtArgs>>): Prisma__AiSuggestionClient<$Result.GetResult<Prisma.$AiSuggestionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AiSuggestions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiSuggestionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AiSuggestions
     * const aiSuggestions = await prisma.aiSuggestion.findMany()
     * 
     * // Get first 10 AiSuggestions
     * const aiSuggestions = await prisma.aiSuggestion.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const aiSuggestionWithIdOnly = await prisma.aiSuggestion.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AiSuggestionFindManyArgs>(args?: SelectSubset<T, AiSuggestionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AiSuggestionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AiSuggestion.
     * @param {AiSuggestionCreateArgs} args - Arguments to create a AiSuggestion.
     * @example
     * // Create one AiSuggestion
     * const AiSuggestion = await prisma.aiSuggestion.create({
     *   data: {
     *     // ... data to create a AiSuggestion
     *   }
     * })
     * 
     */
    create<T extends AiSuggestionCreateArgs>(args: SelectSubset<T, AiSuggestionCreateArgs<ExtArgs>>): Prisma__AiSuggestionClient<$Result.GetResult<Prisma.$AiSuggestionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AiSuggestions.
     * @param {AiSuggestionCreateManyArgs} args - Arguments to create many AiSuggestions.
     * @example
     * // Create many AiSuggestions
     * const aiSuggestion = await prisma.aiSuggestion.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AiSuggestionCreateManyArgs>(args?: SelectSubset<T, AiSuggestionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AiSuggestions and returns the data saved in the database.
     * @param {AiSuggestionCreateManyAndReturnArgs} args - Arguments to create many AiSuggestions.
     * @example
     * // Create many AiSuggestions
     * const aiSuggestion = await prisma.aiSuggestion.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AiSuggestions and only return the `id`
     * const aiSuggestionWithIdOnly = await prisma.aiSuggestion.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AiSuggestionCreateManyAndReturnArgs>(args?: SelectSubset<T, AiSuggestionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AiSuggestionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AiSuggestion.
     * @param {AiSuggestionDeleteArgs} args - Arguments to delete one AiSuggestion.
     * @example
     * // Delete one AiSuggestion
     * const AiSuggestion = await prisma.aiSuggestion.delete({
     *   where: {
     *     // ... filter to delete one AiSuggestion
     *   }
     * })
     * 
     */
    delete<T extends AiSuggestionDeleteArgs>(args: SelectSubset<T, AiSuggestionDeleteArgs<ExtArgs>>): Prisma__AiSuggestionClient<$Result.GetResult<Prisma.$AiSuggestionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AiSuggestion.
     * @param {AiSuggestionUpdateArgs} args - Arguments to update one AiSuggestion.
     * @example
     * // Update one AiSuggestion
     * const aiSuggestion = await prisma.aiSuggestion.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AiSuggestionUpdateArgs>(args: SelectSubset<T, AiSuggestionUpdateArgs<ExtArgs>>): Prisma__AiSuggestionClient<$Result.GetResult<Prisma.$AiSuggestionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AiSuggestions.
     * @param {AiSuggestionDeleteManyArgs} args - Arguments to filter AiSuggestions to delete.
     * @example
     * // Delete a few AiSuggestions
     * const { count } = await prisma.aiSuggestion.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AiSuggestionDeleteManyArgs>(args?: SelectSubset<T, AiSuggestionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AiSuggestions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiSuggestionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AiSuggestions
     * const aiSuggestion = await prisma.aiSuggestion.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AiSuggestionUpdateManyArgs>(args: SelectSubset<T, AiSuggestionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AiSuggestions and returns the data updated in the database.
     * @param {AiSuggestionUpdateManyAndReturnArgs} args - Arguments to update many AiSuggestions.
     * @example
     * // Update many AiSuggestions
     * const aiSuggestion = await prisma.aiSuggestion.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AiSuggestions and only return the `id`
     * const aiSuggestionWithIdOnly = await prisma.aiSuggestion.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AiSuggestionUpdateManyAndReturnArgs>(args: SelectSubset<T, AiSuggestionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AiSuggestionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AiSuggestion.
     * @param {AiSuggestionUpsertArgs} args - Arguments to update or create a AiSuggestion.
     * @example
     * // Update or create a AiSuggestion
     * const aiSuggestion = await prisma.aiSuggestion.upsert({
     *   create: {
     *     // ... data to create a AiSuggestion
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AiSuggestion we want to update
     *   }
     * })
     */
    upsert<T extends AiSuggestionUpsertArgs>(args: SelectSubset<T, AiSuggestionUpsertArgs<ExtArgs>>): Prisma__AiSuggestionClient<$Result.GetResult<Prisma.$AiSuggestionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AiSuggestions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiSuggestionCountArgs} args - Arguments to filter AiSuggestions to count.
     * @example
     * // Count the number of AiSuggestions
     * const count = await prisma.aiSuggestion.count({
     *   where: {
     *     // ... the filter for the AiSuggestions we want to count
     *   }
     * })
    **/
    count<T extends AiSuggestionCountArgs>(
      args?: Subset<T, AiSuggestionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AiSuggestionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AiSuggestion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiSuggestionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AiSuggestionAggregateArgs>(args: Subset<T, AiSuggestionAggregateArgs>): Prisma.PrismaPromise<GetAiSuggestionAggregateType<T>>

    /**
     * Group by AiSuggestion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiSuggestionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AiSuggestionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AiSuggestionGroupByArgs['orderBy'] }
        : { orderBy?: AiSuggestionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AiSuggestionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAiSuggestionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AiSuggestion model
   */
  readonly fields: AiSuggestionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AiSuggestion.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AiSuggestionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    request<T extends ServiceRequestDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ServiceRequestDefaultArgs<ExtArgs>>): Prisma__ServiceRequestClient<$Result.GetResult<Prisma.$ServiceRequestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AiSuggestion model
   */
  interface AiSuggestionFieldRefs {
    readonly id: FieldRef<"AiSuggestion", 'String'>
    readonly requestId: FieldRef<"AiSuggestion", 'String'>
    readonly type: FieldRef<"AiSuggestion", 'String'>
    readonly input: FieldRef<"AiSuggestion", 'String'>
    readonly output: FieldRef<"AiSuggestion", 'String'>
    readonly confidence: FieldRef<"AiSuggestion", 'Float'>
    readonly modelVersion: FieldRef<"AiSuggestion", 'String'>
    readonly isConclusive: FieldRef<"AiSuggestion", 'Boolean'>
    readonly disclaimer: FieldRef<"AiSuggestion", 'String'>
    readonly createdAt: FieldRef<"AiSuggestion", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AiSuggestion findUnique
   */
  export type AiSuggestionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiSuggestion
     */
    select?: AiSuggestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiSuggestion
     */
    omit?: AiSuggestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiSuggestionInclude<ExtArgs> | null
    /**
     * Filter, which AiSuggestion to fetch.
     */
    where: AiSuggestionWhereUniqueInput
  }

  /**
   * AiSuggestion findUniqueOrThrow
   */
  export type AiSuggestionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiSuggestion
     */
    select?: AiSuggestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiSuggestion
     */
    omit?: AiSuggestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiSuggestionInclude<ExtArgs> | null
    /**
     * Filter, which AiSuggestion to fetch.
     */
    where: AiSuggestionWhereUniqueInput
  }

  /**
   * AiSuggestion findFirst
   */
  export type AiSuggestionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiSuggestion
     */
    select?: AiSuggestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiSuggestion
     */
    omit?: AiSuggestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiSuggestionInclude<ExtArgs> | null
    /**
     * Filter, which AiSuggestion to fetch.
     */
    where?: AiSuggestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AiSuggestions to fetch.
     */
    orderBy?: AiSuggestionOrderByWithRelationInput | AiSuggestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AiSuggestions.
     */
    cursor?: AiSuggestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AiSuggestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AiSuggestions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AiSuggestions.
     */
    distinct?: AiSuggestionScalarFieldEnum | AiSuggestionScalarFieldEnum[]
  }

  /**
   * AiSuggestion findFirstOrThrow
   */
  export type AiSuggestionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiSuggestion
     */
    select?: AiSuggestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiSuggestion
     */
    omit?: AiSuggestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiSuggestionInclude<ExtArgs> | null
    /**
     * Filter, which AiSuggestion to fetch.
     */
    where?: AiSuggestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AiSuggestions to fetch.
     */
    orderBy?: AiSuggestionOrderByWithRelationInput | AiSuggestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AiSuggestions.
     */
    cursor?: AiSuggestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AiSuggestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AiSuggestions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AiSuggestions.
     */
    distinct?: AiSuggestionScalarFieldEnum | AiSuggestionScalarFieldEnum[]
  }

  /**
   * AiSuggestion findMany
   */
  export type AiSuggestionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiSuggestion
     */
    select?: AiSuggestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiSuggestion
     */
    omit?: AiSuggestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiSuggestionInclude<ExtArgs> | null
    /**
     * Filter, which AiSuggestions to fetch.
     */
    where?: AiSuggestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AiSuggestions to fetch.
     */
    orderBy?: AiSuggestionOrderByWithRelationInput | AiSuggestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AiSuggestions.
     */
    cursor?: AiSuggestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AiSuggestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AiSuggestions.
     */
    skip?: number
    distinct?: AiSuggestionScalarFieldEnum | AiSuggestionScalarFieldEnum[]
  }

  /**
   * AiSuggestion create
   */
  export type AiSuggestionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiSuggestion
     */
    select?: AiSuggestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiSuggestion
     */
    omit?: AiSuggestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiSuggestionInclude<ExtArgs> | null
    /**
     * The data needed to create a AiSuggestion.
     */
    data: XOR<AiSuggestionCreateInput, AiSuggestionUncheckedCreateInput>
  }

  /**
   * AiSuggestion createMany
   */
  export type AiSuggestionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AiSuggestions.
     */
    data: AiSuggestionCreateManyInput | AiSuggestionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AiSuggestion createManyAndReturn
   */
  export type AiSuggestionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiSuggestion
     */
    select?: AiSuggestionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AiSuggestion
     */
    omit?: AiSuggestionOmit<ExtArgs> | null
    /**
     * The data used to create many AiSuggestions.
     */
    data: AiSuggestionCreateManyInput | AiSuggestionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiSuggestionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AiSuggestion update
   */
  export type AiSuggestionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiSuggestion
     */
    select?: AiSuggestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiSuggestion
     */
    omit?: AiSuggestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiSuggestionInclude<ExtArgs> | null
    /**
     * The data needed to update a AiSuggestion.
     */
    data: XOR<AiSuggestionUpdateInput, AiSuggestionUncheckedUpdateInput>
    /**
     * Choose, which AiSuggestion to update.
     */
    where: AiSuggestionWhereUniqueInput
  }

  /**
   * AiSuggestion updateMany
   */
  export type AiSuggestionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AiSuggestions.
     */
    data: XOR<AiSuggestionUpdateManyMutationInput, AiSuggestionUncheckedUpdateManyInput>
    /**
     * Filter which AiSuggestions to update
     */
    where?: AiSuggestionWhereInput
    /**
     * Limit how many AiSuggestions to update.
     */
    limit?: number
  }

  /**
   * AiSuggestion updateManyAndReturn
   */
  export type AiSuggestionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiSuggestion
     */
    select?: AiSuggestionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AiSuggestion
     */
    omit?: AiSuggestionOmit<ExtArgs> | null
    /**
     * The data used to update AiSuggestions.
     */
    data: XOR<AiSuggestionUpdateManyMutationInput, AiSuggestionUncheckedUpdateManyInput>
    /**
     * Filter which AiSuggestions to update
     */
    where?: AiSuggestionWhereInput
    /**
     * Limit how many AiSuggestions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiSuggestionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AiSuggestion upsert
   */
  export type AiSuggestionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiSuggestion
     */
    select?: AiSuggestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiSuggestion
     */
    omit?: AiSuggestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiSuggestionInclude<ExtArgs> | null
    /**
     * The filter to search for the AiSuggestion to update in case it exists.
     */
    where: AiSuggestionWhereUniqueInput
    /**
     * In case the AiSuggestion found by the `where` argument doesn't exist, create a new AiSuggestion with this data.
     */
    create: XOR<AiSuggestionCreateInput, AiSuggestionUncheckedCreateInput>
    /**
     * In case the AiSuggestion was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AiSuggestionUpdateInput, AiSuggestionUncheckedUpdateInput>
  }

  /**
   * AiSuggestion delete
   */
  export type AiSuggestionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiSuggestion
     */
    select?: AiSuggestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiSuggestion
     */
    omit?: AiSuggestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiSuggestionInclude<ExtArgs> | null
    /**
     * Filter which AiSuggestion to delete.
     */
    where: AiSuggestionWhereUniqueInput
  }

  /**
   * AiSuggestion deleteMany
   */
  export type AiSuggestionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AiSuggestions to delete
     */
    where?: AiSuggestionWhereInput
    /**
     * Limit how many AiSuggestions to delete.
     */
    limit?: number
  }

  /**
   * AiSuggestion without action
   */
  export type AiSuggestionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiSuggestion
     */
    select?: AiSuggestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiSuggestion
     */
    omit?: AiSuggestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiSuggestionInclude<ExtArgs> | null
  }


  /**
   * Model AiQuoteAnalysis
   */

  export type AggregateAiQuoteAnalysis = {
    _count: AiQuoteAnalysisCountAggregateOutputType | null
    _min: AiQuoteAnalysisMinAggregateOutputType | null
    _max: AiQuoteAnalysisMaxAggregateOutputType | null
  }

  export type AiQuoteAnalysisMinAggregateOutputType = {
    id: string | null
    quoteId: string | null
    type: string | null
    input: string | null
    output: string | null
    traceability: string | null
    modelVersion: string | null
    createdAt: Date | null
  }

  export type AiQuoteAnalysisMaxAggregateOutputType = {
    id: string | null
    quoteId: string | null
    type: string | null
    input: string | null
    output: string | null
    traceability: string | null
    modelVersion: string | null
    createdAt: Date | null
  }

  export type AiQuoteAnalysisCountAggregateOutputType = {
    id: number
    quoteId: number
    type: number
    input: number
    output: number
    traceability: number
    modelVersion: number
    createdAt: number
    _all: number
  }


  export type AiQuoteAnalysisMinAggregateInputType = {
    id?: true
    quoteId?: true
    type?: true
    input?: true
    output?: true
    traceability?: true
    modelVersion?: true
    createdAt?: true
  }

  export type AiQuoteAnalysisMaxAggregateInputType = {
    id?: true
    quoteId?: true
    type?: true
    input?: true
    output?: true
    traceability?: true
    modelVersion?: true
    createdAt?: true
  }

  export type AiQuoteAnalysisCountAggregateInputType = {
    id?: true
    quoteId?: true
    type?: true
    input?: true
    output?: true
    traceability?: true
    modelVersion?: true
    createdAt?: true
    _all?: true
  }

  export type AiQuoteAnalysisAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AiQuoteAnalysis to aggregate.
     */
    where?: AiQuoteAnalysisWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AiQuoteAnalyses to fetch.
     */
    orderBy?: AiQuoteAnalysisOrderByWithRelationInput | AiQuoteAnalysisOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AiQuoteAnalysisWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AiQuoteAnalyses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AiQuoteAnalyses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AiQuoteAnalyses
    **/
    _count?: true | AiQuoteAnalysisCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AiQuoteAnalysisMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AiQuoteAnalysisMaxAggregateInputType
  }

  export type GetAiQuoteAnalysisAggregateType<T extends AiQuoteAnalysisAggregateArgs> = {
        [P in keyof T & keyof AggregateAiQuoteAnalysis]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAiQuoteAnalysis[P]>
      : GetScalarType<T[P], AggregateAiQuoteAnalysis[P]>
  }




  export type AiQuoteAnalysisGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AiQuoteAnalysisWhereInput
    orderBy?: AiQuoteAnalysisOrderByWithAggregationInput | AiQuoteAnalysisOrderByWithAggregationInput[]
    by: AiQuoteAnalysisScalarFieldEnum[] | AiQuoteAnalysisScalarFieldEnum
    having?: AiQuoteAnalysisScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AiQuoteAnalysisCountAggregateInputType | true
    _min?: AiQuoteAnalysisMinAggregateInputType
    _max?: AiQuoteAnalysisMaxAggregateInputType
  }

  export type AiQuoteAnalysisGroupByOutputType = {
    id: string
    quoteId: string
    type: string
    input: string | null
    output: string | null
    traceability: string | null
    modelVersion: string | null
    createdAt: Date
    _count: AiQuoteAnalysisCountAggregateOutputType | null
    _min: AiQuoteAnalysisMinAggregateOutputType | null
    _max: AiQuoteAnalysisMaxAggregateOutputType | null
  }

  type GetAiQuoteAnalysisGroupByPayload<T extends AiQuoteAnalysisGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AiQuoteAnalysisGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AiQuoteAnalysisGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AiQuoteAnalysisGroupByOutputType[P]>
            : GetScalarType<T[P], AiQuoteAnalysisGroupByOutputType[P]>
        }
      >
    >


  export type AiQuoteAnalysisSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    quoteId?: boolean
    type?: boolean
    input?: boolean
    output?: boolean
    traceability?: boolean
    modelVersion?: boolean
    createdAt?: boolean
    quote?: boolean | QuoteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aiQuoteAnalysis"]>

  export type AiQuoteAnalysisSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    quoteId?: boolean
    type?: boolean
    input?: boolean
    output?: boolean
    traceability?: boolean
    modelVersion?: boolean
    createdAt?: boolean
    quote?: boolean | QuoteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aiQuoteAnalysis"]>

  export type AiQuoteAnalysisSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    quoteId?: boolean
    type?: boolean
    input?: boolean
    output?: boolean
    traceability?: boolean
    modelVersion?: boolean
    createdAt?: boolean
    quote?: boolean | QuoteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aiQuoteAnalysis"]>

  export type AiQuoteAnalysisSelectScalar = {
    id?: boolean
    quoteId?: boolean
    type?: boolean
    input?: boolean
    output?: boolean
    traceability?: boolean
    modelVersion?: boolean
    createdAt?: boolean
  }

  export type AiQuoteAnalysisOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "quoteId" | "type" | "input" | "output" | "traceability" | "modelVersion" | "createdAt", ExtArgs["result"]["aiQuoteAnalysis"]>
  export type AiQuoteAnalysisInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    quote?: boolean | QuoteDefaultArgs<ExtArgs>
  }
  export type AiQuoteAnalysisIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    quote?: boolean | QuoteDefaultArgs<ExtArgs>
  }
  export type AiQuoteAnalysisIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    quote?: boolean | QuoteDefaultArgs<ExtArgs>
  }

  export type $AiQuoteAnalysisPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AiQuoteAnalysis"
    objects: {
      quote: Prisma.$QuotePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      quoteId: string
      type: string
      input: string | null
      output: string | null
      traceability: string | null
      modelVersion: string | null
      createdAt: Date
    }, ExtArgs["result"]["aiQuoteAnalysis"]>
    composites: {}
  }

  type AiQuoteAnalysisGetPayload<S extends boolean | null | undefined | AiQuoteAnalysisDefaultArgs> = $Result.GetResult<Prisma.$AiQuoteAnalysisPayload, S>

  type AiQuoteAnalysisCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AiQuoteAnalysisFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AiQuoteAnalysisCountAggregateInputType | true
    }

  export interface AiQuoteAnalysisDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AiQuoteAnalysis'], meta: { name: 'AiQuoteAnalysis' } }
    /**
     * Find zero or one AiQuoteAnalysis that matches the filter.
     * @param {AiQuoteAnalysisFindUniqueArgs} args - Arguments to find a AiQuoteAnalysis
     * @example
     * // Get one AiQuoteAnalysis
     * const aiQuoteAnalysis = await prisma.aiQuoteAnalysis.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AiQuoteAnalysisFindUniqueArgs>(args: SelectSubset<T, AiQuoteAnalysisFindUniqueArgs<ExtArgs>>): Prisma__AiQuoteAnalysisClient<$Result.GetResult<Prisma.$AiQuoteAnalysisPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AiQuoteAnalysis that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AiQuoteAnalysisFindUniqueOrThrowArgs} args - Arguments to find a AiQuoteAnalysis
     * @example
     * // Get one AiQuoteAnalysis
     * const aiQuoteAnalysis = await prisma.aiQuoteAnalysis.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AiQuoteAnalysisFindUniqueOrThrowArgs>(args: SelectSubset<T, AiQuoteAnalysisFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AiQuoteAnalysisClient<$Result.GetResult<Prisma.$AiQuoteAnalysisPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AiQuoteAnalysis that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiQuoteAnalysisFindFirstArgs} args - Arguments to find a AiQuoteAnalysis
     * @example
     * // Get one AiQuoteAnalysis
     * const aiQuoteAnalysis = await prisma.aiQuoteAnalysis.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AiQuoteAnalysisFindFirstArgs>(args?: SelectSubset<T, AiQuoteAnalysisFindFirstArgs<ExtArgs>>): Prisma__AiQuoteAnalysisClient<$Result.GetResult<Prisma.$AiQuoteAnalysisPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AiQuoteAnalysis that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiQuoteAnalysisFindFirstOrThrowArgs} args - Arguments to find a AiQuoteAnalysis
     * @example
     * // Get one AiQuoteAnalysis
     * const aiQuoteAnalysis = await prisma.aiQuoteAnalysis.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AiQuoteAnalysisFindFirstOrThrowArgs>(args?: SelectSubset<T, AiQuoteAnalysisFindFirstOrThrowArgs<ExtArgs>>): Prisma__AiQuoteAnalysisClient<$Result.GetResult<Prisma.$AiQuoteAnalysisPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AiQuoteAnalyses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiQuoteAnalysisFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AiQuoteAnalyses
     * const aiQuoteAnalyses = await prisma.aiQuoteAnalysis.findMany()
     * 
     * // Get first 10 AiQuoteAnalyses
     * const aiQuoteAnalyses = await prisma.aiQuoteAnalysis.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const aiQuoteAnalysisWithIdOnly = await prisma.aiQuoteAnalysis.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AiQuoteAnalysisFindManyArgs>(args?: SelectSubset<T, AiQuoteAnalysisFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AiQuoteAnalysisPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AiQuoteAnalysis.
     * @param {AiQuoteAnalysisCreateArgs} args - Arguments to create a AiQuoteAnalysis.
     * @example
     * // Create one AiQuoteAnalysis
     * const AiQuoteAnalysis = await prisma.aiQuoteAnalysis.create({
     *   data: {
     *     // ... data to create a AiQuoteAnalysis
     *   }
     * })
     * 
     */
    create<T extends AiQuoteAnalysisCreateArgs>(args: SelectSubset<T, AiQuoteAnalysisCreateArgs<ExtArgs>>): Prisma__AiQuoteAnalysisClient<$Result.GetResult<Prisma.$AiQuoteAnalysisPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AiQuoteAnalyses.
     * @param {AiQuoteAnalysisCreateManyArgs} args - Arguments to create many AiQuoteAnalyses.
     * @example
     * // Create many AiQuoteAnalyses
     * const aiQuoteAnalysis = await prisma.aiQuoteAnalysis.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AiQuoteAnalysisCreateManyArgs>(args?: SelectSubset<T, AiQuoteAnalysisCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AiQuoteAnalyses and returns the data saved in the database.
     * @param {AiQuoteAnalysisCreateManyAndReturnArgs} args - Arguments to create many AiQuoteAnalyses.
     * @example
     * // Create many AiQuoteAnalyses
     * const aiQuoteAnalysis = await prisma.aiQuoteAnalysis.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AiQuoteAnalyses and only return the `id`
     * const aiQuoteAnalysisWithIdOnly = await prisma.aiQuoteAnalysis.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AiQuoteAnalysisCreateManyAndReturnArgs>(args?: SelectSubset<T, AiQuoteAnalysisCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AiQuoteAnalysisPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AiQuoteAnalysis.
     * @param {AiQuoteAnalysisDeleteArgs} args - Arguments to delete one AiQuoteAnalysis.
     * @example
     * // Delete one AiQuoteAnalysis
     * const AiQuoteAnalysis = await prisma.aiQuoteAnalysis.delete({
     *   where: {
     *     // ... filter to delete one AiQuoteAnalysis
     *   }
     * })
     * 
     */
    delete<T extends AiQuoteAnalysisDeleteArgs>(args: SelectSubset<T, AiQuoteAnalysisDeleteArgs<ExtArgs>>): Prisma__AiQuoteAnalysisClient<$Result.GetResult<Prisma.$AiQuoteAnalysisPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AiQuoteAnalysis.
     * @param {AiQuoteAnalysisUpdateArgs} args - Arguments to update one AiQuoteAnalysis.
     * @example
     * // Update one AiQuoteAnalysis
     * const aiQuoteAnalysis = await prisma.aiQuoteAnalysis.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AiQuoteAnalysisUpdateArgs>(args: SelectSubset<T, AiQuoteAnalysisUpdateArgs<ExtArgs>>): Prisma__AiQuoteAnalysisClient<$Result.GetResult<Prisma.$AiQuoteAnalysisPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AiQuoteAnalyses.
     * @param {AiQuoteAnalysisDeleteManyArgs} args - Arguments to filter AiQuoteAnalyses to delete.
     * @example
     * // Delete a few AiQuoteAnalyses
     * const { count } = await prisma.aiQuoteAnalysis.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AiQuoteAnalysisDeleteManyArgs>(args?: SelectSubset<T, AiQuoteAnalysisDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AiQuoteAnalyses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiQuoteAnalysisUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AiQuoteAnalyses
     * const aiQuoteAnalysis = await prisma.aiQuoteAnalysis.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AiQuoteAnalysisUpdateManyArgs>(args: SelectSubset<T, AiQuoteAnalysisUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AiQuoteAnalyses and returns the data updated in the database.
     * @param {AiQuoteAnalysisUpdateManyAndReturnArgs} args - Arguments to update many AiQuoteAnalyses.
     * @example
     * // Update many AiQuoteAnalyses
     * const aiQuoteAnalysis = await prisma.aiQuoteAnalysis.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AiQuoteAnalyses and only return the `id`
     * const aiQuoteAnalysisWithIdOnly = await prisma.aiQuoteAnalysis.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AiQuoteAnalysisUpdateManyAndReturnArgs>(args: SelectSubset<T, AiQuoteAnalysisUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AiQuoteAnalysisPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AiQuoteAnalysis.
     * @param {AiQuoteAnalysisUpsertArgs} args - Arguments to update or create a AiQuoteAnalysis.
     * @example
     * // Update or create a AiQuoteAnalysis
     * const aiQuoteAnalysis = await prisma.aiQuoteAnalysis.upsert({
     *   create: {
     *     // ... data to create a AiQuoteAnalysis
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AiQuoteAnalysis we want to update
     *   }
     * })
     */
    upsert<T extends AiQuoteAnalysisUpsertArgs>(args: SelectSubset<T, AiQuoteAnalysisUpsertArgs<ExtArgs>>): Prisma__AiQuoteAnalysisClient<$Result.GetResult<Prisma.$AiQuoteAnalysisPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AiQuoteAnalyses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiQuoteAnalysisCountArgs} args - Arguments to filter AiQuoteAnalyses to count.
     * @example
     * // Count the number of AiQuoteAnalyses
     * const count = await prisma.aiQuoteAnalysis.count({
     *   where: {
     *     // ... the filter for the AiQuoteAnalyses we want to count
     *   }
     * })
    **/
    count<T extends AiQuoteAnalysisCountArgs>(
      args?: Subset<T, AiQuoteAnalysisCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AiQuoteAnalysisCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AiQuoteAnalysis.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiQuoteAnalysisAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AiQuoteAnalysisAggregateArgs>(args: Subset<T, AiQuoteAnalysisAggregateArgs>): Prisma.PrismaPromise<GetAiQuoteAnalysisAggregateType<T>>

    /**
     * Group by AiQuoteAnalysis.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiQuoteAnalysisGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AiQuoteAnalysisGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AiQuoteAnalysisGroupByArgs['orderBy'] }
        : { orderBy?: AiQuoteAnalysisGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AiQuoteAnalysisGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAiQuoteAnalysisGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AiQuoteAnalysis model
   */
  readonly fields: AiQuoteAnalysisFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AiQuoteAnalysis.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AiQuoteAnalysisClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    quote<T extends QuoteDefaultArgs<ExtArgs> = {}>(args?: Subset<T, QuoteDefaultArgs<ExtArgs>>): Prisma__QuoteClient<$Result.GetResult<Prisma.$QuotePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AiQuoteAnalysis model
   */
  interface AiQuoteAnalysisFieldRefs {
    readonly id: FieldRef<"AiQuoteAnalysis", 'String'>
    readonly quoteId: FieldRef<"AiQuoteAnalysis", 'String'>
    readonly type: FieldRef<"AiQuoteAnalysis", 'String'>
    readonly input: FieldRef<"AiQuoteAnalysis", 'String'>
    readonly output: FieldRef<"AiQuoteAnalysis", 'String'>
    readonly traceability: FieldRef<"AiQuoteAnalysis", 'String'>
    readonly modelVersion: FieldRef<"AiQuoteAnalysis", 'String'>
    readonly createdAt: FieldRef<"AiQuoteAnalysis", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AiQuoteAnalysis findUnique
   */
  export type AiQuoteAnalysisFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiQuoteAnalysis
     */
    select?: AiQuoteAnalysisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiQuoteAnalysis
     */
    omit?: AiQuoteAnalysisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiQuoteAnalysisInclude<ExtArgs> | null
    /**
     * Filter, which AiQuoteAnalysis to fetch.
     */
    where: AiQuoteAnalysisWhereUniqueInput
  }

  /**
   * AiQuoteAnalysis findUniqueOrThrow
   */
  export type AiQuoteAnalysisFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiQuoteAnalysis
     */
    select?: AiQuoteAnalysisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiQuoteAnalysis
     */
    omit?: AiQuoteAnalysisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiQuoteAnalysisInclude<ExtArgs> | null
    /**
     * Filter, which AiQuoteAnalysis to fetch.
     */
    where: AiQuoteAnalysisWhereUniqueInput
  }

  /**
   * AiQuoteAnalysis findFirst
   */
  export type AiQuoteAnalysisFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiQuoteAnalysis
     */
    select?: AiQuoteAnalysisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiQuoteAnalysis
     */
    omit?: AiQuoteAnalysisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiQuoteAnalysisInclude<ExtArgs> | null
    /**
     * Filter, which AiQuoteAnalysis to fetch.
     */
    where?: AiQuoteAnalysisWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AiQuoteAnalyses to fetch.
     */
    orderBy?: AiQuoteAnalysisOrderByWithRelationInput | AiQuoteAnalysisOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AiQuoteAnalyses.
     */
    cursor?: AiQuoteAnalysisWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AiQuoteAnalyses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AiQuoteAnalyses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AiQuoteAnalyses.
     */
    distinct?: AiQuoteAnalysisScalarFieldEnum | AiQuoteAnalysisScalarFieldEnum[]
  }

  /**
   * AiQuoteAnalysis findFirstOrThrow
   */
  export type AiQuoteAnalysisFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiQuoteAnalysis
     */
    select?: AiQuoteAnalysisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiQuoteAnalysis
     */
    omit?: AiQuoteAnalysisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiQuoteAnalysisInclude<ExtArgs> | null
    /**
     * Filter, which AiQuoteAnalysis to fetch.
     */
    where?: AiQuoteAnalysisWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AiQuoteAnalyses to fetch.
     */
    orderBy?: AiQuoteAnalysisOrderByWithRelationInput | AiQuoteAnalysisOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AiQuoteAnalyses.
     */
    cursor?: AiQuoteAnalysisWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AiQuoteAnalyses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AiQuoteAnalyses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AiQuoteAnalyses.
     */
    distinct?: AiQuoteAnalysisScalarFieldEnum | AiQuoteAnalysisScalarFieldEnum[]
  }

  /**
   * AiQuoteAnalysis findMany
   */
  export type AiQuoteAnalysisFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiQuoteAnalysis
     */
    select?: AiQuoteAnalysisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiQuoteAnalysis
     */
    omit?: AiQuoteAnalysisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiQuoteAnalysisInclude<ExtArgs> | null
    /**
     * Filter, which AiQuoteAnalyses to fetch.
     */
    where?: AiQuoteAnalysisWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AiQuoteAnalyses to fetch.
     */
    orderBy?: AiQuoteAnalysisOrderByWithRelationInput | AiQuoteAnalysisOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AiQuoteAnalyses.
     */
    cursor?: AiQuoteAnalysisWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AiQuoteAnalyses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AiQuoteAnalyses.
     */
    skip?: number
    distinct?: AiQuoteAnalysisScalarFieldEnum | AiQuoteAnalysisScalarFieldEnum[]
  }

  /**
   * AiQuoteAnalysis create
   */
  export type AiQuoteAnalysisCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiQuoteAnalysis
     */
    select?: AiQuoteAnalysisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiQuoteAnalysis
     */
    omit?: AiQuoteAnalysisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiQuoteAnalysisInclude<ExtArgs> | null
    /**
     * The data needed to create a AiQuoteAnalysis.
     */
    data: XOR<AiQuoteAnalysisCreateInput, AiQuoteAnalysisUncheckedCreateInput>
  }

  /**
   * AiQuoteAnalysis createMany
   */
  export type AiQuoteAnalysisCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AiQuoteAnalyses.
     */
    data: AiQuoteAnalysisCreateManyInput | AiQuoteAnalysisCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AiQuoteAnalysis createManyAndReturn
   */
  export type AiQuoteAnalysisCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiQuoteAnalysis
     */
    select?: AiQuoteAnalysisSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AiQuoteAnalysis
     */
    omit?: AiQuoteAnalysisOmit<ExtArgs> | null
    /**
     * The data used to create many AiQuoteAnalyses.
     */
    data: AiQuoteAnalysisCreateManyInput | AiQuoteAnalysisCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiQuoteAnalysisIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AiQuoteAnalysis update
   */
  export type AiQuoteAnalysisUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiQuoteAnalysis
     */
    select?: AiQuoteAnalysisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiQuoteAnalysis
     */
    omit?: AiQuoteAnalysisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiQuoteAnalysisInclude<ExtArgs> | null
    /**
     * The data needed to update a AiQuoteAnalysis.
     */
    data: XOR<AiQuoteAnalysisUpdateInput, AiQuoteAnalysisUncheckedUpdateInput>
    /**
     * Choose, which AiQuoteAnalysis to update.
     */
    where: AiQuoteAnalysisWhereUniqueInput
  }

  /**
   * AiQuoteAnalysis updateMany
   */
  export type AiQuoteAnalysisUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AiQuoteAnalyses.
     */
    data: XOR<AiQuoteAnalysisUpdateManyMutationInput, AiQuoteAnalysisUncheckedUpdateManyInput>
    /**
     * Filter which AiQuoteAnalyses to update
     */
    where?: AiQuoteAnalysisWhereInput
    /**
     * Limit how many AiQuoteAnalyses to update.
     */
    limit?: number
  }

  /**
   * AiQuoteAnalysis updateManyAndReturn
   */
  export type AiQuoteAnalysisUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiQuoteAnalysis
     */
    select?: AiQuoteAnalysisSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AiQuoteAnalysis
     */
    omit?: AiQuoteAnalysisOmit<ExtArgs> | null
    /**
     * The data used to update AiQuoteAnalyses.
     */
    data: XOR<AiQuoteAnalysisUpdateManyMutationInput, AiQuoteAnalysisUncheckedUpdateManyInput>
    /**
     * Filter which AiQuoteAnalyses to update
     */
    where?: AiQuoteAnalysisWhereInput
    /**
     * Limit how many AiQuoteAnalyses to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiQuoteAnalysisIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AiQuoteAnalysis upsert
   */
  export type AiQuoteAnalysisUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiQuoteAnalysis
     */
    select?: AiQuoteAnalysisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiQuoteAnalysis
     */
    omit?: AiQuoteAnalysisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiQuoteAnalysisInclude<ExtArgs> | null
    /**
     * The filter to search for the AiQuoteAnalysis to update in case it exists.
     */
    where: AiQuoteAnalysisWhereUniqueInput
    /**
     * In case the AiQuoteAnalysis found by the `where` argument doesn't exist, create a new AiQuoteAnalysis with this data.
     */
    create: XOR<AiQuoteAnalysisCreateInput, AiQuoteAnalysisUncheckedCreateInput>
    /**
     * In case the AiQuoteAnalysis was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AiQuoteAnalysisUpdateInput, AiQuoteAnalysisUncheckedUpdateInput>
  }

  /**
   * AiQuoteAnalysis delete
   */
  export type AiQuoteAnalysisDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiQuoteAnalysis
     */
    select?: AiQuoteAnalysisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiQuoteAnalysis
     */
    omit?: AiQuoteAnalysisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiQuoteAnalysisInclude<ExtArgs> | null
    /**
     * Filter which AiQuoteAnalysis to delete.
     */
    where: AiQuoteAnalysisWhereUniqueInput
  }

  /**
   * AiQuoteAnalysis deleteMany
   */
  export type AiQuoteAnalysisDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AiQuoteAnalyses to delete
     */
    where?: AiQuoteAnalysisWhereInput
    /**
     * Limit how many AiQuoteAnalyses to delete.
     */
    limit?: number
  }

  /**
   * AiQuoteAnalysis without action
   */
  export type AiQuoteAnalysisDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiQuoteAnalysis
     */
    select?: AiQuoteAnalysisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiQuoteAnalysis
     */
    omit?: AiQuoteAnalysisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiQuoteAnalysisInclude<ExtArgs> | null
  }


  /**
   * Model AppConfig
   */

  export type AggregateAppConfig = {
    _count: AppConfigCountAggregateOutputType | null
    _min: AppConfigMinAggregateOutputType | null
    _max: AppConfigMaxAggregateOutputType | null
  }

  export type AppConfigMinAggregateOutputType = {
    id: string | null
    key: string | null
    value: string | null
    description: string | null
    updatedAt: Date | null
  }

  export type AppConfigMaxAggregateOutputType = {
    id: string | null
    key: string | null
    value: string | null
    description: string | null
    updatedAt: Date | null
  }

  export type AppConfigCountAggregateOutputType = {
    id: number
    key: number
    value: number
    description: number
    updatedAt: number
    _all: number
  }


  export type AppConfigMinAggregateInputType = {
    id?: true
    key?: true
    value?: true
    description?: true
    updatedAt?: true
  }

  export type AppConfigMaxAggregateInputType = {
    id?: true
    key?: true
    value?: true
    description?: true
    updatedAt?: true
  }

  export type AppConfigCountAggregateInputType = {
    id?: true
    key?: true
    value?: true
    description?: true
    updatedAt?: true
    _all?: true
  }

  export type AppConfigAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AppConfig to aggregate.
     */
    where?: AppConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AppConfigs to fetch.
     */
    orderBy?: AppConfigOrderByWithRelationInput | AppConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AppConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AppConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AppConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AppConfigs
    **/
    _count?: true | AppConfigCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AppConfigMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AppConfigMaxAggregateInputType
  }

  export type GetAppConfigAggregateType<T extends AppConfigAggregateArgs> = {
        [P in keyof T & keyof AggregateAppConfig]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAppConfig[P]>
      : GetScalarType<T[P], AggregateAppConfig[P]>
  }




  export type AppConfigGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AppConfigWhereInput
    orderBy?: AppConfigOrderByWithAggregationInput | AppConfigOrderByWithAggregationInput[]
    by: AppConfigScalarFieldEnum[] | AppConfigScalarFieldEnum
    having?: AppConfigScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AppConfigCountAggregateInputType | true
    _min?: AppConfigMinAggregateInputType
    _max?: AppConfigMaxAggregateInputType
  }

  export type AppConfigGroupByOutputType = {
    id: string
    key: string
    value: string
    description: string | null
    updatedAt: Date
    _count: AppConfigCountAggregateOutputType | null
    _min: AppConfigMinAggregateOutputType | null
    _max: AppConfigMaxAggregateOutputType | null
  }

  type GetAppConfigGroupByPayload<T extends AppConfigGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AppConfigGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AppConfigGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AppConfigGroupByOutputType[P]>
            : GetScalarType<T[P], AppConfigGroupByOutputType[P]>
        }
      >
    >


  export type AppConfigSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    value?: boolean
    description?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["appConfig"]>

  export type AppConfigSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    value?: boolean
    description?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["appConfig"]>

  export type AppConfigSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    value?: boolean
    description?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["appConfig"]>

  export type AppConfigSelectScalar = {
    id?: boolean
    key?: boolean
    value?: boolean
    description?: boolean
    updatedAt?: boolean
  }

  export type AppConfigOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "key" | "value" | "description" | "updatedAt", ExtArgs["result"]["appConfig"]>

  export type $AppConfigPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AppConfig"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      key: string
      value: string
      description: string | null
      updatedAt: Date
    }, ExtArgs["result"]["appConfig"]>
    composites: {}
  }

  type AppConfigGetPayload<S extends boolean | null | undefined | AppConfigDefaultArgs> = $Result.GetResult<Prisma.$AppConfigPayload, S>

  type AppConfigCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AppConfigFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AppConfigCountAggregateInputType | true
    }

  export interface AppConfigDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AppConfig'], meta: { name: 'AppConfig' } }
    /**
     * Find zero or one AppConfig that matches the filter.
     * @param {AppConfigFindUniqueArgs} args - Arguments to find a AppConfig
     * @example
     * // Get one AppConfig
     * const appConfig = await prisma.appConfig.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AppConfigFindUniqueArgs>(args: SelectSubset<T, AppConfigFindUniqueArgs<ExtArgs>>): Prisma__AppConfigClient<$Result.GetResult<Prisma.$AppConfigPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AppConfig that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AppConfigFindUniqueOrThrowArgs} args - Arguments to find a AppConfig
     * @example
     * // Get one AppConfig
     * const appConfig = await prisma.appConfig.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AppConfigFindUniqueOrThrowArgs>(args: SelectSubset<T, AppConfigFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AppConfigClient<$Result.GetResult<Prisma.$AppConfigPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AppConfig that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppConfigFindFirstArgs} args - Arguments to find a AppConfig
     * @example
     * // Get one AppConfig
     * const appConfig = await prisma.appConfig.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AppConfigFindFirstArgs>(args?: SelectSubset<T, AppConfigFindFirstArgs<ExtArgs>>): Prisma__AppConfigClient<$Result.GetResult<Prisma.$AppConfigPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AppConfig that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppConfigFindFirstOrThrowArgs} args - Arguments to find a AppConfig
     * @example
     * // Get one AppConfig
     * const appConfig = await prisma.appConfig.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AppConfigFindFirstOrThrowArgs>(args?: SelectSubset<T, AppConfigFindFirstOrThrowArgs<ExtArgs>>): Prisma__AppConfigClient<$Result.GetResult<Prisma.$AppConfigPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AppConfigs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppConfigFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AppConfigs
     * const appConfigs = await prisma.appConfig.findMany()
     * 
     * // Get first 10 AppConfigs
     * const appConfigs = await prisma.appConfig.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const appConfigWithIdOnly = await prisma.appConfig.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AppConfigFindManyArgs>(args?: SelectSubset<T, AppConfigFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AppConfigPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AppConfig.
     * @param {AppConfigCreateArgs} args - Arguments to create a AppConfig.
     * @example
     * // Create one AppConfig
     * const AppConfig = await prisma.appConfig.create({
     *   data: {
     *     // ... data to create a AppConfig
     *   }
     * })
     * 
     */
    create<T extends AppConfigCreateArgs>(args: SelectSubset<T, AppConfigCreateArgs<ExtArgs>>): Prisma__AppConfigClient<$Result.GetResult<Prisma.$AppConfigPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AppConfigs.
     * @param {AppConfigCreateManyArgs} args - Arguments to create many AppConfigs.
     * @example
     * // Create many AppConfigs
     * const appConfig = await prisma.appConfig.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AppConfigCreateManyArgs>(args?: SelectSubset<T, AppConfigCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AppConfigs and returns the data saved in the database.
     * @param {AppConfigCreateManyAndReturnArgs} args - Arguments to create many AppConfigs.
     * @example
     * // Create many AppConfigs
     * const appConfig = await prisma.appConfig.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AppConfigs and only return the `id`
     * const appConfigWithIdOnly = await prisma.appConfig.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AppConfigCreateManyAndReturnArgs>(args?: SelectSubset<T, AppConfigCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AppConfigPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AppConfig.
     * @param {AppConfigDeleteArgs} args - Arguments to delete one AppConfig.
     * @example
     * // Delete one AppConfig
     * const AppConfig = await prisma.appConfig.delete({
     *   where: {
     *     // ... filter to delete one AppConfig
     *   }
     * })
     * 
     */
    delete<T extends AppConfigDeleteArgs>(args: SelectSubset<T, AppConfigDeleteArgs<ExtArgs>>): Prisma__AppConfigClient<$Result.GetResult<Prisma.$AppConfigPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AppConfig.
     * @param {AppConfigUpdateArgs} args - Arguments to update one AppConfig.
     * @example
     * // Update one AppConfig
     * const appConfig = await prisma.appConfig.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AppConfigUpdateArgs>(args: SelectSubset<T, AppConfigUpdateArgs<ExtArgs>>): Prisma__AppConfigClient<$Result.GetResult<Prisma.$AppConfigPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AppConfigs.
     * @param {AppConfigDeleteManyArgs} args - Arguments to filter AppConfigs to delete.
     * @example
     * // Delete a few AppConfigs
     * const { count } = await prisma.appConfig.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AppConfigDeleteManyArgs>(args?: SelectSubset<T, AppConfigDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AppConfigs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppConfigUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AppConfigs
     * const appConfig = await prisma.appConfig.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AppConfigUpdateManyArgs>(args: SelectSubset<T, AppConfigUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AppConfigs and returns the data updated in the database.
     * @param {AppConfigUpdateManyAndReturnArgs} args - Arguments to update many AppConfigs.
     * @example
     * // Update many AppConfigs
     * const appConfig = await prisma.appConfig.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AppConfigs and only return the `id`
     * const appConfigWithIdOnly = await prisma.appConfig.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AppConfigUpdateManyAndReturnArgs>(args: SelectSubset<T, AppConfigUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AppConfigPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AppConfig.
     * @param {AppConfigUpsertArgs} args - Arguments to update or create a AppConfig.
     * @example
     * // Update or create a AppConfig
     * const appConfig = await prisma.appConfig.upsert({
     *   create: {
     *     // ... data to create a AppConfig
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AppConfig we want to update
     *   }
     * })
     */
    upsert<T extends AppConfigUpsertArgs>(args: SelectSubset<T, AppConfigUpsertArgs<ExtArgs>>): Prisma__AppConfigClient<$Result.GetResult<Prisma.$AppConfigPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AppConfigs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppConfigCountArgs} args - Arguments to filter AppConfigs to count.
     * @example
     * // Count the number of AppConfigs
     * const count = await prisma.appConfig.count({
     *   where: {
     *     // ... the filter for the AppConfigs we want to count
     *   }
     * })
    **/
    count<T extends AppConfigCountArgs>(
      args?: Subset<T, AppConfigCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AppConfigCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AppConfig.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppConfigAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AppConfigAggregateArgs>(args: Subset<T, AppConfigAggregateArgs>): Prisma.PrismaPromise<GetAppConfigAggregateType<T>>

    /**
     * Group by AppConfig.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppConfigGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AppConfigGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AppConfigGroupByArgs['orderBy'] }
        : { orderBy?: AppConfigGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AppConfigGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAppConfigGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AppConfig model
   */
  readonly fields: AppConfigFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AppConfig.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AppConfigClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AppConfig model
   */
  interface AppConfigFieldRefs {
    readonly id: FieldRef<"AppConfig", 'String'>
    readonly key: FieldRef<"AppConfig", 'String'>
    readonly value: FieldRef<"AppConfig", 'String'>
    readonly description: FieldRef<"AppConfig", 'String'>
    readonly updatedAt: FieldRef<"AppConfig", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AppConfig findUnique
   */
  export type AppConfigFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppConfig
     */
    select?: AppConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AppConfig
     */
    omit?: AppConfigOmit<ExtArgs> | null
    /**
     * Filter, which AppConfig to fetch.
     */
    where: AppConfigWhereUniqueInput
  }

  /**
   * AppConfig findUniqueOrThrow
   */
  export type AppConfigFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppConfig
     */
    select?: AppConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AppConfig
     */
    omit?: AppConfigOmit<ExtArgs> | null
    /**
     * Filter, which AppConfig to fetch.
     */
    where: AppConfigWhereUniqueInput
  }

  /**
   * AppConfig findFirst
   */
  export type AppConfigFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppConfig
     */
    select?: AppConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AppConfig
     */
    omit?: AppConfigOmit<ExtArgs> | null
    /**
     * Filter, which AppConfig to fetch.
     */
    where?: AppConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AppConfigs to fetch.
     */
    orderBy?: AppConfigOrderByWithRelationInput | AppConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AppConfigs.
     */
    cursor?: AppConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AppConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AppConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AppConfigs.
     */
    distinct?: AppConfigScalarFieldEnum | AppConfigScalarFieldEnum[]
  }

  /**
   * AppConfig findFirstOrThrow
   */
  export type AppConfigFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppConfig
     */
    select?: AppConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AppConfig
     */
    omit?: AppConfigOmit<ExtArgs> | null
    /**
     * Filter, which AppConfig to fetch.
     */
    where?: AppConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AppConfigs to fetch.
     */
    orderBy?: AppConfigOrderByWithRelationInput | AppConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AppConfigs.
     */
    cursor?: AppConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AppConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AppConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AppConfigs.
     */
    distinct?: AppConfigScalarFieldEnum | AppConfigScalarFieldEnum[]
  }

  /**
   * AppConfig findMany
   */
  export type AppConfigFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppConfig
     */
    select?: AppConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AppConfig
     */
    omit?: AppConfigOmit<ExtArgs> | null
    /**
     * Filter, which AppConfigs to fetch.
     */
    where?: AppConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AppConfigs to fetch.
     */
    orderBy?: AppConfigOrderByWithRelationInput | AppConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AppConfigs.
     */
    cursor?: AppConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AppConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AppConfigs.
     */
    skip?: number
    distinct?: AppConfigScalarFieldEnum | AppConfigScalarFieldEnum[]
  }

  /**
   * AppConfig create
   */
  export type AppConfigCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppConfig
     */
    select?: AppConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AppConfig
     */
    omit?: AppConfigOmit<ExtArgs> | null
    /**
     * The data needed to create a AppConfig.
     */
    data: XOR<AppConfigCreateInput, AppConfigUncheckedCreateInput>
  }

  /**
   * AppConfig createMany
   */
  export type AppConfigCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AppConfigs.
     */
    data: AppConfigCreateManyInput | AppConfigCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AppConfig createManyAndReturn
   */
  export type AppConfigCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppConfig
     */
    select?: AppConfigSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AppConfig
     */
    omit?: AppConfigOmit<ExtArgs> | null
    /**
     * The data used to create many AppConfigs.
     */
    data: AppConfigCreateManyInput | AppConfigCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AppConfig update
   */
  export type AppConfigUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppConfig
     */
    select?: AppConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AppConfig
     */
    omit?: AppConfigOmit<ExtArgs> | null
    /**
     * The data needed to update a AppConfig.
     */
    data: XOR<AppConfigUpdateInput, AppConfigUncheckedUpdateInput>
    /**
     * Choose, which AppConfig to update.
     */
    where: AppConfigWhereUniqueInput
  }

  /**
   * AppConfig updateMany
   */
  export type AppConfigUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AppConfigs.
     */
    data: XOR<AppConfigUpdateManyMutationInput, AppConfigUncheckedUpdateManyInput>
    /**
     * Filter which AppConfigs to update
     */
    where?: AppConfigWhereInput
    /**
     * Limit how many AppConfigs to update.
     */
    limit?: number
  }

  /**
   * AppConfig updateManyAndReturn
   */
  export type AppConfigUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppConfig
     */
    select?: AppConfigSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AppConfig
     */
    omit?: AppConfigOmit<ExtArgs> | null
    /**
     * The data used to update AppConfigs.
     */
    data: XOR<AppConfigUpdateManyMutationInput, AppConfigUncheckedUpdateManyInput>
    /**
     * Filter which AppConfigs to update
     */
    where?: AppConfigWhereInput
    /**
     * Limit how many AppConfigs to update.
     */
    limit?: number
  }

  /**
   * AppConfig upsert
   */
  export type AppConfigUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppConfig
     */
    select?: AppConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AppConfig
     */
    omit?: AppConfigOmit<ExtArgs> | null
    /**
     * The filter to search for the AppConfig to update in case it exists.
     */
    where: AppConfigWhereUniqueInput
    /**
     * In case the AppConfig found by the `where` argument doesn't exist, create a new AppConfig with this data.
     */
    create: XOR<AppConfigCreateInput, AppConfigUncheckedCreateInput>
    /**
     * In case the AppConfig was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AppConfigUpdateInput, AppConfigUncheckedUpdateInput>
  }

  /**
   * AppConfig delete
   */
  export type AppConfigDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppConfig
     */
    select?: AppConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AppConfig
     */
    omit?: AppConfigOmit<ExtArgs> | null
    /**
     * Filter which AppConfig to delete.
     */
    where: AppConfigWhereUniqueInput
  }

  /**
   * AppConfig deleteMany
   */
  export type AppConfigDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AppConfigs to delete
     */
    where?: AppConfigWhereInput
    /**
     * Limit how many AppConfigs to delete.
     */
    limit?: number
  }

  /**
   * AppConfig without action
   */
  export type AppConfigDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppConfig
     */
    select?: AppConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AppConfig
     */
    omit?: AppConfigOmit<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserProfileScalarFieldEnum: {
    id: 'id',
    clerkUserId: 'clerkUserId',
    role: 'role',
    email: 'email',
    phone: 'phone',
    name: 'name',
    district: 'district',
    avatarUrl: 'avatarUrl',
    notifChannel: 'notifChannel',
    phoneVisible: 'phoneVisible',
    termsAccepted: 'termsAccepted',
    termsVersion: 'termsVersion',
    termsAcceptedAt: 'termsAcceptedAt',
    privacyAccepted: 'privacyAccepted',
    privacyVersion: 'privacyVersion',
    privacyAcceptedAt: 'privacyAcceptedAt',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserProfileScalarFieldEnum = (typeof UserProfileScalarFieldEnum)[keyof typeof UserProfileScalarFieldEnum]


  export const MotorcycleScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    brand: 'brand',
    model: 'model',
    year: 'year',
    displacement: 'displacement',
    use: 'use',
    kmApprox: 'kmApprox',
    placa: 'placa',
    alias: 'alias',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MotorcycleScalarFieldEnum = (typeof MotorcycleScalarFieldEnum)[keyof typeof MotorcycleScalarFieldEnum]


  export const CategoryScalarFieldEnum: {
    id: 'id',
    name: 'name',
    slug: 'slug',
    description: 'description',
    parentId: 'parentId',
    version: 'version',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CategoryScalarFieldEnum = (typeof CategoryScalarFieldEnum)[keyof typeof CategoryScalarFieldEnum]


  export const GuideQuestionScalarFieldEnum: {
    id: 'id',
    categoryId: 'categoryId',
    question: 'question',
    inputType: 'inputType',
    options: 'options',
    order: 'order',
    isActive: 'isActive',
    createdAt: 'createdAt'
  };

  export type GuideQuestionScalarFieldEnum = (typeof GuideQuestionScalarFieldEnum)[keyof typeof GuideQuestionScalarFieldEnum]


  export const GuideAnswerScalarFieldEnum: {
    id: 'id',
    questionId: 'questionId',
    requestId: 'requestId',
    answer: 'answer',
    createdAt: 'createdAt'
  };

  export type GuideAnswerScalarFieldEnum = (typeof GuideAnswerScalarFieldEnum)[keyof typeof GuideAnswerScalarFieldEnum]


  export const ServiceRequestScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    motorcycleId: 'motorcycleId',
    categoryId: 'categoryId',
    description: 'description',
    district: 'district',
    urgency: 'urgency',
    status: 'status',
    completionScore: 'completionScore',
    expiresAt: 'expiresAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ServiceRequestScalarFieldEnum = (typeof ServiceRequestScalarFieldEnum)[keyof typeof ServiceRequestScalarFieldEnum]


  export const RequestMediaScalarFieldEnum: {
    id: 'id',
    requestId: 'requestId',
    url: 'url',
    mediaType: 'mediaType',
    fileName: 'fileName',
    fileSize: 'fileSize',
    createdAt: 'createdAt'
  };

  export type RequestMediaScalarFieldEnum = (typeof RequestMediaScalarFieldEnum)[keyof typeof RequestMediaScalarFieldEnum]


  export const RequestStatusHistoryScalarFieldEnum: {
    id: 'id',
    requestId: 'requestId',
    fromStatus: 'fromStatus',
    toStatus: 'toStatus',
    actorId: 'actorId',
    reason: 'reason',
    createdAt: 'createdAt'
  };

  export type RequestStatusHistoryScalarFieldEnum = (typeof RequestStatusHistoryScalarFieldEnum)[keyof typeof RequestStatusHistoryScalarFieldEnum]


  export const WorkshopScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    name: 'name',
    address: 'address',
    district: 'district',
    phone: 'phone',
    ruc: 'ruc',
    description: 'description',
    photoUrl: 'photoUrl',
    status: 'status',
    transparencyAccepted: 'transparencyAccepted',
    guaranteePolicy: 'guaranteePolicy',
    latitude: 'latitude',
    longitude: 'longitude',
    rating: 'rating',
    totalServices: 'totalServices',
    evidenceRate: 'evidenceRate',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type WorkshopScalarFieldEnum = (typeof WorkshopScalarFieldEnum)[keyof typeof WorkshopScalarFieldEnum]


  export const WorkshopCategoryScalarFieldEnum: {
    id: 'id',
    workshopId: 'workshopId',
    categoryId: 'categoryId'
  };

  export type WorkshopCategoryScalarFieldEnum = (typeof WorkshopCategoryScalarFieldEnum)[keyof typeof WorkshopCategoryScalarFieldEnum]


  export const WorkshopVerificationScalarFieldEnum: {
    id: 'id',
    workshopId: 'workshopId',
    adminId: 'adminId',
    decision: 'decision',
    reason: 'reason',
    createdAt: 'createdAt'
  };

  export type WorkshopVerificationScalarFieldEnum = (typeof WorkshopVerificationScalarFieldEnum)[keyof typeof WorkshopVerificationScalarFieldEnum]


  export const QuoteScalarFieldEnum: {
    id: 'id',
    requestId: 'requestId',
    workshopId: 'workshopId',
    version: 'version',
    diagnosis: 'diagnosis',
    laborCost: 'laborCost',
    totalParts: 'totalParts',
    totalCost: 'totalCost',
    estimatedTime: 'estimatedTime',
    validUntil: 'validUntil',
    notes: 'notes',
    status: 'status',
    rejectionReason: 'rejectionReason',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type QuoteScalarFieldEnum = (typeof QuoteScalarFieldEnum)[keyof typeof QuoteScalarFieldEnum]


  export const QuotePartItemScalarFieldEnum: {
    id: 'id',
    quoteId: 'quoteId',
    name: 'name',
    quantity: 'quantity',
    unitPrice: 'unitPrice',
    partType: 'partType',
    notes: 'notes',
    alternativeName: 'alternativeName',
    alternativePrice: 'alternativePrice',
    alternativeType: 'alternativeType',
    alternativeNotes: 'alternativeNotes',
    selectedAlternative: 'selectedAlternative',
    createdAt: 'createdAt'
  };

  export type QuotePartItemScalarFieldEnum = (typeof QuotePartItemScalarFieldEnum)[keyof typeof QuotePartItemScalarFieldEnum]


  export const WorkOrderScalarFieldEnum: {
    id: 'id',
    orderNumber: 'orderNumber',
    requestId: 'requestId',
    quoteId: 'quoteId',
    workshopId: 'workshopId',
    diagnosis: 'diagnosis',
    totalAgreed: 'totalAgreed',
    totalFinal: 'totalFinal',
    status: 'status',
    userAcceptedAt: 'userAcceptedAt',
    workshopAcceptedAt: 'workshopAcceptedAt',
    startedAt: 'startedAt',
    startNote: 'startNote',
    completedAt: 'completedAt',
    closedAt: 'closedAt',
    closureChecklist: 'closureChecklist',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type WorkOrderScalarFieldEnum = (typeof WorkOrderScalarFieldEnum)[keyof typeof WorkOrderScalarFieldEnum]


  export const ChangeRequestScalarFieldEnum: {
    id: 'id',
    workOrderId: 'workOrderId',
    description: 'description',
    justification: 'justification',
    additionalCost: 'additionalCost',
    additionalTime: 'additionalTime',
    status: 'status',
    decidedAt: 'decidedAt',
    decidedBy: 'decidedBy',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ChangeRequestScalarFieldEnum = (typeof ChangeRequestScalarFieldEnum)[keyof typeof ChangeRequestScalarFieldEnum]


  export const EvidenceScalarFieldEnum: {
    id: 'id',
    workOrderId: 'workOrderId',
    stage: 'stage',
    url: 'url',
    mediaType: 'mediaType',
    fileName: 'fileName',
    description: 'description',
    flagged: 'flagged',
    createdAt: 'createdAt'
  };

  export type EvidenceScalarFieldEnum = (typeof EvidenceScalarFieldEnum)[keyof typeof EvidenceScalarFieldEnum]


  export const ReviewScalarFieldEnum: {
    id: 'id',
    workOrderId: 'workOrderId',
    workshopId: 'workshopId',
    userId: 'userId',
    rating: 'rating',
    comment: 'comment',
    editableUntil: 'editableUntil',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ReviewScalarFieldEnum = (typeof ReviewScalarFieldEnum)[keyof typeof ReviewScalarFieldEnum]


  export const ReceiptScalarFieldEnum: {
    id: 'id',
    workOrderId: 'workOrderId',
    totalOriginal: 'totalOriginal',
    totalChanges: 'totalChanges',
    totalFinal: 'totalFinal',
    pdfUrl: 'pdfUrl',
    createdAt: 'createdAt'
  };

  export type ReceiptScalarFieldEnum = (typeof ReceiptScalarFieldEnum)[keyof typeof ReceiptScalarFieldEnum]


  export const IncidentReportScalarFieldEnum: {
    id: 'id',
    reporterId: 'reporterId',
    workshopId: 'workshopId',
    type: 'type',
    description: 'description',
    evidenceUrl: 'evidenceUrl',
    status: 'status',
    resolution: 'resolution',
    resolvedAt: 'resolvedAt',
    resolvedBy: 'resolvedBy',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type IncidentReportScalarFieldEnum = (typeof IncidentReportScalarFieldEnum)[keyof typeof IncidentReportScalarFieldEnum]


  export const ChatMessageScalarFieldEnum: {
    id: 'id',
    requestId: 'requestId',
    senderId: 'senderId',
    content: 'content',
    imageUrl: 'imageUrl',
    isRead: 'isRead',
    createdAt: 'createdAt'
  };

  export type ChatMessageScalarFieldEnum = (typeof ChatMessageScalarFieldEnum)[keyof typeof ChatMessageScalarFieldEnum]


  export const NotificationScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    requestId: 'requestId',
    title: 'title',
    body: 'body',
    channel: 'channel',
    isRead: 'isRead',
    link: 'link',
    createdAt: 'createdAt'
  };

  export type NotificationScalarFieldEnum = (typeof NotificationScalarFieldEnum)[keyof typeof NotificationScalarFieldEnum]


  export const AuditLogScalarFieldEnum: {
    id: 'id',
    actorId: 'actorId',
    action: 'action',
    targetType: 'targetType',
    targetId: 'targetId',
    reason: 'reason',
    metadata: 'metadata',
    createdAt: 'createdAt'
  };

  export type AuditLogScalarFieldEnum = (typeof AuditLogScalarFieldEnum)[keyof typeof AuditLogScalarFieldEnum]


  export const FeatureFlagScalarFieldEnum: {
    id: 'id',
    key: 'key',
    name: 'name',
    description: 'description',
    enabled: 'enabled',
    isMvp: 'isMvp',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type FeatureFlagScalarFieldEnum = (typeof FeatureFlagScalarFieldEnum)[keyof typeof FeatureFlagScalarFieldEnum]


  export const AiSuggestionScalarFieldEnum: {
    id: 'id',
    requestId: 'requestId',
    type: 'type',
    input: 'input',
    output: 'output',
    confidence: 'confidence',
    modelVersion: 'modelVersion',
    isConclusive: 'isConclusive',
    disclaimer: 'disclaimer',
    createdAt: 'createdAt'
  };

  export type AiSuggestionScalarFieldEnum = (typeof AiSuggestionScalarFieldEnum)[keyof typeof AiSuggestionScalarFieldEnum]


  export const AiQuoteAnalysisScalarFieldEnum: {
    id: 'id',
    quoteId: 'quoteId',
    type: 'type',
    input: 'input',
    output: 'output',
    traceability: 'traceability',
    modelVersion: 'modelVersion',
    createdAt: 'createdAt'
  };

  export type AiQuoteAnalysisScalarFieldEnum = (typeof AiQuoteAnalysisScalarFieldEnum)[keyof typeof AiQuoteAnalysisScalarFieldEnum]


  export const AppConfigScalarFieldEnum: {
    id: 'id',
    key: 'key',
    value: 'value',
    description: 'description',
    updatedAt: 'updatedAt'
  };

  export type AppConfigScalarFieldEnum = (typeof AppConfigScalarFieldEnum)[keyof typeof AppConfigScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'UserRole'
   */
  export type EnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole'>
    


  /**
   * Reference to a field of type 'UserRole[]'
   */
  export type ListEnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole[]'>
    


  /**
   * Reference to a field of type 'NotificationChannel'
   */
  export type EnumNotificationChannelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationChannel'>
    


  /**
   * Reference to a field of type 'NotificationChannel[]'
   */
  export type ListEnumNotificationChannelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationChannel[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'MotorcycleUse'
   */
  export type EnumMotorcycleUseFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MotorcycleUse'>
    


  /**
   * Reference to a field of type 'MotorcycleUse[]'
   */
  export type ListEnumMotorcycleUseFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MotorcycleUse[]'>
    


  /**
   * Reference to a field of type 'UrgencyLevel'
   */
  export type EnumUrgencyLevelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UrgencyLevel'>
    


  /**
   * Reference to a field of type 'UrgencyLevel[]'
   */
  export type ListEnumUrgencyLevelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UrgencyLevel[]'>
    


  /**
   * Reference to a field of type 'ServiceRequestStatus'
   */
  export type EnumServiceRequestStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ServiceRequestStatus'>
    


  /**
   * Reference to a field of type 'ServiceRequestStatus[]'
   */
  export type ListEnumServiceRequestStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ServiceRequestStatus[]'>
    


  /**
   * Reference to a field of type 'MediaType'
   */
  export type EnumMediaTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MediaType'>
    


  /**
   * Reference to a field of type 'MediaType[]'
   */
  export type ListEnumMediaTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MediaType[]'>
    


  /**
   * Reference to a field of type 'WorkshopStatus'
   */
  export type EnumWorkshopStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'WorkshopStatus'>
    


  /**
   * Reference to a field of type 'WorkshopStatus[]'
   */
  export type ListEnumWorkshopStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'WorkshopStatus[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'QuoteStatus'
   */
  export type EnumQuoteStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QuoteStatus'>
    


  /**
   * Reference to a field of type 'QuoteStatus[]'
   */
  export type ListEnumQuoteStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QuoteStatus[]'>
    


  /**
   * Reference to a field of type 'PartType'
   */
  export type EnumPartTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PartType'>
    


  /**
   * Reference to a field of type 'PartType[]'
   */
  export type ListEnumPartTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PartType[]'>
    


  /**
   * Reference to a field of type 'WorkOrderStatus'
   */
  export type EnumWorkOrderStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'WorkOrderStatus'>
    


  /**
   * Reference to a field of type 'WorkOrderStatus[]'
   */
  export type ListEnumWorkOrderStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'WorkOrderStatus[]'>
    


  /**
   * Reference to a field of type 'ChangeRequestStatus'
   */
  export type EnumChangeRequestStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ChangeRequestStatus'>
    


  /**
   * Reference to a field of type 'ChangeRequestStatus[]'
   */
  export type ListEnumChangeRequestStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ChangeRequestStatus[]'>
    


  /**
   * Reference to a field of type 'EvidenceStage'
   */
  export type EnumEvidenceStageFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EvidenceStage'>
    


  /**
   * Reference to a field of type 'EvidenceStage[]'
   */
  export type ListEnumEvidenceStageFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EvidenceStage[]'>
    


  /**
   * Reference to a field of type 'IncidentType'
   */
  export type EnumIncidentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'IncidentType'>
    


  /**
   * Reference to a field of type 'IncidentType[]'
   */
  export type ListEnumIncidentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'IncidentType[]'>
    


  /**
   * Reference to a field of type 'IncidentStatus'
   */
  export type EnumIncidentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'IncidentStatus'>
    


  /**
   * Reference to a field of type 'IncidentStatus[]'
   */
  export type ListEnumIncidentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'IncidentStatus[]'>
    


  /**
   * Reference to a field of type 'AdminActionType'
   */
  export type EnumAdminActionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AdminActionType'>
    


  /**
   * Reference to a field of type 'AdminActionType[]'
   */
  export type ListEnumAdminActionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AdminActionType[]'>
    
  /**
   * Deep Input Types
   */


  export type UserProfileWhereInput = {
    AND?: UserProfileWhereInput | UserProfileWhereInput[]
    OR?: UserProfileWhereInput[]
    NOT?: UserProfileWhereInput | UserProfileWhereInput[]
    id?: StringFilter<"UserProfile"> | string
    clerkUserId?: StringFilter<"UserProfile"> | string
    role?: EnumUserRoleFilter<"UserProfile"> | $Enums.UserRole
    email?: StringNullableFilter<"UserProfile"> | string | null
    phone?: StringNullableFilter<"UserProfile"> | string | null
    name?: StringNullableFilter<"UserProfile"> | string | null
    district?: StringNullableFilter<"UserProfile"> | string | null
    avatarUrl?: StringNullableFilter<"UserProfile"> | string | null
    notifChannel?: EnumNotificationChannelFilter<"UserProfile"> | $Enums.NotificationChannel
    phoneVisible?: BoolFilter<"UserProfile"> | boolean
    termsAccepted?: BoolFilter<"UserProfile"> | boolean
    termsVersion?: StringNullableFilter<"UserProfile"> | string | null
    termsAcceptedAt?: DateTimeNullableFilter<"UserProfile"> | Date | string | null
    privacyAccepted?: BoolFilter<"UserProfile"> | boolean
    privacyVersion?: StringNullableFilter<"UserProfile"> | string | null
    privacyAcceptedAt?: DateTimeNullableFilter<"UserProfile"> | Date | string | null
    isActive?: BoolFilter<"UserProfile"> | boolean
    createdAt?: DateTimeFilter<"UserProfile"> | Date | string
    updatedAt?: DateTimeFilter<"UserProfile"> | Date | string
    motorcycles?: MotorcycleListRelationFilter
    serviceRequests?: ServiceRequestListRelationFilter
    reviews?: ReviewListRelationFilter
    incidentReports?: IncidentReportListRelationFilter
    notifications?: NotificationListRelationFilter
    chatMessages?: ChatMessageListRelationFilter
    workshop?: XOR<WorkshopNullableScalarRelationFilter, WorkshopWhereInput> | null
  }

  export type UserProfileOrderByWithRelationInput = {
    id?: SortOrder
    clerkUserId?: SortOrder
    role?: SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    name?: SortOrderInput | SortOrder
    district?: SortOrderInput | SortOrder
    avatarUrl?: SortOrderInput | SortOrder
    notifChannel?: SortOrder
    phoneVisible?: SortOrder
    termsAccepted?: SortOrder
    termsVersion?: SortOrderInput | SortOrder
    termsAcceptedAt?: SortOrderInput | SortOrder
    privacyAccepted?: SortOrder
    privacyVersion?: SortOrderInput | SortOrder
    privacyAcceptedAt?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    motorcycles?: MotorcycleOrderByRelationAggregateInput
    serviceRequests?: ServiceRequestOrderByRelationAggregateInput
    reviews?: ReviewOrderByRelationAggregateInput
    incidentReports?: IncidentReportOrderByRelationAggregateInput
    notifications?: NotificationOrderByRelationAggregateInput
    chatMessages?: ChatMessageOrderByRelationAggregateInput
    workshop?: WorkshopOrderByWithRelationInput
  }

  export type UserProfileWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    clerkUserId?: string
    email?: string
    phone?: string
    AND?: UserProfileWhereInput | UserProfileWhereInput[]
    OR?: UserProfileWhereInput[]
    NOT?: UserProfileWhereInput | UserProfileWhereInput[]
    role?: EnumUserRoleFilter<"UserProfile"> | $Enums.UserRole
    name?: StringNullableFilter<"UserProfile"> | string | null
    district?: StringNullableFilter<"UserProfile"> | string | null
    avatarUrl?: StringNullableFilter<"UserProfile"> | string | null
    notifChannel?: EnumNotificationChannelFilter<"UserProfile"> | $Enums.NotificationChannel
    phoneVisible?: BoolFilter<"UserProfile"> | boolean
    termsAccepted?: BoolFilter<"UserProfile"> | boolean
    termsVersion?: StringNullableFilter<"UserProfile"> | string | null
    termsAcceptedAt?: DateTimeNullableFilter<"UserProfile"> | Date | string | null
    privacyAccepted?: BoolFilter<"UserProfile"> | boolean
    privacyVersion?: StringNullableFilter<"UserProfile"> | string | null
    privacyAcceptedAt?: DateTimeNullableFilter<"UserProfile"> | Date | string | null
    isActive?: BoolFilter<"UserProfile"> | boolean
    createdAt?: DateTimeFilter<"UserProfile"> | Date | string
    updatedAt?: DateTimeFilter<"UserProfile"> | Date | string
    motorcycles?: MotorcycleListRelationFilter
    serviceRequests?: ServiceRequestListRelationFilter
    reviews?: ReviewListRelationFilter
    incidentReports?: IncidentReportListRelationFilter
    notifications?: NotificationListRelationFilter
    chatMessages?: ChatMessageListRelationFilter
    workshop?: XOR<WorkshopNullableScalarRelationFilter, WorkshopWhereInput> | null
  }, "id" | "clerkUserId" | "email" | "phone">

  export type UserProfileOrderByWithAggregationInput = {
    id?: SortOrder
    clerkUserId?: SortOrder
    role?: SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    name?: SortOrderInput | SortOrder
    district?: SortOrderInput | SortOrder
    avatarUrl?: SortOrderInput | SortOrder
    notifChannel?: SortOrder
    phoneVisible?: SortOrder
    termsAccepted?: SortOrder
    termsVersion?: SortOrderInput | SortOrder
    termsAcceptedAt?: SortOrderInput | SortOrder
    privacyAccepted?: SortOrder
    privacyVersion?: SortOrderInput | SortOrder
    privacyAcceptedAt?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserProfileCountOrderByAggregateInput
    _max?: UserProfileMaxOrderByAggregateInput
    _min?: UserProfileMinOrderByAggregateInput
  }

  export type UserProfileScalarWhereWithAggregatesInput = {
    AND?: UserProfileScalarWhereWithAggregatesInput | UserProfileScalarWhereWithAggregatesInput[]
    OR?: UserProfileScalarWhereWithAggregatesInput[]
    NOT?: UserProfileScalarWhereWithAggregatesInput | UserProfileScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserProfile"> | string
    clerkUserId?: StringWithAggregatesFilter<"UserProfile"> | string
    role?: EnumUserRoleWithAggregatesFilter<"UserProfile"> | $Enums.UserRole
    email?: StringNullableWithAggregatesFilter<"UserProfile"> | string | null
    phone?: StringNullableWithAggregatesFilter<"UserProfile"> | string | null
    name?: StringNullableWithAggregatesFilter<"UserProfile"> | string | null
    district?: StringNullableWithAggregatesFilter<"UserProfile"> | string | null
    avatarUrl?: StringNullableWithAggregatesFilter<"UserProfile"> | string | null
    notifChannel?: EnumNotificationChannelWithAggregatesFilter<"UserProfile"> | $Enums.NotificationChannel
    phoneVisible?: BoolWithAggregatesFilter<"UserProfile"> | boolean
    termsAccepted?: BoolWithAggregatesFilter<"UserProfile"> | boolean
    termsVersion?: StringNullableWithAggregatesFilter<"UserProfile"> | string | null
    termsAcceptedAt?: DateTimeNullableWithAggregatesFilter<"UserProfile"> | Date | string | null
    privacyAccepted?: BoolWithAggregatesFilter<"UserProfile"> | boolean
    privacyVersion?: StringNullableWithAggregatesFilter<"UserProfile"> | string | null
    privacyAcceptedAt?: DateTimeNullableWithAggregatesFilter<"UserProfile"> | Date | string | null
    isActive?: BoolWithAggregatesFilter<"UserProfile"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"UserProfile"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"UserProfile"> | Date | string
  }

  export type MotorcycleWhereInput = {
    AND?: MotorcycleWhereInput | MotorcycleWhereInput[]
    OR?: MotorcycleWhereInput[]
    NOT?: MotorcycleWhereInput | MotorcycleWhereInput[]
    id?: StringFilter<"Motorcycle"> | string
    userId?: StringFilter<"Motorcycle"> | string
    brand?: StringFilter<"Motorcycle"> | string
    model?: StringFilter<"Motorcycle"> | string
    year?: IntFilter<"Motorcycle"> | number
    displacement?: IntNullableFilter<"Motorcycle"> | number | null
    use?: EnumMotorcycleUseNullableFilter<"Motorcycle"> | $Enums.MotorcycleUse | null
    kmApprox?: IntNullableFilter<"Motorcycle"> | number | null
    placa?: StringNullableFilter<"Motorcycle"> | string | null
    alias?: StringNullableFilter<"Motorcycle"> | string | null
    createdAt?: DateTimeFilter<"Motorcycle"> | Date | string
    updatedAt?: DateTimeFilter<"Motorcycle"> | Date | string
    user?: XOR<UserProfileScalarRelationFilter, UserProfileWhereInput>
    serviceRequests?: ServiceRequestListRelationFilter
  }

  export type MotorcycleOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    brand?: SortOrder
    model?: SortOrder
    year?: SortOrder
    displacement?: SortOrderInput | SortOrder
    use?: SortOrderInput | SortOrder
    kmApprox?: SortOrderInput | SortOrder
    placa?: SortOrderInput | SortOrder
    alias?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserProfileOrderByWithRelationInput
    serviceRequests?: ServiceRequestOrderByRelationAggregateInput
  }

  export type MotorcycleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    placa?: string
    userId_brand_model_year_alias?: MotorcycleUserIdBrandModelYearAliasCompoundUniqueInput
    AND?: MotorcycleWhereInput | MotorcycleWhereInput[]
    OR?: MotorcycleWhereInput[]
    NOT?: MotorcycleWhereInput | MotorcycleWhereInput[]
    userId?: StringFilter<"Motorcycle"> | string
    brand?: StringFilter<"Motorcycle"> | string
    model?: StringFilter<"Motorcycle"> | string
    year?: IntFilter<"Motorcycle"> | number
    displacement?: IntNullableFilter<"Motorcycle"> | number | null
    use?: EnumMotorcycleUseNullableFilter<"Motorcycle"> | $Enums.MotorcycleUse | null
    kmApprox?: IntNullableFilter<"Motorcycle"> | number | null
    alias?: StringNullableFilter<"Motorcycle"> | string | null
    createdAt?: DateTimeFilter<"Motorcycle"> | Date | string
    updatedAt?: DateTimeFilter<"Motorcycle"> | Date | string
    user?: XOR<UserProfileScalarRelationFilter, UserProfileWhereInput>
    serviceRequests?: ServiceRequestListRelationFilter
  }, "id" | "placa" | "userId_brand_model_year_alias">

  export type MotorcycleOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    brand?: SortOrder
    model?: SortOrder
    year?: SortOrder
    displacement?: SortOrderInput | SortOrder
    use?: SortOrderInput | SortOrder
    kmApprox?: SortOrderInput | SortOrder
    placa?: SortOrderInput | SortOrder
    alias?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MotorcycleCountOrderByAggregateInput
    _avg?: MotorcycleAvgOrderByAggregateInput
    _max?: MotorcycleMaxOrderByAggregateInput
    _min?: MotorcycleMinOrderByAggregateInput
    _sum?: MotorcycleSumOrderByAggregateInput
  }

  export type MotorcycleScalarWhereWithAggregatesInput = {
    AND?: MotorcycleScalarWhereWithAggregatesInput | MotorcycleScalarWhereWithAggregatesInput[]
    OR?: MotorcycleScalarWhereWithAggregatesInput[]
    NOT?: MotorcycleScalarWhereWithAggregatesInput | MotorcycleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Motorcycle"> | string
    userId?: StringWithAggregatesFilter<"Motorcycle"> | string
    brand?: StringWithAggregatesFilter<"Motorcycle"> | string
    model?: StringWithAggregatesFilter<"Motorcycle"> | string
    year?: IntWithAggregatesFilter<"Motorcycle"> | number
    displacement?: IntNullableWithAggregatesFilter<"Motorcycle"> | number | null
    use?: EnumMotorcycleUseNullableWithAggregatesFilter<"Motorcycle"> | $Enums.MotorcycleUse | null
    kmApprox?: IntNullableWithAggregatesFilter<"Motorcycle"> | number | null
    placa?: StringNullableWithAggregatesFilter<"Motorcycle"> | string | null
    alias?: StringNullableWithAggregatesFilter<"Motorcycle"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Motorcycle"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Motorcycle"> | Date | string
  }

  export type CategoryWhereInput = {
    AND?: CategoryWhereInput | CategoryWhereInput[]
    OR?: CategoryWhereInput[]
    NOT?: CategoryWhereInput | CategoryWhereInput[]
    id?: StringFilter<"Category"> | string
    name?: StringFilter<"Category"> | string
    slug?: StringFilter<"Category"> | string
    description?: StringNullableFilter<"Category"> | string | null
    parentId?: StringNullableFilter<"Category"> | string | null
    version?: IntFilter<"Category"> | number
    isActive?: BoolFilter<"Category"> | boolean
    createdAt?: DateTimeFilter<"Category"> | Date | string
    updatedAt?: DateTimeFilter<"Category"> | Date | string
    parent?: XOR<CategoryNullableScalarRelationFilter, CategoryWhereInput> | null
    children?: CategoryListRelationFilter
    guideQuestions?: GuideQuestionListRelationFilter
    serviceRequests?: ServiceRequestListRelationFilter
    workshopCategories?: WorkshopCategoryListRelationFilter
  }

  export type CategoryOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrderInput | SortOrder
    parentId?: SortOrderInput | SortOrder
    version?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    parent?: CategoryOrderByWithRelationInput
    children?: CategoryOrderByRelationAggregateInput
    guideQuestions?: GuideQuestionOrderByRelationAggregateInput
    serviceRequests?: ServiceRequestOrderByRelationAggregateInput
    workshopCategories?: WorkshopCategoryOrderByRelationAggregateInput
  }

  export type CategoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slug?: string
    AND?: CategoryWhereInput | CategoryWhereInput[]
    OR?: CategoryWhereInput[]
    NOT?: CategoryWhereInput | CategoryWhereInput[]
    name?: StringFilter<"Category"> | string
    description?: StringNullableFilter<"Category"> | string | null
    parentId?: StringNullableFilter<"Category"> | string | null
    version?: IntFilter<"Category"> | number
    isActive?: BoolFilter<"Category"> | boolean
    createdAt?: DateTimeFilter<"Category"> | Date | string
    updatedAt?: DateTimeFilter<"Category"> | Date | string
    parent?: XOR<CategoryNullableScalarRelationFilter, CategoryWhereInput> | null
    children?: CategoryListRelationFilter
    guideQuestions?: GuideQuestionListRelationFilter
    serviceRequests?: ServiceRequestListRelationFilter
    workshopCategories?: WorkshopCategoryListRelationFilter
  }, "id" | "slug">

  export type CategoryOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrderInput | SortOrder
    parentId?: SortOrderInput | SortOrder
    version?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CategoryCountOrderByAggregateInput
    _avg?: CategoryAvgOrderByAggregateInput
    _max?: CategoryMaxOrderByAggregateInput
    _min?: CategoryMinOrderByAggregateInput
    _sum?: CategorySumOrderByAggregateInput
  }

  export type CategoryScalarWhereWithAggregatesInput = {
    AND?: CategoryScalarWhereWithAggregatesInput | CategoryScalarWhereWithAggregatesInput[]
    OR?: CategoryScalarWhereWithAggregatesInput[]
    NOT?: CategoryScalarWhereWithAggregatesInput | CategoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Category"> | string
    name?: StringWithAggregatesFilter<"Category"> | string
    slug?: StringWithAggregatesFilter<"Category"> | string
    description?: StringNullableWithAggregatesFilter<"Category"> | string | null
    parentId?: StringNullableWithAggregatesFilter<"Category"> | string | null
    version?: IntWithAggregatesFilter<"Category"> | number
    isActive?: BoolWithAggregatesFilter<"Category"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Category"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Category"> | Date | string
  }

  export type GuideQuestionWhereInput = {
    AND?: GuideQuestionWhereInput | GuideQuestionWhereInput[]
    OR?: GuideQuestionWhereInput[]
    NOT?: GuideQuestionWhereInput | GuideQuestionWhereInput[]
    id?: StringFilter<"GuideQuestion"> | string
    categoryId?: StringFilter<"GuideQuestion"> | string
    question?: StringFilter<"GuideQuestion"> | string
    inputType?: StringFilter<"GuideQuestion"> | string
    options?: StringNullableFilter<"GuideQuestion"> | string | null
    order?: IntFilter<"GuideQuestion"> | number
    isActive?: BoolFilter<"GuideQuestion"> | boolean
    createdAt?: DateTimeFilter<"GuideQuestion"> | Date | string
    category?: XOR<CategoryScalarRelationFilter, CategoryWhereInput>
    answers?: GuideAnswerListRelationFilter
  }

  export type GuideQuestionOrderByWithRelationInput = {
    id?: SortOrder
    categoryId?: SortOrder
    question?: SortOrder
    inputType?: SortOrder
    options?: SortOrderInput | SortOrder
    order?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    category?: CategoryOrderByWithRelationInput
    answers?: GuideAnswerOrderByRelationAggregateInput
  }

  export type GuideQuestionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: GuideQuestionWhereInput | GuideQuestionWhereInput[]
    OR?: GuideQuestionWhereInput[]
    NOT?: GuideQuestionWhereInput | GuideQuestionWhereInput[]
    categoryId?: StringFilter<"GuideQuestion"> | string
    question?: StringFilter<"GuideQuestion"> | string
    inputType?: StringFilter<"GuideQuestion"> | string
    options?: StringNullableFilter<"GuideQuestion"> | string | null
    order?: IntFilter<"GuideQuestion"> | number
    isActive?: BoolFilter<"GuideQuestion"> | boolean
    createdAt?: DateTimeFilter<"GuideQuestion"> | Date | string
    category?: XOR<CategoryScalarRelationFilter, CategoryWhereInput>
    answers?: GuideAnswerListRelationFilter
  }, "id">

  export type GuideQuestionOrderByWithAggregationInput = {
    id?: SortOrder
    categoryId?: SortOrder
    question?: SortOrder
    inputType?: SortOrder
    options?: SortOrderInput | SortOrder
    order?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    _count?: GuideQuestionCountOrderByAggregateInput
    _avg?: GuideQuestionAvgOrderByAggregateInput
    _max?: GuideQuestionMaxOrderByAggregateInput
    _min?: GuideQuestionMinOrderByAggregateInput
    _sum?: GuideQuestionSumOrderByAggregateInput
  }

  export type GuideQuestionScalarWhereWithAggregatesInput = {
    AND?: GuideQuestionScalarWhereWithAggregatesInput | GuideQuestionScalarWhereWithAggregatesInput[]
    OR?: GuideQuestionScalarWhereWithAggregatesInput[]
    NOT?: GuideQuestionScalarWhereWithAggregatesInput | GuideQuestionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"GuideQuestion"> | string
    categoryId?: StringWithAggregatesFilter<"GuideQuestion"> | string
    question?: StringWithAggregatesFilter<"GuideQuestion"> | string
    inputType?: StringWithAggregatesFilter<"GuideQuestion"> | string
    options?: StringNullableWithAggregatesFilter<"GuideQuestion"> | string | null
    order?: IntWithAggregatesFilter<"GuideQuestion"> | number
    isActive?: BoolWithAggregatesFilter<"GuideQuestion"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"GuideQuestion"> | Date | string
  }

  export type GuideAnswerWhereInput = {
    AND?: GuideAnswerWhereInput | GuideAnswerWhereInput[]
    OR?: GuideAnswerWhereInput[]
    NOT?: GuideAnswerWhereInput | GuideAnswerWhereInput[]
    id?: StringFilter<"GuideAnswer"> | string
    questionId?: StringFilter<"GuideAnswer"> | string
    requestId?: StringFilter<"GuideAnswer"> | string
    answer?: StringFilter<"GuideAnswer"> | string
    createdAt?: DateTimeFilter<"GuideAnswer"> | Date | string
    question?: XOR<GuideQuestionScalarRelationFilter, GuideQuestionWhereInput>
    request?: XOR<ServiceRequestScalarRelationFilter, ServiceRequestWhereInput>
  }

  export type GuideAnswerOrderByWithRelationInput = {
    id?: SortOrder
    questionId?: SortOrder
    requestId?: SortOrder
    answer?: SortOrder
    createdAt?: SortOrder
    question?: GuideQuestionOrderByWithRelationInput
    request?: ServiceRequestOrderByWithRelationInput
  }

  export type GuideAnswerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: GuideAnswerWhereInput | GuideAnswerWhereInput[]
    OR?: GuideAnswerWhereInput[]
    NOT?: GuideAnswerWhereInput | GuideAnswerWhereInput[]
    questionId?: StringFilter<"GuideAnswer"> | string
    requestId?: StringFilter<"GuideAnswer"> | string
    answer?: StringFilter<"GuideAnswer"> | string
    createdAt?: DateTimeFilter<"GuideAnswer"> | Date | string
    question?: XOR<GuideQuestionScalarRelationFilter, GuideQuestionWhereInput>
    request?: XOR<ServiceRequestScalarRelationFilter, ServiceRequestWhereInput>
  }, "id">

  export type GuideAnswerOrderByWithAggregationInput = {
    id?: SortOrder
    questionId?: SortOrder
    requestId?: SortOrder
    answer?: SortOrder
    createdAt?: SortOrder
    _count?: GuideAnswerCountOrderByAggregateInput
    _max?: GuideAnswerMaxOrderByAggregateInput
    _min?: GuideAnswerMinOrderByAggregateInput
  }

  export type GuideAnswerScalarWhereWithAggregatesInput = {
    AND?: GuideAnswerScalarWhereWithAggregatesInput | GuideAnswerScalarWhereWithAggregatesInput[]
    OR?: GuideAnswerScalarWhereWithAggregatesInput[]
    NOT?: GuideAnswerScalarWhereWithAggregatesInput | GuideAnswerScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"GuideAnswer"> | string
    questionId?: StringWithAggregatesFilter<"GuideAnswer"> | string
    requestId?: StringWithAggregatesFilter<"GuideAnswer"> | string
    answer?: StringWithAggregatesFilter<"GuideAnswer"> | string
    createdAt?: DateTimeWithAggregatesFilter<"GuideAnswer"> | Date | string
  }

  export type ServiceRequestWhereInput = {
    AND?: ServiceRequestWhereInput | ServiceRequestWhereInput[]
    OR?: ServiceRequestWhereInput[]
    NOT?: ServiceRequestWhereInput | ServiceRequestWhereInput[]
    id?: StringFilter<"ServiceRequest"> | string
    userId?: StringFilter<"ServiceRequest"> | string
    motorcycleId?: StringFilter<"ServiceRequest"> | string
    categoryId?: StringFilter<"ServiceRequest"> | string
    description?: StringFilter<"ServiceRequest"> | string
    district?: StringFilter<"ServiceRequest"> | string
    urgency?: EnumUrgencyLevelFilter<"ServiceRequest"> | $Enums.UrgencyLevel
    status?: EnumServiceRequestStatusFilter<"ServiceRequest"> | $Enums.ServiceRequestStatus
    completionScore?: IntFilter<"ServiceRequest"> | number
    expiresAt?: DateTimeNullableFilter<"ServiceRequest"> | Date | string | null
    createdAt?: DateTimeFilter<"ServiceRequest"> | Date | string
    updatedAt?: DateTimeFilter<"ServiceRequest"> | Date | string
    user?: XOR<UserProfileScalarRelationFilter, UserProfileWhereInput>
    motorcycle?: XOR<MotorcycleScalarRelationFilter, MotorcycleWhereInput>
    category?: XOR<CategoryScalarRelationFilter, CategoryWhereInput>
    media?: RequestMediaListRelationFilter
    guideAnswers?: GuideAnswerListRelationFilter
    quotes?: QuoteListRelationFilter
    statusHistory?: RequestStatusHistoryListRelationFilter
    notifications?: NotificationListRelationFilter
    workOrder?: XOR<WorkOrderNullableScalarRelationFilter, WorkOrderWhereInput> | null
    chatMessages?: ChatMessageListRelationFilter
    aiSuggestions?: AiSuggestionListRelationFilter
  }

  export type ServiceRequestOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    motorcycleId?: SortOrder
    categoryId?: SortOrder
    description?: SortOrder
    district?: SortOrder
    urgency?: SortOrder
    status?: SortOrder
    completionScore?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserProfileOrderByWithRelationInput
    motorcycle?: MotorcycleOrderByWithRelationInput
    category?: CategoryOrderByWithRelationInput
    media?: RequestMediaOrderByRelationAggregateInput
    guideAnswers?: GuideAnswerOrderByRelationAggregateInput
    quotes?: QuoteOrderByRelationAggregateInput
    statusHistory?: RequestStatusHistoryOrderByRelationAggregateInput
    notifications?: NotificationOrderByRelationAggregateInput
    workOrder?: WorkOrderOrderByWithRelationInput
    chatMessages?: ChatMessageOrderByRelationAggregateInput
    aiSuggestions?: AiSuggestionOrderByRelationAggregateInput
  }

  export type ServiceRequestWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ServiceRequestWhereInput | ServiceRequestWhereInput[]
    OR?: ServiceRequestWhereInput[]
    NOT?: ServiceRequestWhereInput | ServiceRequestWhereInput[]
    userId?: StringFilter<"ServiceRequest"> | string
    motorcycleId?: StringFilter<"ServiceRequest"> | string
    categoryId?: StringFilter<"ServiceRequest"> | string
    description?: StringFilter<"ServiceRequest"> | string
    district?: StringFilter<"ServiceRequest"> | string
    urgency?: EnumUrgencyLevelFilter<"ServiceRequest"> | $Enums.UrgencyLevel
    status?: EnumServiceRequestStatusFilter<"ServiceRequest"> | $Enums.ServiceRequestStatus
    completionScore?: IntFilter<"ServiceRequest"> | number
    expiresAt?: DateTimeNullableFilter<"ServiceRequest"> | Date | string | null
    createdAt?: DateTimeFilter<"ServiceRequest"> | Date | string
    updatedAt?: DateTimeFilter<"ServiceRequest"> | Date | string
    user?: XOR<UserProfileScalarRelationFilter, UserProfileWhereInput>
    motorcycle?: XOR<MotorcycleScalarRelationFilter, MotorcycleWhereInput>
    category?: XOR<CategoryScalarRelationFilter, CategoryWhereInput>
    media?: RequestMediaListRelationFilter
    guideAnswers?: GuideAnswerListRelationFilter
    quotes?: QuoteListRelationFilter
    statusHistory?: RequestStatusHistoryListRelationFilter
    notifications?: NotificationListRelationFilter
    workOrder?: XOR<WorkOrderNullableScalarRelationFilter, WorkOrderWhereInput> | null
    chatMessages?: ChatMessageListRelationFilter
    aiSuggestions?: AiSuggestionListRelationFilter
  }, "id">

  export type ServiceRequestOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    motorcycleId?: SortOrder
    categoryId?: SortOrder
    description?: SortOrder
    district?: SortOrder
    urgency?: SortOrder
    status?: SortOrder
    completionScore?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ServiceRequestCountOrderByAggregateInput
    _avg?: ServiceRequestAvgOrderByAggregateInput
    _max?: ServiceRequestMaxOrderByAggregateInput
    _min?: ServiceRequestMinOrderByAggregateInput
    _sum?: ServiceRequestSumOrderByAggregateInput
  }

  export type ServiceRequestScalarWhereWithAggregatesInput = {
    AND?: ServiceRequestScalarWhereWithAggregatesInput | ServiceRequestScalarWhereWithAggregatesInput[]
    OR?: ServiceRequestScalarWhereWithAggregatesInput[]
    NOT?: ServiceRequestScalarWhereWithAggregatesInput | ServiceRequestScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ServiceRequest"> | string
    userId?: StringWithAggregatesFilter<"ServiceRequest"> | string
    motorcycleId?: StringWithAggregatesFilter<"ServiceRequest"> | string
    categoryId?: StringWithAggregatesFilter<"ServiceRequest"> | string
    description?: StringWithAggregatesFilter<"ServiceRequest"> | string
    district?: StringWithAggregatesFilter<"ServiceRequest"> | string
    urgency?: EnumUrgencyLevelWithAggregatesFilter<"ServiceRequest"> | $Enums.UrgencyLevel
    status?: EnumServiceRequestStatusWithAggregatesFilter<"ServiceRequest"> | $Enums.ServiceRequestStatus
    completionScore?: IntWithAggregatesFilter<"ServiceRequest"> | number
    expiresAt?: DateTimeNullableWithAggregatesFilter<"ServiceRequest"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ServiceRequest"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ServiceRequest"> | Date | string
  }

  export type RequestMediaWhereInput = {
    AND?: RequestMediaWhereInput | RequestMediaWhereInput[]
    OR?: RequestMediaWhereInput[]
    NOT?: RequestMediaWhereInput | RequestMediaWhereInput[]
    id?: StringFilter<"RequestMedia"> | string
    requestId?: StringFilter<"RequestMedia"> | string
    url?: StringFilter<"RequestMedia"> | string
    mediaType?: EnumMediaTypeFilter<"RequestMedia"> | $Enums.MediaType
    fileName?: StringNullableFilter<"RequestMedia"> | string | null
    fileSize?: IntNullableFilter<"RequestMedia"> | number | null
    createdAt?: DateTimeFilter<"RequestMedia"> | Date | string
    request?: XOR<ServiceRequestScalarRelationFilter, ServiceRequestWhereInput>
  }

  export type RequestMediaOrderByWithRelationInput = {
    id?: SortOrder
    requestId?: SortOrder
    url?: SortOrder
    mediaType?: SortOrder
    fileName?: SortOrderInput | SortOrder
    fileSize?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    request?: ServiceRequestOrderByWithRelationInput
  }

  export type RequestMediaWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: RequestMediaWhereInput | RequestMediaWhereInput[]
    OR?: RequestMediaWhereInput[]
    NOT?: RequestMediaWhereInput | RequestMediaWhereInput[]
    requestId?: StringFilter<"RequestMedia"> | string
    url?: StringFilter<"RequestMedia"> | string
    mediaType?: EnumMediaTypeFilter<"RequestMedia"> | $Enums.MediaType
    fileName?: StringNullableFilter<"RequestMedia"> | string | null
    fileSize?: IntNullableFilter<"RequestMedia"> | number | null
    createdAt?: DateTimeFilter<"RequestMedia"> | Date | string
    request?: XOR<ServiceRequestScalarRelationFilter, ServiceRequestWhereInput>
  }, "id">

  export type RequestMediaOrderByWithAggregationInput = {
    id?: SortOrder
    requestId?: SortOrder
    url?: SortOrder
    mediaType?: SortOrder
    fileName?: SortOrderInput | SortOrder
    fileSize?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: RequestMediaCountOrderByAggregateInput
    _avg?: RequestMediaAvgOrderByAggregateInput
    _max?: RequestMediaMaxOrderByAggregateInput
    _min?: RequestMediaMinOrderByAggregateInput
    _sum?: RequestMediaSumOrderByAggregateInput
  }

  export type RequestMediaScalarWhereWithAggregatesInput = {
    AND?: RequestMediaScalarWhereWithAggregatesInput | RequestMediaScalarWhereWithAggregatesInput[]
    OR?: RequestMediaScalarWhereWithAggregatesInput[]
    NOT?: RequestMediaScalarWhereWithAggregatesInput | RequestMediaScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RequestMedia"> | string
    requestId?: StringWithAggregatesFilter<"RequestMedia"> | string
    url?: StringWithAggregatesFilter<"RequestMedia"> | string
    mediaType?: EnumMediaTypeWithAggregatesFilter<"RequestMedia"> | $Enums.MediaType
    fileName?: StringNullableWithAggregatesFilter<"RequestMedia"> | string | null
    fileSize?: IntNullableWithAggregatesFilter<"RequestMedia"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"RequestMedia"> | Date | string
  }

  export type RequestStatusHistoryWhereInput = {
    AND?: RequestStatusHistoryWhereInput | RequestStatusHistoryWhereInput[]
    OR?: RequestStatusHistoryWhereInput[]
    NOT?: RequestStatusHistoryWhereInput | RequestStatusHistoryWhereInput[]
    id?: StringFilter<"RequestStatusHistory"> | string
    requestId?: StringFilter<"RequestStatusHistory"> | string
    fromStatus?: EnumServiceRequestStatusNullableFilter<"RequestStatusHistory"> | $Enums.ServiceRequestStatus | null
    toStatus?: EnumServiceRequestStatusFilter<"RequestStatusHistory"> | $Enums.ServiceRequestStatus
    actorId?: StringNullableFilter<"RequestStatusHistory"> | string | null
    reason?: StringNullableFilter<"RequestStatusHistory"> | string | null
    createdAt?: DateTimeFilter<"RequestStatusHistory"> | Date | string
    request?: XOR<ServiceRequestScalarRelationFilter, ServiceRequestWhereInput>
  }

  export type RequestStatusHistoryOrderByWithRelationInput = {
    id?: SortOrder
    requestId?: SortOrder
    fromStatus?: SortOrderInput | SortOrder
    toStatus?: SortOrder
    actorId?: SortOrderInput | SortOrder
    reason?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    request?: ServiceRequestOrderByWithRelationInput
  }

  export type RequestStatusHistoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: RequestStatusHistoryWhereInput | RequestStatusHistoryWhereInput[]
    OR?: RequestStatusHistoryWhereInput[]
    NOT?: RequestStatusHistoryWhereInput | RequestStatusHistoryWhereInput[]
    requestId?: StringFilter<"RequestStatusHistory"> | string
    fromStatus?: EnumServiceRequestStatusNullableFilter<"RequestStatusHistory"> | $Enums.ServiceRequestStatus | null
    toStatus?: EnumServiceRequestStatusFilter<"RequestStatusHistory"> | $Enums.ServiceRequestStatus
    actorId?: StringNullableFilter<"RequestStatusHistory"> | string | null
    reason?: StringNullableFilter<"RequestStatusHistory"> | string | null
    createdAt?: DateTimeFilter<"RequestStatusHistory"> | Date | string
    request?: XOR<ServiceRequestScalarRelationFilter, ServiceRequestWhereInput>
  }, "id">

  export type RequestStatusHistoryOrderByWithAggregationInput = {
    id?: SortOrder
    requestId?: SortOrder
    fromStatus?: SortOrderInput | SortOrder
    toStatus?: SortOrder
    actorId?: SortOrderInput | SortOrder
    reason?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: RequestStatusHistoryCountOrderByAggregateInput
    _max?: RequestStatusHistoryMaxOrderByAggregateInput
    _min?: RequestStatusHistoryMinOrderByAggregateInput
  }

  export type RequestStatusHistoryScalarWhereWithAggregatesInput = {
    AND?: RequestStatusHistoryScalarWhereWithAggregatesInput | RequestStatusHistoryScalarWhereWithAggregatesInput[]
    OR?: RequestStatusHistoryScalarWhereWithAggregatesInput[]
    NOT?: RequestStatusHistoryScalarWhereWithAggregatesInput | RequestStatusHistoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RequestStatusHistory"> | string
    requestId?: StringWithAggregatesFilter<"RequestStatusHistory"> | string
    fromStatus?: EnumServiceRequestStatusNullableWithAggregatesFilter<"RequestStatusHistory"> | $Enums.ServiceRequestStatus | null
    toStatus?: EnumServiceRequestStatusWithAggregatesFilter<"RequestStatusHistory"> | $Enums.ServiceRequestStatus
    actorId?: StringNullableWithAggregatesFilter<"RequestStatusHistory"> | string | null
    reason?: StringNullableWithAggregatesFilter<"RequestStatusHistory"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"RequestStatusHistory"> | Date | string
  }

  export type WorkshopWhereInput = {
    AND?: WorkshopWhereInput | WorkshopWhereInput[]
    OR?: WorkshopWhereInput[]
    NOT?: WorkshopWhereInput | WorkshopWhereInput[]
    id?: StringFilter<"Workshop"> | string
    userId?: StringFilter<"Workshop"> | string
    name?: StringFilter<"Workshop"> | string
    address?: StringFilter<"Workshop"> | string
    district?: StringFilter<"Workshop"> | string
    phone?: StringFilter<"Workshop"> | string
    ruc?: StringNullableFilter<"Workshop"> | string | null
    description?: StringNullableFilter<"Workshop"> | string | null
    photoUrl?: StringNullableFilter<"Workshop"> | string | null
    status?: EnumWorkshopStatusFilter<"Workshop"> | $Enums.WorkshopStatus
    transparencyAccepted?: BoolFilter<"Workshop"> | boolean
    guaranteePolicy?: StringNullableFilter<"Workshop"> | string | null
    latitude?: FloatNullableFilter<"Workshop"> | number | null
    longitude?: FloatNullableFilter<"Workshop"> | number | null
    rating?: FloatFilter<"Workshop"> | number
    totalServices?: IntFilter<"Workshop"> | number
    evidenceRate?: FloatFilter<"Workshop"> | number
    createdAt?: DateTimeFilter<"Workshop"> | Date | string
    updatedAt?: DateTimeFilter<"Workshop"> | Date | string
    user?: XOR<UserProfileScalarRelationFilter, UserProfileWhereInput>
    categories?: WorkshopCategoryListRelationFilter
    quotes?: QuoteListRelationFilter
    workOrders?: WorkOrderListRelationFilter
    reviews?: ReviewListRelationFilter
    incidentReports?: IncidentReportListRelationFilter
    verifications?: WorkshopVerificationListRelationFilter
  }

  export type WorkshopOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    address?: SortOrder
    district?: SortOrder
    phone?: SortOrder
    ruc?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    photoUrl?: SortOrderInput | SortOrder
    status?: SortOrder
    transparencyAccepted?: SortOrder
    guaranteePolicy?: SortOrderInput | SortOrder
    latitude?: SortOrderInput | SortOrder
    longitude?: SortOrderInput | SortOrder
    rating?: SortOrder
    totalServices?: SortOrder
    evidenceRate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserProfileOrderByWithRelationInput
    categories?: WorkshopCategoryOrderByRelationAggregateInput
    quotes?: QuoteOrderByRelationAggregateInput
    workOrders?: WorkOrderOrderByRelationAggregateInput
    reviews?: ReviewOrderByRelationAggregateInput
    incidentReports?: IncidentReportOrderByRelationAggregateInput
    verifications?: WorkshopVerificationOrderByRelationAggregateInput
  }

  export type WorkshopWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: WorkshopWhereInput | WorkshopWhereInput[]
    OR?: WorkshopWhereInput[]
    NOT?: WorkshopWhereInput | WorkshopWhereInput[]
    name?: StringFilter<"Workshop"> | string
    address?: StringFilter<"Workshop"> | string
    district?: StringFilter<"Workshop"> | string
    phone?: StringFilter<"Workshop"> | string
    ruc?: StringNullableFilter<"Workshop"> | string | null
    description?: StringNullableFilter<"Workshop"> | string | null
    photoUrl?: StringNullableFilter<"Workshop"> | string | null
    status?: EnumWorkshopStatusFilter<"Workshop"> | $Enums.WorkshopStatus
    transparencyAccepted?: BoolFilter<"Workshop"> | boolean
    guaranteePolicy?: StringNullableFilter<"Workshop"> | string | null
    latitude?: FloatNullableFilter<"Workshop"> | number | null
    longitude?: FloatNullableFilter<"Workshop"> | number | null
    rating?: FloatFilter<"Workshop"> | number
    totalServices?: IntFilter<"Workshop"> | number
    evidenceRate?: FloatFilter<"Workshop"> | number
    createdAt?: DateTimeFilter<"Workshop"> | Date | string
    updatedAt?: DateTimeFilter<"Workshop"> | Date | string
    user?: XOR<UserProfileScalarRelationFilter, UserProfileWhereInput>
    categories?: WorkshopCategoryListRelationFilter
    quotes?: QuoteListRelationFilter
    workOrders?: WorkOrderListRelationFilter
    reviews?: ReviewListRelationFilter
    incidentReports?: IncidentReportListRelationFilter
    verifications?: WorkshopVerificationListRelationFilter
  }, "id" | "userId">

  export type WorkshopOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    address?: SortOrder
    district?: SortOrder
    phone?: SortOrder
    ruc?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    photoUrl?: SortOrderInput | SortOrder
    status?: SortOrder
    transparencyAccepted?: SortOrder
    guaranteePolicy?: SortOrderInput | SortOrder
    latitude?: SortOrderInput | SortOrder
    longitude?: SortOrderInput | SortOrder
    rating?: SortOrder
    totalServices?: SortOrder
    evidenceRate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: WorkshopCountOrderByAggregateInput
    _avg?: WorkshopAvgOrderByAggregateInput
    _max?: WorkshopMaxOrderByAggregateInput
    _min?: WorkshopMinOrderByAggregateInput
    _sum?: WorkshopSumOrderByAggregateInput
  }

  export type WorkshopScalarWhereWithAggregatesInput = {
    AND?: WorkshopScalarWhereWithAggregatesInput | WorkshopScalarWhereWithAggregatesInput[]
    OR?: WorkshopScalarWhereWithAggregatesInput[]
    NOT?: WorkshopScalarWhereWithAggregatesInput | WorkshopScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Workshop"> | string
    userId?: StringWithAggregatesFilter<"Workshop"> | string
    name?: StringWithAggregatesFilter<"Workshop"> | string
    address?: StringWithAggregatesFilter<"Workshop"> | string
    district?: StringWithAggregatesFilter<"Workshop"> | string
    phone?: StringWithAggregatesFilter<"Workshop"> | string
    ruc?: StringNullableWithAggregatesFilter<"Workshop"> | string | null
    description?: StringNullableWithAggregatesFilter<"Workshop"> | string | null
    photoUrl?: StringNullableWithAggregatesFilter<"Workshop"> | string | null
    status?: EnumWorkshopStatusWithAggregatesFilter<"Workshop"> | $Enums.WorkshopStatus
    transparencyAccepted?: BoolWithAggregatesFilter<"Workshop"> | boolean
    guaranteePolicy?: StringNullableWithAggregatesFilter<"Workshop"> | string | null
    latitude?: FloatNullableWithAggregatesFilter<"Workshop"> | number | null
    longitude?: FloatNullableWithAggregatesFilter<"Workshop"> | number | null
    rating?: FloatWithAggregatesFilter<"Workshop"> | number
    totalServices?: IntWithAggregatesFilter<"Workshop"> | number
    evidenceRate?: FloatWithAggregatesFilter<"Workshop"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Workshop"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Workshop"> | Date | string
  }

  export type WorkshopCategoryWhereInput = {
    AND?: WorkshopCategoryWhereInput | WorkshopCategoryWhereInput[]
    OR?: WorkshopCategoryWhereInput[]
    NOT?: WorkshopCategoryWhereInput | WorkshopCategoryWhereInput[]
    id?: StringFilter<"WorkshopCategory"> | string
    workshopId?: StringFilter<"WorkshopCategory"> | string
    categoryId?: StringFilter<"WorkshopCategory"> | string
    workshop?: XOR<WorkshopScalarRelationFilter, WorkshopWhereInput>
    category?: XOR<CategoryScalarRelationFilter, CategoryWhereInput>
  }

  export type WorkshopCategoryOrderByWithRelationInput = {
    id?: SortOrder
    workshopId?: SortOrder
    categoryId?: SortOrder
    workshop?: WorkshopOrderByWithRelationInput
    category?: CategoryOrderByWithRelationInput
  }

  export type WorkshopCategoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    workshopId_categoryId?: WorkshopCategoryWorkshopIdCategoryIdCompoundUniqueInput
    AND?: WorkshopCategoryWhereInput | WorkshopCategoryWhereInput[]
    OR?: WorkshopCategoryWhereInput[]
    NOT?: WorkshopCategoryWhereInput | WorkshopCategoryWhereInput[]
    workshopId?: StringFilter<"WorkshopCategory"> | string
    categoryId?: StringFilter<"WorkshopCategory"> | string
    workshop?: XOR<WorkshopScalarRelationFilter, WorkshopWhereInput>
    category?: XOR<CategoryScalarRelationFilter, CategoryWhereInput>
  }, "id" | "workshopId_categoryId">

  export type WorkshopCategoryOrderByWithAggregationInput = {
    id?: SortOrder
    workshopId?: SortOrder
    categoryId?: SortOrder
    _count?: WorkshopCategoryCountOrderByAggregateInput
    _max?: WorkshopCategoryMaxOrderByAggregateInput
    _min?: WorkshopCategoryMinOrderByAggregateInput
  }

  export type WorkshopCategoryScalarWhereWithAggregatesInput = {
    AND?: WorkshopCategoryScalarWhereWithAggregatesInput | WorkshopCategoryScalarWhereWithAggregatesInput[]
    OR?: WorkshopCategoryScalarWhereWithAggregatesInput[]
    NOT?: WorkshopCategoryScalarWhereWithAggregatesInput | WorkshopCategoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"WorkshopCategory"> | string
    workshopId?: StringWithAggregatesFilter<"WorkshopCategory"> | string
    categoryId?: StringWithAggregatesFilter<"WorkshopCategory"> | string
  }

  export type WorkshopVerificationWhereInput = {
    AND?: WorkshopVerificationWhereInput | WorkshopVerificationWhereInput[]
    OR?: WorkshopVerificationWhereInput[]
    NOT?: WorkshopVerificationWhereInput | WorkshopVerificationWhereInput[]
    id?: StringFilter<"WorkshopVerification"> | string
    workshopId?: StringFilter<"WorkshopVerification"> | string
    adminId?: StringFilter<"WorkshopVerification"> | string
    decision?: EnumWorkshopStatusFilter<"WorkshopVerification"> | $Enums.WorkshopStatus
    reason?: StringFilter<"WorkshopVerification"> | string
    createdAt?: DateTimeFilter<"WorkshopVerification"> | Date | string
    workshop?: XOR<WorkshopScalarRelationFilter, WorkshopWhereInput>
  }

  export type WorkshopVerificationOrderByWithRelationInput = {
    id?: SortOrder
    workshopId?: SortOrder
    adminId?: SortOrder
    decision?: SortOrder
    reason?: SortOrder
    createdAt?: SortOrder
    workshop?: WorkshopOrderByWithRelationInput
  }

  export type WorkshopVerificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: WorkshopVerificationWhereInput | WorkshopVerificationWhereInput[]
    OR?: WorkshopVerificationWhereInput[]
    NOT?: WorkshopVerificationWhereInput | WorkshopVerificationWhereInput[]
    workshopId?: StringFilter<"WorkshopVerification"> | string
    adminId?: StringFilter<"WorkshopVerification"> | string
    decision?: EnumWorkshopStatusFilter<"WorkshopVerification"> | $Enums.WorkshopStatus
    reason?: StringFilter<"WorkshopVerification"> | string
    createdAt?: DateTimeFilter<"WorkshopVerification"> | Date | string
    workshop?: XOR<WorkshopScalarRelationFilter, WorkshopWhereInput>
  }, "id">

  export type WorkshopVerificationOrderByWithAggregationInput = {
    id?: SortOrder
    workshopId?: SortOrder
    adminId?: SortOrder
    decision?: SortOrder
    reason?: SortOrder
    createdAt?: SortOrder
    _count?: WorkshopVerificationCountOrderByAggregateInput
    _max?: WorkshopVerificationMaxOrderByAggregateInput
    _min?: WorkshopVerificationMinOrderByAggregateInput
  }

  export type WorkshopVerificationScalarWhereWithAggregatesInput = {
    AND?: WorkshopVerificationScalarWhereWithAggregatesInput | WorkshopVerificationScalarWhereWithAggregatesInput[]
    OR?: WorkshopVerificationScalarWhereWithAggregatesInput[]
    NOT?: WorkshopVerificationScalarWhereWithAggregatesInput | WorkshopVerificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"WorkshopVerification"> | string
    workshopId?: StringWithAggregatesFilter<"WorkshopVerification"> | string
    adminId?: StringWithAggregatesFilter<"WorkshopVerification"> | string
    decision?: EnumWorkshopStatusWithAggregatesFilter<"WorkshopVerification"> | $Enums.WorkshopStatus
    reason?: StringWithAggregatesFilter<"WorkshopVerification"> | string
    createdAt?: DateTimeWithAggregatesFilter<"WorkshopVerification"> | Date | string
  }

  export type QuoteWhereInput = {
    AND?: QuoteWhereInput | QuoteWhereInput[]
    OR?: QuoteWhereInput[]
    NOT?: QuoteWhereInput | QuoteWhereInput[]
    id?: StringFilter<"Quote"> | string
    requestId?: StringFilter<"Quote"> | string
    workshopId?: StringFilter<"Quote"> | string
    version?: IntFilter<"Quote"> | number
    diagnosis?: StringFilter<"Quote"> | string
    laborCost?: FloatFilter<"Quote"> | number
    totalParts?: FloatFilter<"Quote"> | number
    totalCost?: FloatFilter<"Quote"> | number
    estimatedTime?: StringFilter<"Quote"> | string
    validUntil?: DateTimeFilter<"Quote"> | Date | string
    notes?: StringNullableFilter<"Quote"> | string | null
    status?: EnumQuoteStatusFilter<"Quote"> | $Enums.QuoteStatus
    rejectionReason?: StringNullableFilter<"Quote"> | string | null
    createdAt?: DateTimeFilter<"Quote"> | Date | string
    updatedAt?: DateTimeFilter<"Quote"> | Date | string
    request?: XOR<ServiceRequestScalarRelationFilter, ServiceRequestWhereInput>
    workshop?: XOR<WorkshopScalarRelationFilter, WorkshopWhereInput>
    parts?: QuotePartItemListRelationFilter
    workOrder?: XOR<WorkOrderNullableScalarRelationFilter, WorkOrderWhereInput> | null
    aiAnalysis?: AiQuoteAnalysisListRelationFilter
  }

  export type QuoteOrderByWithRelationInput = {
    id?: SortOrder
    requestId?: SortOrder
    workshopId?: SortOrder
    version?: SortOrder
    diagnosis?: SortOrder
    laborCost?: SortOrder
    totalParts?: SortOrder
    totalCost?: SortOrder
    estimatedTime?: SortOrder
    validUntil?: SortOrder
    notes?: SortOrderInput | SortOrder
    status?: SortOrder
    rejectionReason?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    request?: ServiceRequestOrderByWithRelationInput
    workshop?: WorkshopOrderByWithRelationInput
    parts?: QuotePartItemOrderByRelationAggregateInput
    workOrder?: WorkOrderOrderByWithRelationInput
    aiAnalysis?: AiQuoteAnalysisOrderByRelationAggregateInput
  }

  export type QuoteWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: QuoteWhereInput | QuoteWhereInput[]
    OR?: QuoteWhereInput[]
    NOT?: QuoteWhereInput | QuoteWhereInput[]
    requestId?: StringFilter<"Quote"> | string
    workshopId?: StringFilter<"Quote"> | string
    version?: IntFilter<"Quote"> | number
    diagnosis?: StringFilter<"Quote"> | string
    laborCost?: FloatFilter<"Quote"> | number
    totalParts?: FloatFilter<"Quote"> | number
    totalCost?: FloatFilter<"Quote"> | number
    estimatedTime?: StringFilter<"Quote"> | string
    validUntil?: DateTimeFilter<"Quote"> | Date | string
    notes?: StringNullableFilter<"Quote"> | string | null
    status?: EnumQuoteStatusFilter<"Quote"> | $Enums.QuoteStatus
    rejectionReason?: StringNullableFilter<"Quote"> | string | null
    createdAt?: DateTimeFilter<"Quote"> | Date | string
    updatedAt?: DateTimeFilter<"Quote"> | Date | string
    request?: XOR<ServiceRequestScalarRelationFilter, ServiceRequestWhereInput>
    workshop?: XOR<WorkshopScalarRelationFilter, WorkshopWhereInput>
    parts?: QuotePartItemListRelationFilter
    workOrder?: XOR<WorkOrderNullableScalarRelationFilter, WorkOrderWhereInput> | null
    aiAnalysis?: AiQuoteAnalysisListRelationFilter
  }, "id">

  export type QuoteOrderByWithAggregationInput = {
    id?: SortOrder
    requestId?: SortOrder
    workshopId?: SortOrder
    version?: SortOrder
    diagnosis?: SortOrder
    laborCost?: SortOrder
    totalParts?: SortOrder
    totalCost?: SortOrder
    estimatedTime?: SortOrder
    validUntil?: SortOrder
    notes?: SortOrderInput | SortOrder
    status?: SortOrder
    rejectionReason?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: QuoteCountOrderByAggregateInput
    _avg?: QuoteAvgOrderByAggregateInput
    _max?: QuoteMaxOrderByAggregateInput
    _min?: QuoteMinOrderByAggregateInput
    _sum?: QuoteSumOrderByAggregateInput
  }

  export type QuoteScalarWhereWithAggregatesInput = {
    AND?: QuoteScalarWhereWithAggregatesInput | QuoteScalarWhereWithAggregatesInput[]
    OR?: QuoteScalarWhereWithAggregatesInput[]
    NOT?: QuoteScalarWhereWithAggregatesInput | QuoteScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Quote"> | string
    requestId?: StringWithAggregatesFilter<"Quote"> | string
    workshopId?: StringWithAggregatesFilter<"Quote"> | string
    version?: IntWithAggregatesFilter<"Quote"> | number
    diagnosis?: StringWithAggregatesFilter<"Quote"> | string
    laborCost?: FloatWithAggregatesFilter<"Quote"> | number
    totalParts?: FloatWithAggregatesFilter<"Quote"> | number
    totalCost?: FloatWithAggregatesFilter<"Quote"> | number
    estimatedTime?: StringWithAggregatesFilter<"Quote"> | string
    validUntil?: DateTimeWithAggregatesFilter<"Quote"> | Date | string
    notes?: StringNullableWithAggregatesFilter<"Quote"> | string | null
    status?: EnumQuoteStatusWithAggregatesFilter<"Quote"> | $Enums.QuoteStatus
    rejectionReason?: StringNullableWithAggregatesFilter<"Quote"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Quote"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Quote"> | Date | string
  }

  export type QuotePartItemWhereInput = {
    AND?: QuotePartItemWhereInput | QuotePartItemWhereInput[]
    OR?: QuotePartItemWhereInput[]
    NOT?: QuotePartItemWhereInput | QuotePartItemWhereInput[]
    id?: StringFilter<"QuotePartItem"> | string
    quoteId?: StringFilter<"QuotePartItem"> | string
    name?: StringFilter<"QuotePartItem"> | string
    quantity?: IntFilter<"QuotePartItem"> | number
    unitPrice?: FloatFilter<"QuotePartItem"> | number
    partType?: EnumPartTypeFilter<"QuotePartItem"> | $Enums.PartType
    notes?: StringNullableFilter<"QuotePartItem"> | string | null
    alternativeName?: StringNullableFilter<"QuotePartItem"> | string | null
    alternativePrice?: FloatNullableFilter<"QuotePartItem"> | number | null
    alternativeType?: EnumPartTypeNullableFilter<"QuotePartItem"> | $Enums.PartType | null
    alternativeNotes?: StringNullableFilter<"QuotePartItem"> | string | null
    selectedAlternative?: BoolFilter<"QuotePartItem"> | boolean
    createdAt?: DateTimeFilter<"QuotePartItem"> | Date | string
    quote?: XOR<QuoteScalarRelationFilter, QuoteWhereInput>
  }

  export type QuotePartItemOrderByWithRelationInput = {
    id?: SortOrder
    quoteId?: SortOrder
    name?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    partType?: SortOrder
    notes?: SortOrderInput | SortOrder
    alternativeName?: SortOrderInput | SortOrder
    alternativePrice?: SortOrderInput | SortOrder
    alternativeType?: SortOrderInput | SortOrder
    alternativeNotes?: SortOrderInput | SortOrder
    selectedAlternative?: SortOrder
    createdAt?: SortOrder
    quote?: QuoteOrderByWithRelationInput
  }

  export type QuotePartItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: QuotePartItemWhereInput | QuotePartItemWhereInput[]
    OR?: QuotePartItemWhereInput[]
    NOT?: QuotePartItemWhereInput | QuotePartItemWhereInput[]
    quoteId?: StringFilter<"QuotePartItem"> | string
    name?: StringFilter<"QuotePartItem"> | string
    quantity?: IntFilter<"QuotePartItem"> | number
    unitPrice?: FloatFilter<"QuotePartItem"> | number
    partType?: EnumPartTypeFilter<"QuotePartItem"> | $Enums.PartType
    notes?: StringNullableFilter<"QuotePartItem"> | string | null
    alternativeName?: StringNullableFilter<"QuotePartItem"> | string | null
    alternativePrice?: FloatNullableFilter<"QuotePartItem"> | number | null
    alternativeType?: EnumPartTypeNullableFilter<"QuotePartItem"> | $Enums.PartType | null
    alternativeNotes?: StringNullableFilter<"QuotePartItem"> | string | null
    selectedAlternative?: BoolFilter<"QuotePartItem"> | boolean
    createdAt?: DateTimeFilter<"QuotePartItem"> | Date | string
    quote?: XOR<QuoteScalarRelationFilter, QuoteWhereInput>
  }, "id">

  export type QuotePartItemOrderByWithAggregationInput = {
    id?: SortOrder
    quoteId?: SortOrder
    name?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    partType?: SortOrder
    notes?: SortOrderInput | SortOrder
    alternativeName?: SortOrderInput | SortOrder
    alternativePrice?: SortOrderInput | SortOrder
    alternativeType?: SortOrderInput | SortOrder
    alternativeNotes?: SortOrderInput | SortOrder
    selectedAlternative?: SortOrder
    createdAt?: SortOrder
    _count?: QuotePartItemCountOrderByAggregateInput
    _avg?: QuotePartItemAvgOrderByAggregateInput
    _max?: QuotePartItemMaxOrderByAggregateInput
    _min?: QuotePartItemMinOrderByAggregateInput
    _sum?: QuotePartItemSumOrderByAggregateInput
  }

  export type QuotePartItemScalarWhereWithAggregatesInput = {
    AND?: QuotePartItemScalarWhereWithAggregatesInput | QuotePartItemScalarWhereWithAggregatesInput[]
    OR?: QuotePartItemScalarWhereWithAggregatesInput[]
    NOT?: QuotePartItemScalarWhereWithAggregatesInput | QuotePartItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"QuotePartItem"> | string
    quoteId?: StringWithAggregatesFilter<"QuotePartItem"> | string
    name?: StringWithAggregatesFilter<"QuotePartItem"> | string
    quantity?: IntWithAggregatesFilter<"QuotePartItem"> | number
    unitPrice?: FloatWithAggregatesFilter<"QuotePartItem"> | number
    partType?: EnumPartTypeWithAggregatesFilter<"QuotePartItem"> | $Enums.PartType
    notes?: StringNullableWithAggregatesFilter<"QuotePartItem"> | string | null
    alternativeName?: StringNullableWithAggregatesFilter<"QuotePartItem"> | string | null
    alternativePrice?: FloatNullableWithAggregatesFilter<"QuotePartItem"> | number | null
    alternativeType?: EnumPartTypeNullableWithAggregatesFilter<"QuotePartItem"> | $Enums.PartType | null
    alternativeNotes?: StringNullableWithAggregatesFilter<"QuotePartItem"> | string | null
    selectedAlternative?: BoolWithAggregatesFilter<"QuotePartItem"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"QuotePartItem"> | Date | string
  }

  export type WorkOrderWhereInput = {
    AND?: WorkOrderWhereInput | WorkOrderWhereInput[]
    OR?: WorkOrderWhereInput[]
    NOT?: WorkOrderWhereInput | WorkOrderWhereInput[]
    id?: StringFilter<"WorkOrder"> | string
    orderNumber?: StringFilter<"WorkOrder"> | string
    requestId?: StringFilter<"WorkOrder"> | string
    quoteId?: StringFilter<"WorkOrder"> | string
    workshopId?: StringFilter<"WorkOrder"> | string
    diagnosis?: StringFilter<"WorkOrder"> | string
    totalAgreed?: FloatFilter<"WorkOrder"> | number
    totalFinal?: FloatNullableFilter<"WorkOrder"> | number | null
    status?: EnumWorkOrderStatusFilter<"WorkOrder"> | $Enums.WorkOrderStatus
    userAcceptedAt?: DateTimeNullableFilter<"WorkOrder"> | Date | string | null
    workshopAcceptedAt?: DateTimeNullableFilter<"WorkOrder"> | Date | string | null
    startedAt?: DateTimeNullableFilter<"WorkOrder"> | Date | string | null
    startNote?: StringNullableFilter<"WorkOrder"> | string | null
    completedAt?: DateTimeNullableFilter<"WorkOrder"> | Date | string | null
    closedAt?: DateTimeNullableFilter<"WorkOrder"> | Date | string | null
    closureChecklist?: StringNullableFilter<"WorkOrder"> | string | null
    createdAt?: DateTimeFilter<"WorkOrder"> | Date | string
    updatedAt?: DateTimeFilter<"WorkOrder"> | Date | string
    request?: XOR<ServiceRequestScalarRelationFilter, ServiceRequestWhereInput>
    quote?: XOR<QuoteScalarRelationFilter, QuoteWhereInput>
    workshop?: XOR<WorkshopScalarRelationFilter, WorkshopWhereInput>
    changeRequests?: ChangeRequestListRelationFilter
    evidences?: EvidenceListRelationFilter
    review?: XOR<ReviewNullableScalarRelationFilter, ReviewWhereInput> | null
    receipt?: XOR<ReceiptNullableScalarRelationFilter, ReceiptWhereInput> | null
  }

  export type WorkOrderOrderByWithRelationInput = {
    id?: SortOrder
    orderNumber?: SortOrder
    requestId?: SortOrder
    quoteId?: SortOrder
    workshopId?: SortOrder
    diagnosis?: SortOrder
    totalAgreed?: SortOrder
    totalFinal?: SortOrderInput | SortOrder
    status?: SortOrder
    userAcceptedAt?: SortOrderInput | SortOrder
    workshopAcceptedAt?: SortOrderInput | SortOrder
    startedAt?: SortOrderInput | SortOrder
    startNote?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    closedAt?: SortOrderInput | SortOrder
    closureChecklist?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    request?: ServiceRequestOrderByWithRelationInput
    quote?: QuoteOrderByWithRelationInput
    workshop?: WorkshopOrderByWithRelationInput
    changeRequests?: ChangeRequestOrderByRelationAggregateInput
    evidences?: EvidenceOrderByRelationAggregateInput
    review?: ReviewOrderByWithRelationInput
    receipt?: ReceiptOrderByWithRelationInput
  }

  export type WorkOrderWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    orderNumber?: string
    requestId?: string
    quoteId?: string
    AND?: WorkOrderWhereInput | WorkOrderWhereInput[]
    OR?: WorkOrderWhereInput[]
    NOT?: WorkOrderWhereInput | WorkOrderWhereInput[]
    workshopId?: StringFilter<"WorkOrder"> | string
    diagnosis?: StringFilter<"WorkOrder"> | string
    totalAgreed?: FloatFilter<"WorkOrder"> | number
    totalFinal?: FloatNullableFilter<"WorkOrder"> | number | null
    status?: EnumWorkOrderStatusFilter<"WorkOrder"> | $Enums.WorkOrderStatus
    userAcceptedAt?: DateTimeNullableFilter<"WorkOrder"> | Date | string | null
    workshopAcceptedAt?: DateTimeNullableFilter<"WorkOrder"> | Date | string | null
    startedAt?: DateTimeNullableFilter<"WorkOrder"> | Date | string | null
    startNote?: StringNullableFilter<"WorkOrder"> | string | null
    completedAt?: DateTimeNullableFilter<"WorkOrder"> | Date | string | null
    closedAt?: DateTimeNullableFilter<"WorkOrder"> | Date | string | null
    closureChecklist?: StringNullableFilter<"WorkOrder"> | string | null
    createdAt?: DateTimeFilter<"WorkOrder"> | Date | string
    updatedAt?: DateTimeFilter<"WorkOrder"> | Date | string
    request?: XOR<ServiceRequestScalarRelationFilter, ServiceRequestWhereInput>
    quote?: XOR<QuoteScalarRelationFilter, QuoteWhereInput>
    workshop?: XOR<WorkshopScalarRelationFilter, WorkshopWhereInput>
    changeRequests?: ChangeRequestListRelationFilter
    evidences?: EvidenceListRelationFilter
    review?: XOR<ReviewNullableScalarRelationFilter, ReviewWhereInput> | null
    receipt?: XOR<ReceiptNullableScalarRelationFilter, ReceiptWhereInput> | null
  }, "id" | "orderNumber" | "requestId" | "quoteId">

  export type WorkOrderOrderByWithAggregationInput = {
    id?: SortOrder
    orderNumber?: SortOrder
    requestId?: SortOrder
    quoteId?: SortOrder
    workshopId?: SortOrder
    diagnosis?: SortOrder
    totalAgreed?: SortOrder
    totalFinal?: SortOrderInput | SortOrder
    status?: SortOrder
    userAcceptedAt?: SortOrderInput | SortOrder
    workshopAcceptedAt?: SortOrderInput | SortOrder
    startedAt?: SortOrderInput | SortOrder
    startNote?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    closedAt?: SortOrderInput | SortOrder
    closureChecklist?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: WorkOrderCountOrderByAggregateInput
    _avg?: WorkOrderAvgOrderByAggregateInput
    _max?: WorkOrderMaxOrderByAggregateInput
    _min?: WorkOrderMinOrderByAggregateInput
    _sum?: WorkOrderSumOrderByAggregateInput
  }

  export type WorkOrderScalarWhereWithAggregatesInput = {
    AND?: WorkOrderScalarWhereWithAggregatesInput | WorkOrderScalarWhereWithAggregatesInput[]
    OR?: WorkOrderScalarWhereWithAggregatesInput[]
    NOT?: WorkOrderScalarWhereWithAggregatesInput | WorkOrderScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"WorkOrder"> | string
    orderNumber?: StringWithAggregatesFilter<"WorkOrder"> | string
    requestId?: StringWithAggregatesFilter<"WorkOrder"> | string
    quoteId?: StringWithAggregatesFilter<"WorkOrder"> | string
    workshopId?: StringWithAggregatesFilter<"WorkOrder"> | string
    diagnosis?: StringWithAggregatesFilter<"WorkOrder"> | string
    totalAgreed?: FloatWithAggregatesFilter<"WorkOrder"> | number
    totalFinal?: FloatNullableWithAggregatesFilter<"WorkOrder"> | number | null
    status?: EnumWorkOrderStatusWithAggregatesFilter<"WorkOrder"> | $Enums.WorkOrderStatus
    userAcceptedAt?: DateTimeNullableWithAggregatesFilter<"WorkOrder"> | Date | string | null
    workshopAcceptedAt?: DateTimeNullableWithAggregatesFilter<"WorkOrder"> | Date | string | null
    startedAt?: DateTimeNullableWithAggregatesFilter<"WorkOrder"> | Date | string | null
    startNote?: StringNullableWithAggregatesFilter<"WorkOrder"> | string | null
    completedAt?: DateTimeNullableWithAggregatesFilter<"WorkOrder"> | Date | string | null
    closedAt?: DateTimeNullableWithAggregatesFilter<"WorkOrder"> | Date | string | null
    closureChecklist?: StringNullableWithAggregatesFilter<"WorkOrder"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"WorkOrder"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"WorkOrder"> | Date | string
  }

  export type ChangeRequestWhereInput = {
    AND?: ChangeRequestWhereInput | ChangeRequestWhereInput[]
    OR?: ChangeRequestWhereInput[]
    NOT?: ChangeRequestWhereInput | ChangeRequestWhereInput[]
    id?: StringFilter<"ChangeRequest"> | string
    workOrderId?: StringFilter<"ChangeRequest"> | string
    description?: StringFilter<"ChangeRequest"> | string
    justification?: StringFilter<"ChangeRequest"> | string
    additionalCost?: FloatFilter<"ChangeRequest"> | number
    additionalTime?: StringNullableFilter<"ChangeRequest"> | string | null
    status?: EnumChangeRequestStatusFilter<"ChangeRequest"> | $Enums.ChangeRequestStatus
    decidedAt?: DateTimeNullableFilter<"ChangeRequest"> | Date | string | null
    decidedBy?: StringNullableFilter<"ChangeRequest"> | string | null
    createdAt?: DateTimeFilter<"ChangeRequest"> | Date | string
    updatedAt?: DateTimeFilter<"ChangeRequest"> | Date | string
    workOrder?: XOR<WorkOrderScalarRelationFilter, WorkOrderWhereInput>
  }

  export type ChangeRequestOrderByWithRelationInput = {
    id?: SortOrder
    workOrderId?: SortOrder
    description?: SortOrder
    justification?: SortOrder
    additionalCost?: SortOrder
    additionalTime?: SortOrderInput | SortOrder
    status?: SortOrder
    decidedAt?: SortOrderInput | SortOrder
    decidedBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    workOrder?: WorkOrderOrderByWithRelationInput
  }

  export type ChangeRequestWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ChangeRequestWhereInput | ChangeRequestWhereInput[]
    OR?: ChangeRequestWhereInput[]
    NOT?: ChangeRequestWhereInput | ChangeRequestWhereInput[]
    workOrderId?: StringFilter<"ChangeRequest"> | string
    description?: StringFilter<"ChangeRequest"> | string
    justification?: StringFilter<"ChangeRequest"> | string
    additionalCost?: FloatFilter<"ChangeRequest"> | number
    additionalTime?: StringNullableFilter<"ChangeRequest"> | string | null
    status?: EnumChangeRequestStatusFilter<"ChangeRequest"> | $Enums.ChangeRequestStatus
    decidedAt?: DateTimeNullableFilter<"ChangeRequest"> | Date | string | null
    decidedBy?: StringNullableFilter<"ChangeRequest"> | string | null
    createdAt?: DateTimeFilter<"ChangeRequest"> | Date | string
    updatedAt?: DateTimeFilter<"ChangeRequest"> | Date | string
    workOrder?: XOR<WorkOrderScalarRelationFilter, WorkOrderWhereInput>
  }, "id">

  export type ChangeRequestOrderByWithAggregationInput = {
    id?: SortOrder
    workOrderId?: SortOrder
    description?: SortOrder
    justification?: SortOrder
    additionalCost?: SortOrder
    additionalTime?: SortOrderInput | SortOrder
    status?: SortOrder
    decidedAt?: SortOrderInput | SortOrder
    decidedBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ChangeRequestCountOrderByAggregateInput
    _avg?: ChangeRequestAvgOrderByAggregateInput
    _max?: ChangeRequestMaxOrderByAggregateInput
    _min?: ChangeRequestMinOrderByAggregateInput
    _sum?: ChangeRequestSumOrderByAggregateInput
  }

  export type ChangeRequestScalarWhereWithAggregatesInput = {
    AND?: ChangeRequestScalarWhereWithAggregatesInput | ChangeRequestScalarWhereWithAggregatesInput[]
    OR?: ChangeRequestScalarWhereWithAggregatesInput[]
    NOT?: ChangeRequestScalarWhereWithAggregatesInput | ChangeRequestScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ChangeRequest"> | string
    workOrderId?: StringWithAggregatesFilter<"ChangeRequest"> | string
    description?: StringWithAggregatesFilter<"ChangeRequest"> | string
    justification?: StringWithAggregatesFilter<"ChangeRequest"> | string
    additionalCost?: FloatWithAggregatesFilter<"ChangeRequest"> | number
    additionalTime?: StringNullableWithAggregatesFilter<"ChangeRequest"> | string | null
    status?: EnumChangeRequestStatusWithAggregatesFilter<"ChangeRequest"> | $Enums.ChangeRequestStatus
    decidedAt?: DateTimeNullableWithAggregatesFilter<"ChangeRequest"> | Date | string | null
    decidedBy?: StringNullableWithAggregatesFilter<"ChangeRequest"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ChangeRequest"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ChangeRequest"> | Date | string
  }

  export type EvidenceWhereInput = {
    AND?: EvidenceWhereInput | EvidenceWhereInput[]
    OR?: EvidenceWhereInput[]
    NOT?: EvidenceWhereInput | EvidenceWhereInput[]
    id?: StringFilter<"Evidence"> | string
    workOrderId?: StringFilter<"Evidence"> | string
    stage?: EnumEvidenceStageFilter<"Evidence"> | $Enums.EvidenceStage
    url?: StringFilter<"Evidence"> | string
    mediaType?: EnumMediaTypeFilter<"Evidence"> | $Enums.MediaType
    fileName?: StringNullableFilter<"Evidence"> | string | null
    description?: StringNullableFilter<"Evidence"> | string | null
    flagged?: BoolFilter<"Evidence"> | boolean
    createdAt?: DateTimeFilter<"Evidence"> | Date | string
    workOrder?: XOR<WorkOrderScalarRelationFilter, WorkOrderWhereInput>
  }

  export type EvidenceOrderByWithRelationInput = {
    id?: SortOrder
    workOrderId?: SortOrder
    stage?: SortOrder
    url?: SortOrder
    mediaType?: SortOrder
    fileName?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    flagged?: SortOrder
    createdAt?: SortOrder
    workOrder?: WorkOrderOrderByWithRelationInput
  }

  export type EvidenceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: EvidenceWhereInput | EvidenceWhereInput[]
    OR?: EvidenceWhereInput[]
    NOT?: EvidenceWhereInput | EvidenceWhereInput[]
    workOrderId?: StringFilter<"Evidence"> | string
    stage?: EnumEvidenceStageFilter<"Evidence"> | $Enums.EvidenceStage
    url?: StringFilter<"Evidence"> | string
    mediaType?: EnumMediaTypeFilter<"Evidence"> | $Enums.MediaType
    fileName?: StringNullableFilter<"Evidence"> | string | null
    description?: StringNullableFilter<"Evidence"> | string | null
    flagged?: BoolFilter<"Evidence"> | boolean
    createdAt?: DateTimeFilter<"Evidence"> | Date | string
    workOrder?: XOR<WorkOrderScalarRelationFilter, WorkOrderWhereInput>
  }, "id">

  export type EvidenceOrderByWithAggregationInput = {
    id?: SortOrder
    workOrderId?: SortOrder
    stage?: SortOrder
    url?: SortOrder
    mediaType?: SortOrder
    fileName?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    flagged?: SortOrder
    createdAt?: SortOrder
    _count?: EvidenceCountOrderByAggregateInput
    _max?: EvidenceMaxOrderByAggregateInput
    _min?: EvidenceMinOrderByAggregateInput
  }

  export type EvidenceScalarWhereWithAggregatesInput = {
    AND?: EvidenceScalarWhereWithAggregatesInput | EvidenceScalarWhereWithAggregatesInput[]
    OR?: EvidenceScalarWhereWithAggregatesInput[]
    NOT?: EvidenceScalarWhereWithAggregatesInput | EvidenceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Evidence"> | string
    workOrderId?: StringWithAggregatesFilter<"Evidence"> | string
    stage?: EnumEvidenceStageWithAggregatesFilter<"Evidence"> | $Enums.EvidenceStage
    url?: StringWithAggregatesFilter<"Evidence"> | string
    mediaType?: EnumMediaTypeWithAggregatesFilter<"Evidence"> | $Enums.MediaType
    fileName?: StringNullableWithAggregatesFilter<"Evidence"> | string | null
    description?: StringNullableWithAggregatesFilter<"Evidence"> | string | null
    flagged?: BoolWithAggregatesFilter<"Evidence"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Evidence"> | Date | string
  }

  export type ReviewWhereInput = {
    AND?: ReviewWhereInput | ReviewWhereInput[]
    OR?: ReviewWhereInput[]
    NOT?: ReviewWhereInput | ReviewWhereInput[]
    id?: StringFilter<"Review"> | string
    workOrderId?: StringFilter<"Review"> | string
    workshopId?: StringFilter<"Review"> | string
    userId?: StringFilter<"Review"> | string
    rating?: IntFilter<"Review"> | number
    comment?: StringNullableFilter<"Review"> | string | null
    editableUntil?: DateTimeFilter<"Review"> | Date | string
    createdAt?: DateTimeFilter<"Review"> | Date | string
    updatedAt?: DateTimeFilter<"Review"> | Date | string
    workOrder?: XOR<WorkOrderScalarRelationFilter, WorkOrderWhereInput>
    workshop?: XOR<WorkshopScalarRelationFilter, WorkshopWhereInput>
    user?: XOR<UserProfileScalarRelationFilter, UserProfileWhereInput>
  }

  export type ReviewOrderByWithRelationInput = {
    id?: SortOrder
    workOrderId?: SortOrder
    workshopId?: SortOrder
    userId?: SortOrder
    rating?: SortOrder
    comment?: SortOrderInput | SortOrder
    editableUntil?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    workOrder?: WorkOrderOrderByWithRelationInput
    workshop?: WorkshopOrderByWithRelationInput
    user?: UserProfileOrderByWithRelationInput
  }

  export type ReviewWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    workOrderId?: string
    AND?: ReviewWhereInput | ReviewWhereInput[]
    OR?: ReviewWhereInput[]
    NOT?: ReviewWhereInput | ReviewWhereInput[]
    workshopId?: StringFilter<"Review"> | string
    userId?: StringFilter<"Review"> | string
    rating?: IntFilter<"Review"> | number
    comment?: StringNullableFilter<"Review"> | string | null
    editableUntil?: DateTimeFilter<"Review"> | Date | string
    createdAt?: DateTimeFilter<"Review"> | Date | string
    updatedAt?: DateTimeFilter<"Review"> | Date | string
    workOrder?: XOR<WorkOrderScalarRelationFilter, WorkOrderWhereInput>
    workshop?: XOR<WorkshopScalarRelationFilter, WorkshopWhereInput>
    user?: XOR<UserProfileScalarRelationFilter, UserProfileWhereInput>
  }, "id" | "workOrderId">

  export type ReviewOrderByWithAggregationInput = {
    id?: SortOrder
    workOrderId?: SortOrder
    workshopId?: SortOrder
    userId?: SortOrder
    rating?: SortOrder
    comment?: SortOrderInput | SortOrder
    editableUntil?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ReviewCountOrderByAggregateInput
    _avg?: ReviewAvgOrderByAggregateInput
    _max?: ReviewMaxOrderByAggregateInput
    _min?: ReviewMinOrderByAggregateInput
    _sum?: ReviewSumOrderByAggregateInput
  }

  export type ReviewScalarWhereWithAggregatesInput = {
    AND?: ReviewScalarWhereWithAggregatesInput | ReviewScalarWhereWithAggregatesInput[]
    OR?: ReviewScalarWhereWithAggregatesInput[]
    NOT?: ReviewScalarWhereWithAggregatesInput | ReviewScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Review"> | string
    workOrderId?: StringWithAggregatesFilter<"Review"> | string
    workshopId?: StringWithAggregatesFilter<"Review"> | string
    userId?: StringWithAggregatesFilter<"Review"> | string
    rating?: IntWithAggregatesFilter<"Review"> | number
    comment?: StringNullableWithAggregatesFilter<"Review"> | string | null
    editableUntil?: DateTimeWithAggregatesFilter<"Review"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"Review"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Review"> | Date | string
  }

  export type ReceiptWhereInput = {
    AND?: ReceiptWhereInput | ReceiptWhereInput[]
    OR?: ReceiptWhereInput[]
    NOT?: ReceiptWhereInput | ReceiptWhereInput[]
    id?: StringFilter<"Receipt"> | string
    workOrderId?: StringFilter<"Receipt"> | string
    totalOriginal?: FloatFilter<"Receipt"> | number
    totalChanges?: FloatFilter<"Receipt"> | number
    totalFinal?: FloatFilter<"Receipt"> | number
    pdfUrl?: StringNullableFilter<"Receipt"> | string | null
    createdAt?: DateTimeFilter<"Receipt"> | Date | string
    workOrder?: XOR<WorkOrderScalarRelationFilter, WorkOrderWhereInput>
  }

  export type ReceiptOrderByWithRelationInput = {
    id?: SortOrder
    workOrderId?: SortOrder
    totalOriginal?: SortOrder
    totalChanges?: SortOrder
    totalFinal?: SortOrder
    pdfUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    workOrder?: WorkOrderOrderByWithRelationInput
  }

  export type ReceiptWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    workOrderId?: string
    AND?: ReceiptWhereInput | ReceiptWhereInput[]
    OR?: ReceiptWhereInput[]
    NOT?: ReceiptWhereInput | ReceiptWhereInput[]
    totalOriginal?: FloatFilter<"Receipt"> | number
    totalChanges?: FloatFilter<"Receipt"> | number
    totalFinal?: FloatFilter<"Receipt"> | number
    pdfUrl?: StringNullableFilter<"Receipt"> | string | null
    createdAt?: DateTimeFilter<"Receipt"> | Date | string
    workOrder?: XOR<WorkOrderScalarRelationFilter, WorkOrderWhereInput>
  }, "id" | "workOrderId">

  export type ReceiptOrderByWithAggregationInput = {
    id?: SortOrder
    workOrderId?: SortOrder
    totalOriginal?: SortOrder
    totalChanges?: SortOrder
    totalFinal?: SortOrder
    pdfUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: ReceiptCountOrderByAggregateInput
    _avg?: ReceiptAvgOrderByAggregateInput
    _max?: ReceiptMaxOrderByAggregateInput
    _min?: ReceiptMinOrderByAggregateInput
    _sum?: ReceiptSumOrderByAggregateInput
  }

  export type ReceiptScalarWhereWithAggregatesInput = {
    AND?: ReceiptScalarWhereWithAggregatesInput | ReceiptScalarWhereWithAggregatesInput[]
    OR?: ReceiptScalarWhereWithAggregatesInput[]
    NOT?: ReceiptScalarWhereWithAggregatesInput | ReceiptScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Receipt"> | string
    workOrderId?: StringWithAggregatesFilter<"Receipt"> | string
    totalOriginal?: FloatWithAggregatesFilter<"Receipt"> | number
    totalChanges?: FloatWithAggregatesFilter<"Receipt"> | number
    totalFinal?: FloatWithAggregatesFilter<"Receipt"> | number
    pdfUrl?: StringNullableWithAggregatesFilter<"Receipt"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Receipt"> | Date | string
  }

  export type IncidentReportWhereInput = {
    AND?: IncidentReportWhereInput | IncidentReportWhereInput[]
    OR?: IncidentReportWhereInput[]
    NOT?: IncidentReportWhereInput | IncidentReportWhereInput[]
    id?: StringFilter<"IncidentReport"> | string
    reporterId?: StringFilter<"IncidentReport"> | string
    workshopId?: StringFilter<"IncidentReport"> | string
    type?: EnumIncidentTypeFilter<"IncidentReport"> | $Enums.IncidentType
    description?: StringFilter<"IncidentReport"> | string
    evidenceUrl?: StringNullableFilter<"IncidentReport"> | string | null
    status?: EnumIncidentStatusFilter<"IncidentReport"> | $Enums.IncidentStatus
    resolution?: StringNullableFilter<"IncidentReport"> | string | null
    resolvedAt?: DateTimeNullableFilter<"IncidentReport"> | Date | string | null
    resolvedBy?: StringNullableFilter<"IncidentReport"> | string | null
    createdAt?: DateTimeFilter<"IncidentReport"> | Date | string
    updatedAt?: DateTimeFilter<"IncidentReport"> | Date | string
    reporter?: XOR<UserProfileScalarRelationFilter, UserProfileWhereInput>
    workshop?: XOR<WorkshopScalarRelationFilter, WorkshopWhereInput>
  }

  export type IncidentReportOrderByWithRelationInput = {
    id?: SortOrder
    reporterId?: SortOrder
    workshopId?: SortOrder
    type?: SortOrder
    description?: SortOrder
    evidenceUrl?: SortOrderInput | SortOrder
    status?: SortOrder
    resolution?: SortOrderInput | SortOrder
    resolvedAt?: SortOrderInput | SortOrder
    resolvedBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    reporter?: UserProfileOrderByWithRelationInput
    workshop?: WorkshopOrderByWithRelationInput
  }

  export type IncidentReportWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: IncidentReportWhereInput | IncidentReportWhereInput[]
    OR?: IncidentReportWhereInput[]
    NOT?: IncidentReportWhereInput | IncidentReportWhereInput[]
    reporterId?: StringFilter<"IncidentReport"> | string
    workshopId?: StringFilter<"IncidentReport"> | string
    type?: EnumIncidentTypeFilter<"IncidentReport"> | $Enums.IncidentType
    description?: StringFilter<"IncidentReport"> | string
    evidenceUrl?: StringNullableFilter<"IncidentReport"> | string | null
    status?: EnumIncidentStatusFilter<"IncidentReport"> | $Enums.IncidentStatus
    resolution?: StringNullableFilter<"IncidentReport"> | string | null
    resolvedAt?: DateTimeNullableFilter<"IncidentReport"> | Date | string | null
    resolvedBy?: StringNullableFilter<"IncidentReport"> | string | null
    createdAt?: DateTimeFilter<"IncidentReport"> | Date | string
    updatedAt?: DateTimeFilter<"IncidentReport"> | Date | string
    reporter?: XOR<UserProfileScalarRelationFilter, UserProfileWhereInput>
    workshop?: XOR<WorkshopScalarRelationFilter, WorkshopWhereInput>
  }, "id">

  export type IncidentReportOrderByWithAggregationInput = {
    id?: SortOrder
    reporterId?: SortOrder
    workshopId?: SortOrder
    type?: SortOrder
    description?: SortOrder
    evidenceUrl?: SortOrderInput | SortOrder
    status?: SortOrder
    resolution?: SortOrderInput | SortOrder
    resolvedAt?: SortOrderInput | SortOrder
    resolvedBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: IncidentReportCountOrderByAggregateInput
    _max?: IncidentReportMaxOrderByAggregateInput
    _min?: IncidentReportMinOrderByAggregateInput
  }

  export type IncidentReportScalarWhereWithAggregatesInput = {
    AND?: IncidentReportScalarWhereWithAggregatesInput | IncidentReportScalarWhereWithAggregatesInput[]
    OR?: IncidentReportScalarWhereWithAggregatesInput[]
    NOT?: IncidentReportScalarWhereWithAggregatesInput | IncidentReportScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"IncidentReport"> | string
    reporterId?: StringWithAggregatesFilter<"IncidentReport"> | string
    workshopId?: StringWithAggregatesFilter<"IncidentReport"> | string
    type?: EnumIncidentTypeWithAggregatesFilter<"IncidentReport"> | $Enums.IncidentType
    description?: StringWithAggregatesFilter<"IncidentReport"> | string
    evidenceUrl?: StringNullableWithAggregatesFilter<"IncidentReport"> | string | null
    status?: EnumIncidentStatusWithAggregatesFilter<"IncidentReport"> | $Enums.IncidentStatus
    resolution?: StringNullableWithAggregatesFilter<"IncidentReport"> | string | null
    resolvedAt?: DateTimeNullableWithAggregatesFilter<"IncidentReport"> | Date | string | null
    resolvedBy?: StringNullableWithAggregatesFilter<"IncidentReport"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"IncidentReport"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"IncidentReport"> | Date | string
  }

  export type ChatMessageWhereInput = {
    AND?: ChatMessageWhereInput | ChatMessageWhereInput[]
    OR?: ChatMessageWhereInput[]
    NOT?: ChatMessageWhereInput | ChatMessageWhereInput[]
    id?: StringFilter<"ChatMessage"> | string
    requestId?: StringFilter<"ChatMessage"> | string
    senderId?: StringFilter<"ChatMessage"> | string
    content?: StringFilter<"ChatMessage"> | string
    imageUrl?: StringNullableFilter<"ChatMessage"> | string | null
    isRead?: BoolFilter<"ChatMessage"> | boolean
    createdAt?: DateTimeFilter<"ChatMessage"> | Date | string
    request?: XOR<ServiceRequestScalarRelationFilter, ServiceRequestWhereInput>
    sender?: XOR<UserProfileScalarRelationFilter, UserProfileWhereInput>
  }

  export type ChatMessageOrderByWithRelationInput = {
    id?: SortOrder
    requestId?: SortOrder
    senderId?: SortOrder
    content?: SortOrder
    imageUrl?: SortOrderInput | SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    request?: ServiceRequestOrderByWithRelationInput
    sender?: UserProfileOrderByWithRelationInput
  }

  export type ChatMessageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ChatMessageWhereInput | ChatMessageWhereInput[]
    OR?: ChatMessageWhereInput[]
    NOT?: ChatMessageWhereInput | ChatMessageWhereInput[]
    requestId?: StringFilter<"ChatMessage"> | string
    senderId?: StringFilter<"ChatMessage"> | string
    content?: StringFilter<"ChatMessage"> | string
    imageUrl?: StringNullableFilter<"ChatMessage"> | string | null
    isRead?: BoolFilter<"ChatMessage"> | boolean
    createdAt?: DateTimeFilter<"ChatMessage"> | Date | string
    request?: XOR<ServiceRequestScalarRelationFilter, ServiceRequestWhereInput>
    sender?: XOR<UserProfileScalarRelationFilter, UserProfileWhereInput>
  }, "id">

  export type ChatMessageOrderByWithAggregationInput = {
    id?: SortOrder
    requestId?: SortOrder
    senderId?: SortOrder
    content?: SortOrder
    imageUrl?: SortOrderInput | SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    _count?: ChatMessageCountOrderByAggregateInput
    _max?: ChatMessageMaxOrderByAggregateInput
    _min?: ChatMessageMinOrderByAggregateInput
  }

  export type ChatMessageScalarWhereWithAggregatesInput = {
    AND?: ChatMessageScalarWhereWithAggregatesInput | ChatMessageScalarWhereWithAggregatesInput[]
    OR?: ChatMessageScalarWhereWithAggregatesInput[]
    NOT?: ChatMessageScalarWhereWithAggregatesInput | ChatMessageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ChatMessage"> | string
    requestId?: StringWithAggregatesFilter<"ChatMessage"> | string
    senderId?: StringWithAggregatesFilter<"ChatMessage"> | string
    content?: StringWithAggregatesFilter<"ChatMessage"> | string
    imageUrl?: StringNullableWithAggregatesFilter<"ChatMessage"> | string | null
    isRead?: BoolWithAggregatesFilter<"ChatMessage"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"ChatMessage"> | Date | string
  }

  export type NotificationWhereInput = {
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    id?: StringFilter<"Notification"> | string
    userId?: StringFilter<"Notification"> | string
    requestId?: StringNullableFilter<"Notification"> | string | null
    title?: StringFilter<"Notification"> | string
    body?: StringFilter<"Notification"> | string
    channel?: EnumNotificationChannelFilter<"Notification"> | $Enums.NotificationChannel
    isRead?: BoolFilter<"Notification"> | boolean
    link?: StringNullableFilter<"Notification"> | string | null
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    user?: XOR<UserProfileScalarRelationFilter, UserProfileWhereInput>
    request?: XOR<ServiceRequestNullableScalarRelationFilter, ServiceRequestWhereInput> | null
  }

  export type NotificationOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    requestId?: SortOrderInput | SortOrder
    title?: SortOrder
    body?: SortOrder
    channel?: SortOrder
    isRead?: SortOrder
    link?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    user?: UserProfileOrderByWithRelationInput
    request?: ServiceRequestOrderByWithRelationInput
  }

  export type NotificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    userId?: StringFilter<"Notification"> | string
    requestId?: StringNullableFilter<"Notification"> | string | null
    title?: StringFilter<"Notification"> | string
    body?: StringFilter<"Notification"> | string
    channel?: EnumNotificationChannelFilter<"Notification"> | $Enums.NotificationChannel
    isRead?: BoolFilter<"Notification"> | boolean
    link?: StringNullableFilter<"Notification"> | string | null
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    user?: XOR<UserProfileScalarRelationFilter, UserProfileWhereInput>
    request?: XOR<ServiceRequestNullableScalarRelationFilter, ServiceRequestWhereInput> | null
  }, "id">

  export type NotificationOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    requestId?: SortOrderInput | SortOrder
    title?: SortOrder
    body?: SortOrder
    channel?: SortOrder
    isRead?: SortOrder
    link?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: NotificationCountOrderByAggregateInput
    _max?: NotificationMaxOrderByAggregateInput
    _min?: NotificationMinOrderByAggregateInput
  }

  export type NotificationScalarWhereWithAggregatesInput = {
    AND?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    OR?: NotificationScalarWhereWithAggregatesInput[]
    NOT?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Notification"> | string
    userId?: StringWithAggregatesFilter<"Notification"> | string
    requestId?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    title?: StringWithAggregatesFilter<"Notification"> | string
    body?: StringWithAggregatesFilter<"Notification"> | string
    channel?: EnumNotificationChannelWithAggregatesFilter<"Notification"> | $Enums.NotificationChannel
    isRead?: BoolWithAggregatesFilter<"Notification"> | boolean
    link?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
  }

  export type AuditLogWhereInput = {
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    id?: StringFilter<"AuditLog"> | string
    actorId?: StringFilter<"AuditLog"> | string
    action?: EnumAdminActionTypeFilter<"AuditLog"> | $Enums.AdminActionType
    targetType?: StringFilter<"AuditLog"> | string
    targetId?: StringFilter<"AuditLog"> | string
    reason?: StringNullableFilter<"AuditLog"> | string | null
    metadata?: StringNullableFilter<"AuditLog"> | string | null
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
  }

  export type AuditLogOrderByWithRelationInput = {
    id?: SortOrder
    actorId?: SortOrder
    action?: SortOrder
    targetType?: SortOrder
    targetId?: SortOrder
    reason?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
  }

  export type AuditLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    actorId?: StringFilter<"AuditLog"> | string
    action?: EnumAdminActionTypeFilter<"AuditLog"> | $Enums.AdminActionType
    targetType?: StringFilter<"AuditLog"> | string
    targetId?: StringFilter<"AuditLog"> | string
    reason?: StringNullableFilter<"AuditLog"> | string | null
    metadata?: StringNullableFilter<"AuditLog"> | string | null
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
  }, "id">

  export type AuditLogOrderByWithAggregationInput = {
    id?: SortOrder
    actorId?: SortOrder
    action?: SortOrder
    targetType?: SortOrder
    targetId?: SortOrder
    reason?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: AuditLogCountOrderByAggregateInput
    _max?: AuditLogMaxOrderByAggregateInput
    _min?: AuditLogMinOrderByAggregateInput
  }

  export type AuditLogScalarWhereWithAggregatesInput = {
    AND?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    OR?: AuditLogScalarWhereWithAggregatesInput[]
    NOT?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AuditLog"> | string
    actorId?: StringWithAggregatesFilter<"AuditLog"> | string
    action?: EnumAdminActionTypeWithAggregatesFilter<"AuditLog"> | $Enums.AdminActionType
    targetType?: StringWithAggregatesFilter<"AuditLog"> | string
    targetId?: StringWithAggregatesFilter<"AuditLog"> | string
    reason?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    metadata?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"AuditLog"> | Date | string
  }

  export type FeatureFlagWhereInput = {
    AND?: FeatureFlagWhereInput | FeatureFlagWhereInput[]
    OR?: FeatureFlagWhereInput[]
    NOT?: FeatureFlagWhereInput | FeatureFlagWhereInput[]
    id?: StringFilter<"FeatureFlag"> | string
    key?: StringFilter<"FeatureFlag"> | string
    name?: StringFilter<"FeatureFlag"> | string
    description?: StringNullableFilter<"FeatureFlag"> | string | null
    enabled?: BoolFilter<"FeatureFlag"> | boolean
    isMvp?: BoolFilter<"FeatureFlag"> | boolean
    createdAt?: DateTimeFilter<"FeatureFlag"> | Date | string
    updatedAt?: DateTimeFilter<"FeatureFlag"> | Date | string
  }

  export type FeatureFlagOrderByWithRelationInput = {
    id?: SortOrder
    key?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    enabled?: SortOrder
    isMvp?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FeatureFlagWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    key?: string
    AND?: FeatureFlagWhereInput | FeatureFlagWhereInput[]
    OR?: FeatureFlagWhereInput[]
    NOT?: FeatureFlagWhereInput | FeatureFlagWhereInput[]
    name?: StringFilter<"FeatureFlag"> | string
    description?: StringNullableFilter<"FeatureFlag"> | string | null
    enabled?: BoolFilter<"FeatureFlag"> | boolean
    isMvp?: BoolFilter<"FeatureFlag"> | boolean
    createdAt?: DateTimeFilter<"FeatureFlag"> | Date | string
    updatedAt?: DateTimeFilter<"FeatureFlag"> | Date | string
  }, "id" | "key">

  export type FeatureFlagOrderByWithAggregationInput = {
    id?: SortOrder
    key?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    enabled?: SortOrder
    isMvp?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: FeatureFlagCountOrderByAggregateInput
    _max?: FeatureFlagMaxOrderByAggregateInput
    _min?: FeatureFlagMinOrderByAggregateInput
  }

  export type FeatureFlagScalarWhereWithAggregatesInput = {
    AND?: FeatureFlagScalarWhereWithAggregatesInput | FeatureFlagScalarWhereWithAggregatesInput[]
    OR?: FeatureFlagScalarWhereWithAggregatesInput[]
    NOT?: FeatureFlagScalarWhereWithAggregatesInput | FeatureFlagScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"FeatureFlag"> | string
    key?: StringWithAggregatesFilter<"FeatureFlag"> | string
    name?: StringWithAggregatesFilter<"FeatureFlag"> | string
    description?: StringNullableWithAggregatesFilter<"FeatureFlag"> | string | null
    enabled?: BoolWithAggregatesFilter<"FeatureFlag"> | boolean
    isMvp?: BoolWithAggregatesFilter<"FeatureFlag"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"FeatureFlag"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"FeatureFlag"> | Date | string
  }

  export type AiSuggestionWhereInput = {
    AND?: AiSuggestionWhereInput | AiSuggestionWhereInput[]
    OR?: AiSuggestionWhereInput[]
    NOT?: AiSuggestionWhereInput | AiSuggestionWhereInput[]
    id?: StringFilter<"AiSuggestion"> | string
    requestId?: StringFilter<"AiSuggestion"> | string
    type?: StringFilter<"AiSuggestion"> | string
    input?: StringNullableFilter<"AiSuggestion"> | string | null
    output?: StringNullableFilter<"AiSuggestion"> | string | null
    confidence?: FloatNullableFilter<"AiSuggestion"> | number | null
    modelVersion?: StringNullableFilter<"AiSuggestion"> | string | null
    isConclusive?: BoolFilter<"AiSuggestion"> | boolean
    disclaimer?: StringNullableFilter<"AiSuggestion"> | string | null
    createdAt?: DateTimeFilter<"AiSuggestion"> | Date | string
    request?: XOR<ServiceRequestScalarRelationFilter, ServiceRequestWhereInput>
  }

  export type AiSuggestionOrderByWithRelationInput = {
    id?: SortOrder
    requestId?: SortOrder
    type?: SortOrder
    input?: SortOrderInput | SortOrder
    output?: SortOrderInput | SortOrder
    confidence?: SortOrderInput | SortOrder
    modelVersion?: SortOrderInput | SortOrder
    isConclusive?: SortOrder
    disclaimer?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    request?: ServiceRequestOrderByWithRelationInput
  }

  export type AiSuggestionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AiSuggestionWhereInput | AiSuggestionWhereInput[]
    OR?: AiSuggestionWhereInput[]
    NOT?: AiSuggestionWhereInput | AiSuggestionWhereInput[]
    requestId?: StringFilter<"AiSuggestion"> | string
    type?: StringFilter<"AiSuggestion"> | string
    input?: StringNullableFilter<"AiSuggestion"> | string | null
    output?: StringNullableFilter<"AiSuggestion"> | string | null
    confidence?: FloatNullableFilter<"AiSuggestion"> | number | null
    modelVersion?: StringNullableFilter<"AiSuggestion"> | string | null
    isConclusive?: BoolFilter<"AiSuggestion"> | boolean
    disclaimer?: StringNullableFilter<"AiSuggestion"> | string | null
    createdAt?: DateTimeFilter<"AiSuggestion"> | Date | string
    request?: XOR<ServiceRequestScalarRelationFilter, ServiceRequestWhereInput>
  }, "id">

  export type AiSuggestionOrderByWithAggregationInput = {
    id?: SortOrder
    requestId?: SortOrder
    type?: SortOrder
    input?: SortOrderInput | SortOrder
    output?: SortOrderInput | SortOrder
    confidence?: SortOrderInput | SortOrder
    modelVersion?: SortOrderInput | SortOrder
    isConclusive?: SortOrder
    disclaimer?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: AiSuggestionCountOrderByAggregateInput
    _avg?: AiSuggestionAvgOrderByAggregateInput
    _max?: AiSuggestionMaxOrderByAggregateInput
    _min?: AiSuggestionMinOrderByAggregateInput
    _sum?: AiSuggestionSumOrderByAggregateInput
  }

  export type AiSuggestionScalarWhereWithAggregatesInput = {
    AND?: AiSuggestionScalarWhereWithAggregatesInput | AiSuggestionScalarWhereWithAggregatesInput[]
    OR?: AiSuggestionScalarWhereWithAggregatesInput[]
    NOT?: AiSuggestionScalarWhereWithAggregatesInput | AiSuggestionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AiSuggestion"> | string
    requestId?: StringWithAggregatesFilter<"AiSuggestion"> | string
    type?: StringWithAggregatesFilter<"AiSuggestion"> | string
    input?: StringNullableWithAggregatesFilter<"AiSuggestion"> | string | null
    output?: StringNullableWithAggregatesFilter<"AiSuggestion"> | string | null
    confidence?: FloatNullableWithAggregatesFilter<"AiSuggestion"> | number | null
    modelVersion?: StringNullableWithAggregatesFilter<"AiSuggestion"> | string | null
    isConclusive?: BoolWithAggregatesFilter<"AiSuggestion"> | boolean
    disclaimer?: StringNullableWithAggregatesFilter<"AiSuggestion"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"AiSuggestion"> | Date | string
  }

  export type AiQuoteAnalysisWhereInput = {
    AND?: AiQuoteAnalysisWhereInput | AiQuoteAnalysisWhereInput[]
    OR?: AiQuoteAnalysisWhereInput[]
    NOT?: AiQuoteAnalysisWhereInput | AiQuoteAnalysisWhereInput[]
    id?: StringFilter<"AiQuoteAnalysis"> | string
    quoteId?: StringFilter<"AiQuoteAnalysis"> | string
    type?: StringFilter<"AiQuoteAnalysis"> | string
    input?: StringNullableFilter<"AiQuoteAnalysis"> | string | null
    output?: StringNullableFilter<"AiQuoteAnalysis"> | string | null
    traceability?: StringNullableFilter<"AiQuoteAnalysis"> | string | null
    modelVersion?: StringNullableFilter<"AiQuoteAnalysis"> | string | null
    createdAt?: DateTimeFilter<"AiQuoteAnalysis"> | Date | string
    quote?: XOR<QuoteScalarRelationFilter, QuoteWhereInput>
  }

  export type AiQuoteAnalysisOrderByWithRelationInput = {
    id?: SortOrder
    quoteId?: SortOrder
    type?: SortOrder
    input?: SortOrderInput | SortOrder
    output?: SortOrderInput | SortOrder
    traceability?: SortOrderInput | SortOrder
    modelVersion?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    quote?: QuoteOrderByWithRelationInput
  }

  export type AiQuoteAnalysisWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AiQuoteAnalysisWhereInput | AiQuoteAnalysisWhereInput[]
    OR?: AiQuoteAnalysisWhereInput[]
    NOT?: AiQuoteAnalysisWhereInput | AiQuoteAnalysisWhereInput[]
    quoteId?: StringFilter<"AiQuoteAnalysis"> | string
    type?: StringFilter<"AiQuoteAnalysis"> | string
    input?: StringNullableFilter<"AiQuoteAnalysis"> | string | null
    output?: StringNullableFilter<"AiQuoteAnalysis"> | string | null
    traceability?: StringNullableFilter<"AiQuoteAnalysis"> | string | null
    modelVersion?: StringNullableFilter<"AiQuoteAnalysis"> | string | null
    createdAt?: DateTimeFilter<"AiQuoteAnalysis"> | Date | string
    quote?: XOR<QuoteScalarRelationFilter, QuoteWhereInput>
  }, "id">

  export type AiQuoteAnalysisOrderByWithAggregationInput = {
    id?: SortOrder
    quoteId?: SortOrder
    type?: SortOrder
    input?: SortOrderInput | SortOrder
    output?: SortOrderInput | SortOrder
    traceability?: SortOrderInput | SortOrder
    modelVersion?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: AiQuoteAnalysisCountOrderByAggregateInput
    _max?: AiQuoteAnalysisMaxOrderByAggregateInput
    _min?: AiQuoteAnalysisMinOrderByAggregateInput
  }

  export type AiQuoteAnalysisScalarWhereWithAggregatesInput = {
    AND?: AiQuoteAnalysisScalarWhereWithAggregatesInput | AiQuoteAnalysisScalarWhereWithAggregatesInput[]
    OR?: AiQuoteAnalysisScalarWhereWithAggregatesInput[]
    NOT?: AiQuoteAnalysisScalarWhereWithAggregatesInput | AiQuoteAnalysisScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AiQuoteAnalysis"> | string
    quoteId?: StringWithAggregatesFilter<"AiQuoteAnalysis"> | string
    type?: StringWithAggregatesFilter<"AiQuoteAnalysis"> | string
    input?: StringNullableWithAggregatesFilter<"AiQuoteAnalysis"> | string | null
    output?: StringNullableWithAggregatesFilter<"AiQuoteAnalysis"> | string | null
    traceability?: StringNullableWithAggregatesFilter<"AiQuoteAnalysis"> | string | null
    modelVersion?: StringNullableWithAggregatesFilter<"AiQuoteAnalysis"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"AiQuoteAnalysis"> | Date | string
  }

  export type AppConfigWhereInput = {
    AND?: AppConfigWhereInput | AppConfigWhereInput[]
    OR?: AppConfigWhereInput[]
    NOT?: AppConfigWhereInput | AppConfigWhereInput[]
    id?: StringFilter<"AppConfig"> | string
    key?: StringFilter<"AppConfig"> | string
    value?: StringFilter<"AppConfig"> | string
    description?: StringNullableFilter<"AppConfig"> | string | null
    updatedAt?: DateTimeFilter<"AppConfig"> | Date | string
  }

  export type AppConfigOrderByWithRelationInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    description?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
  }

  export type AppConfigWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    key?: string
    AND?: AppConfigWhereInput | AppConfigWhereInput[]
    OR?: AppConfigWhereInput[]
    NOT?: AppConfigWhereInput | AppConfigWhereInput[]
    value?: StringFilter<"AppConfig"> | string
    description?: StringNullableFilter<"AppConfig"> | string | null
    updatedAt?: DateTimeFilter<"AppConfig"> | Date | string
  }, "id" | "key">

  export type AppConfigOrderByWithAggregationInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    description?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    _count?: AppConfigCountOrderByAggregateInput
    _max?: AppConfigMaxOrderByAggregateInput
    _min?: AppConfigMinOrderByAggregateInput
  }

  export type AppConfigScalarWhereWithAggregatesInput = {
    AND?: AppConfigScalarWhereWithAggregatesInput | AppConfigScalarWhereWithAggregatesInput[]
    OR?: AppConfigScalarWhereWithAggregatesInput[]
    NOT?: AppConfigScalarWhereWithAggregatesInput | AppConfigScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AppConfig"> | string
    key?: StringWithAggregatesFilter<"AppConfig"> | string
    value?: StringWithAggregatesFilter<"AppConfig"> | string
    description?: StringNullableWithAggregatesFilter<"AppConfig"> | string | null
    updatedAt?: DateTimeWithAggregatesFilter<"AppConfig"> | Date | string
  }

  export type UserProfileCreateInput = {
    id?: string
    clerkUserId: string
    role?: $Enums.UserRole
    email?: string | null
    phone?: string | null
    name?: string | null
    district?: string | null
    avatarUrl?: string | null
    notifChannel?: $Enums.NotificationChannel
    phoneVisible?: boolean
    termsAccepted?: boolean
    termsVersion?: string | null
    termsAcceptedAt?: Date | string | null
    privacyAccepted?: boolean
    privacyVersion?: string | null
    privacyAcceptedAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    motorcycles?: MotorcycleCreateNestedManyWithoutUserInput
    serviceRequests?: ServiceRequestCreateNestedManyWithoutUserInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
    incidentReports?: IncidentReportCreateNestedManyWithoutReporterInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    chatMessages?: ChatMessageCreateNestedManyWithoutSenderInput
    workshop?: WorkshopCreateNestedOneWithoutUserInput
  }

  export type UserProfileUncheckedCreateInput = {
    id?: string
    clerkUserId: string
    role?: $Enums.UserRole
    email?: string | null
    phone?: string | null
    name?: string | null
    district?: string | null
    avatarUrl?: string | null
    notifChannel?: $Enums.NotificationChannel
    phoneVisible?: boolean
    termsAccepted?: boolean
    termsVersion?: string | null
    termsAcceptedAt?: Date | string | null
    privacyAccepted?: boolean
    privacyVersion?: string | null
    privacyAcceptedAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    motorcycles?: MotorcycleUncheckedCreateNestedManyWithoutUserInput
    serviceRequests?: ServiceRequestUncheckedCreateNestedManyWithoutUserInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
    incidentReports?: IncidentReportUncheckedCreateNestedManyWithoutReporterInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    chatMessages?: ChatMessageUncheckedCreateNestedManyWithoutSenderInput
    workshop?: WorkshopUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserProfileUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    clerkUserId?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    notifChannel?: EnumNotificationChannelFieldUpdateOperationsInput | $Enums.NotificationChannel
    phoneVisible?: BoolFieldUpdateOperationsInput | boolean
    termsAccepted?: BoolFieldUpdateOperationsInput | boolean
    termsVersion?: NullableStringFieldUpdateOperationsInput | string | null
    termsAcceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    privacyAccepted?: BoolFieldUpdateOperationsInput | boolean
    privacyVersion?: NullableStringFieldUpdateOperationsInput | string | null
    privacyAcceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    motorcycles?: MotorcycleUpdateManyWithoutUserNestedInput
    serviceRequests?: ServiceRequestUpdateManyWithoutUserNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
    incidentReports?: IncidentReportUpdateManyWithoutReporterNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    chatMessages?: ChatMessageUpdateManyWithoutSenderNestedInput
    workshop?: WorkshopUpdateOneWithoutUserNestedInput
  }

  export type UserProfileUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    clerkUserId?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    notifChannel?: EnumNotificationChannelFieldUpdateOperationsInput | $Enums.NotificationChannel
    phoneVisible?: BoolFieldUpdateOperationsInput | boolean
    termsAccepted?: BoolFieldUpdateOperationsInput | boolean
    termsVersion?: NullableStringFieldUpdateOperationsInput | string | null
    termsAcceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    privacyAccepted?: BoolFieldUpdateOperationsInput | boolean
    privacyVersion?: NullableStringFieldUpdateOperationsInput | string | null
    privacyAcceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    motorcycles?: MotorcycleUncheckedUpdateManyWithoutUserNestedInput
    serviceRequests?: ServiceRequestUncheckedUpdateManyWithoutUserNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
    incidentReports?: IncidentReportUncheckedUpdateManyWithoutReporterNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    chatMessages?: ChatMessageUncheckedUpdateManyWithoutSenderNestedInput
    workshop?: WorkshopUncheckedUpdateOneWithoutUserNestedInput
  }

  export type UserProfileCreateManyInput = {
    id?: string
    clerkUserId: string
    role?: $Enums.UserRole
    email?: string | null
    phone?: string | null
    name?: string | null
    district?: string | null
    avatarUrl?: string | null
    notifChannel?: $Enums.NotificationChannel
    phoneVisible?: boolean
    termsAccepted?: boolean
    termsVersion?: string | null
    termsAcceptedAt?: Date | string | null
    privacyAccepted?: boolean
    privacyVersion?: string | null
    privacyAcceptedAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserProfileUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    clerkUserId?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    notifChannel?: EnumNotificationChannelFieldUpdateOperationsInput | $Enums.NotificationChannel
    phoneVisible?: BoolFieldUpdateOperationsInput | boolean
    termsAccepted?: BoolFieldUpdateOperationsInput | boolean
    termsVersion?: NullableStringFieldUpdateOperationsInput | string | null
    termsAcceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    privacyAccepted?: BoolFieldUpdateOperationsInput | boolean
    privacyVersion?: NullableStringFieldUpdateOperationsInput | string | null
    privacyAcceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserProfileUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    clerkUserId?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    notifChannel?: EnumNotificationChannelFieldUpdateOperationsInput | $Enums.NotificationChannel
    phoneVisible?: BoolFieldUpdateOperationsInput | boolean
    termsAccepted?: BoolFieldUpdateOperationsInput | boolean
    termsVersion?: NullableStringFieldUpdateOperationsInput | string | null
    termsAcceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    privacyAccepted?: BoolFieldUpdateOperationsInput | boolean
    privacyVersion?: NullableStringFieldUpdateOperationsInput | string | null
    privacyAcceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MotorcycleCreateInput = {
    id?: string
    brand: string
    model: string
    year: number
    displacement?: number | null
    use?: $Enums.MotorcycleUse | null
    kmApprox?: number | null
    placa?: string | null
    alias?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserProfileCreateNestedOneWithoutMotorcyclesInput
    serviceRequests?: ServiceRequestCreateNestedManyWithoutMotorcycleInput
  }

  export type MotorcycleUncheckedCreateInput = {
    id?: string
    userId: string
    brand: string
    model: string
    year: number
    displacement?: number | null
    use?: $Enums.MotorcycleUse | null
    kmApprox?: number | null
    placa?: string | null
    alias?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    serviceRequests?: ServiceRequestUncheckedCreateNestedManyWithoutMotorcycleInput
  }

  export type MotorcycleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    brand?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    displacement?: NullableIntFieldUpdateOperationsInput | number | null
    use?: NullableEnumMotorcycleUseFieldUpdateOperationsInput | $Enums.MotorcycleUse | null
    kmApprox?: NullableIntFieldUpdateOperationsInput | number | null
    placa?: NullableStringFieldUpdateOperationsInput | string | null
    alias?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserProfileUpdateOneRequiredWithoutMotorcyclesNestedInput
    serviceRequests?: ServiceRequestUpdateManyWithoutMotorcycleNestedInput
  }

  export type MotorcycleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    brand?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    displacement?: NullableIntFieldUpdateOperationsInput | number | null
    use?: NullableEnumMotorcycleUseFieldUpdateOperationsInput | $Enums.MotorcycleUse | null
    kmApprox?: NullableIntFieldUpdateOperationsInput | number | null
    placa?: NullableStringFieldUpdateOperationsInput | string | null
    alias?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    serviceRequests?: ServiceRequestUncheckedUpdateManyWithoutMotorcycleNestedInput
  }

  export type MotorcycleCreateManyInput = {
    id?: string
    userId: string
    brand: string
    model: string
    year: number
    displacement?: number | null
    use?: $Enums.MotorcycleUse | null
    kmApprox?: number | null
    placa?: string | null
    alias?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MotorcycleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    brand?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    displacement?: NullableIntFieldUpdateOperationsInput | number | null
    use?: NullableEnumMotorcycleUseFieldUpdateOperationsInput | $Enums.MotorcycleUse | null
    kmApprox?: NullableIntFieldUpdateOperationsInput | number | null
    placa?: NullableStringFieldUpdateOperationsInput | string | null
    alias?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MotorcycleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    brand?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    displacement?: NullableIntFieldUpdateOperationsInput | number | null
    use?: NullableEnumMotorcycleUseFieldUpdateOperationsInput | $Enums.MotorcycleUse | null
    kmApprox?: NullableIntFieldUpdateOperationsInput | number | null
    placa?: NullableStringFieldUpdateOperationsInput | string | null
    alias?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CategoryCreateInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    version?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    parent?: CategoryCreateNestedOneWithoutChildrenInput
    children?: CategoryCreateNestedManyWithoutParentInput
    guideQuestions?: GuideQuestionCreateNestedManyWithoutCategoryInput
    serviceRequests?: ServiceRequestCreateNestedManyWithoutCategoryInput
    workshopCategories?: WorkshopCategoryCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUncheckedCreateInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    parentId?: string | null
    version?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    children?: CategoryUncheckedCreateNestedManyWithoutParentInput
    guideQuestions?: GuideQuestionUncheckedCreateNestedManyWithoutCategoryInput
    serviceRequests?: ServiceRequestUncheckedCreateNestedManyWithoutCategoryInput
    workshopCategories?: WorkshopCategoryUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parent?: CategoryUpdateOneWithoutChildrenNestedInput
    children?: CategoryUpdateManyWithoutParentNestedInput
    guideQuestions?: GuideQuestionUpdateManyWithoutCategoryNestedInput
    serviceRequests?: ServiceRequestUpdateManyWithoutCategoryNestedInput
    workshopCategories?: WorkshopCategoryUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: CategoryUncheckedUpdateManyWithoutParentNestedInput
    guideQuestions?: GuideQuestionUncheckedUpdateManyWithoutCategoryNestedInput
    serviceRequests?: ServiceRequestUncheckedUpdateManyWithoutCategoryNestedInput
    workshopCategories?: WorkshopCategoryUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryCreateManyInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    parentId?: string | null
    version?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CategoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CategoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GuideQuestionCreateInput = {
    id?: string
    question: string
    inputType?: string
    options?: string | null
    order?: number
    isActive?: boolean
    createdAt?: Date | string
    category: CategoryCreateNestedOneWithoutGuideQuestionsInput
    answers?: GuideAnswerCreateNestedManyWithoutQuestionInput
  }

  export type GuideQuestionUncheckedCreateInput = {
    id?: string
    categoryId: string
    question: string
    inputType?: string
    options?: string | null
    order?: number
    isActive?: boolean
    createdAt?: Date | string
    answers?: GuideAnswerUncheckedCreateNestedManyWithoutQuestionInput
  }

  export type GuideQuestionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    inputType?: StringFieldUpdateOperationsInput | string
    options?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: CategoryUpdateOneRequiredWithoutGuideQuestionsNestedInput
    answers?: GuideAnswerUpdateManyWithoutQuestionNestedInput
  }

  export type GuideQuestionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    inputType?: StringFieldUpdateOperationsInput | string
    options?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    answers?: GuideAnswerUncheckedUpdateManyWithoutQuestionNestedInput
  }

  export type GuideQuestionCreateManyInput = {
    id?: string
    categoryId: string
    question: string
    inputType?: string
    options?: string | null
    order?: number
    isActive?: boolean
    createdAt?: Date | string
  }

  export type GuideQuestionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    inputType?: StringFieldUpdateOperationsInput | string
    options?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GuideQuestionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    inputType?: StringFieldUpdateOperationsInput | string
    options?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GuideAnswerCreateInput = {
    id?: string
    answer: string
    createdAt?: Date | string
    question: GuideQuestionCreateNestedOneWithoutAnswersInput
    request: ServiceRequestCreateNestedOneWithoutGuideAnswersInput
  }

  export type GuideAnswerUncheckedCreateInput = {
    id?: string
    questionId: string
    requestId: string
    answer: string
    createdAt?: Date | string
  }

  export type GuideAnswerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    question?: GuideQuestionUpdateOneRequiredWithoutAnswersNestedInput
    request?: ServiceRequestUpdateOneRequiredWithoutGuideAnswersNestedInput
  }

  export type GuideAnswerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    questionId?: StringFieldUpdateOperationsInput | string
    requestId?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GuideAnswerCreateManyInput = {
    id?: string
    questionId: string
    requestId: string
    answer: string
    createdAt?: Date | string
  }

  export type GuideAnswerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GuideAnswerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    questionId?: StringFieldUpdateOperationsInput | string
    requestId?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceRequestCreateInput = {
    id?: string
    description: string
    district: string
    urgency?: $Enums.UrgencyLevel
    status?: $Enums.ServiceRequestStatus
    completionScore?: number
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserProfileCreateNestedOneWithoutServiceRequestsInput
    motorcycle: MotorcycleCreateNestedOneWithoutServiceRequestsInput
    category: CategoryCreateNestedOneWithoutServiceRequestsInput
    media?: RequestMediaCreateNestedManyWithoutRequestInput
    guideAnswers?: GuideAnswerCreateNestedManyWithoutRequestInput
    quotes?: QuoteCreateNestedManyWithoutRequestInput
    statusHistory?: RequestStatusHistoryCreateNestedManyWithoutRequestInput
    notifications?: NotificationCreateNestedManyWithoutRequestInput
    workOrder?: WorkOrderCreateNestedOneWithoutRequestInput
    chatMessages?: ChatMessageCreateNestedManyWithoutRequestInput
    aiSuggestions?: AiSuggestionCreateNestedManyWithoutRequestInput
  }

  export type ServiceRequestUncheckedCreateInput = {
    id?: string
    userId: string
    motorcycleId: string
    categoryId: string
    description: string
    district: string
    urgency?: $Enums.UrgencyLevel
    status?: $Enums.ServiceRequestStatus
    completionScore?: number
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    media?: RequestMediaUncheckedCreateNestedManyWithoutRequestInput
    guideAnswers?: GuideAnswerUncheckedCreateNestedManyWithoutRequestInput
    quotes?: QuoteUncheckedCreateNestedManyWithoutRequestInput
    statusHistory?: RequestStatusHistoryUncheckedCreateNestedManyWithoutRequestInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutRequestInput
    workOrder?: WorkOrderUncheckedCreateNestedOneWithoutRequestInput
    chatMessages?: ChatMessageUncheckedCreateNestedManyWithoutRequestInput
    aiSuggestions?: AiSuggestionUncheckedCreateNestedManyWithoutRequestInput
  }

  export type ServiceRequestUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    district?: StringFieldUpdateOperationsInput | string
    urgency?: EnumUrgencyLevelFieldUpdateOperationsInput | $Enums.UrgencyLevel
    status?: EnumServiceRequestStatusFieldUpdateOperationsInput | $Enums.ServiceRequestStatus
    completionScore?: IntFieldUpdateOperationsInput | number
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserProfileUpdateOneRequiredWithoutServiceRequestsNestedInput
    motorcycle?: MotorcycleUpdateOneRequiredWithoutServiceRequestsNestedInput
    category?: CategoryUpdateOneRequiredWithoutServiceRequestsNestedInput
    media?: RequestMediaUpdateManyWithoutRequestNestedInput
    guideAnswers?: GuideAnswerUpdateManyWithoutRequestNestedInput
    quotes?: QuoteUpdateManyWithoutRequestNestedInput
    statusHistory?: RequestStatusHistoryUpdateManyWithoutRequestNestedInput
    notifications?: NotificationUpdateManyWithoutRequestNestedInput
    workOrder?: WorkOrderUpdateOneWithoutRequestNestedInput
    chatMessages?: ChatMessageUpdateManyWithoutRequestNestedInput
    aiSuggestions?: AiSuggestionUpdateManyWithoutRequestNestedInput
  }

  export type ServiceRequestUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    motorcycleId?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    district?: StringFieldUpdateOperationsInput | string
    urgency?: EnumUrgencyLevelFieldUpdateOperationsInput | $Enums.UrgencyLevel
    status?: EnumServiceRequestStatusFieldUpdateOperationsInput | $Enums.ServiceRequestStatus
    completionScore?: IntFieldUpdateOperationsInput | number
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    media?: RequestMediaUncheckedUpdateManyWithoutRequestNestedInput
    guideAnswers?: GuideAnswerUncheckedUpdateManyWithoutRequestNestedInput
    quotes?: QuoteUncheckedUpdateManyWithoutRequestNestedInput
    statusHistory?: RequestStatusHistoryUncheckedUpdateManyWithoutRequestNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutRequestNestedInput
    workOrder?: WorkOrderUncheckedUpdateOneWithoutRequestNestedInput
    chatMessages?: ChatMessageUncheckedUpdateManyWithoutRequestNestedInput
    aiSuggestions?: AiSuggestionUncheckedUpdateManyWithoutRequestNestedInput
  }

  export type ServiceRequestCreateManyInput = {
    id?: string
    userId: string
    motorcycleId: string
    categoryId: string
    description: string
    district: string
    urgency?: $Enums.UrgencyLevel
    status?: $Enums.ServiceRequestStatus
    completionScore?: number
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ServiceRequestUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    district?: StringFieldUpdateOperationsInput | string
    urgency?: EnumUrgencyLevelFieldUpdateOperationsInput | $Enums.UrgencyLevel
    status?: EnumServiceRequestStatusFieldUpdateOperationsInput | $Enums.ServiceRequestStatus
    completionScore?: IntFieldUpdateOperationsInput | number
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceRequestUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    motorcycleId?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    district?: StringFieldUpdateOperationsInput | string
    urgency?: EnumUrgencyLevelFieldUpdateOperationsInput | $Enums.UrgencyLevel
    status?: EnumServiceRequestStatusFieldUpdateOperationsInput | $Enums.ServiceRequestStatus
    completionScore?: IntFieldUpdateOperationsInput | number
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RequestMediaCreateInput = {
    id?: string
    url: string
    mediaType: $Enums.MediaType
    fileName?: string | null
    fileSize?: number | null
    createdAt?: Date | string
    request: ServiceRequestCreateNestedOneWithoutMediaInput
  }

  export type RequestMediaUncheckedCreateInput = {
    id?: string
    requestId: string
    url: string
    mediaType: $Enums.MediaType
    fileName?: string | null
    fileSize?: number | null
    createdAt?: Date | string
  }

  export type RequestMediaUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    mediaType?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    fileName?: NullableStringFieldUpdateOperationsInput | string | null
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    request?: ServiceRequestUpdateOneRequiredWithoutMediaNestedInput
  }

  export type RequestMediaUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    requestId?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    mediaType?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    fileName?: NullableStringFieldUpdateOperationsInput | string | null
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RequestMediaCreateManyInput = {
    id?: string
    requestId: string
    url: string
    mediaType: $Enums.MediaType
    fileName?: string | null
    fileSize?: number | null
    createdAt?: Date | string
  }

  export type RequestMediaUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    mediaType?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    fileName?: NullableStringFieldUpdateOperationsInput | string | null
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RequestMediaUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    requestId?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    mediaType?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    fileName?: NullableStringFieldUpdateOperationsInput | string | null
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RequestStatusHistoryCreateInput = {
    id?: string
    fromStatus?: $Enums.ServiceRequestStatus | null
    toStatus: $Enums.ServiceRequestStatus
    actorId?: string | null
    reason?: string | null
    createdAt?: Date | string
    request: ServiceRequestCreateNestedOneWithoutStatusHistoryInput
  }

  export type RequestStatusHistoryUncheckedCreateInput = {
    id?: string
    requestId: string
    fromStatus?: $Enums.ServiceRequestStatus | null
    toStatus: $Enums.ServiceRequestStatus
    actorId?: string | null
    reason?: string | null
    createdAt?: Date | string
  }

  export type RequestStatusHistoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    fromStatus?: NullableEnumServiceRequestStatusFieldUpdateOperationsInput | $Enums.ServiceRequestStatus | null
    toStatus?: EnumServiceRequestStatusFieldUpdateOperationsInput | $Enums.ServiceRequestStatus
    actorId?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    request?: ServiceRequestUpdateOneRequiredWithoutStatusHistoryNestedInput
  }

  export type RequestStatusHistoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    requestId?: StringFieldUpdateOperationsInput | string
    fromStatus?: NullableEnumServiceRequestStatusFieldUpdateOperationsInput | $Enums.ServiceRequestStatus | null
    toStatus?: EnumServiceRequestStatusFieldUpdateOperationsInput | $Enums.ServiceRequestStatus
    actorId?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RequestStatusHistoryCreateManyInput = {
    id?: string
    requestId: string
    fromStatus?: $Enums.ServiceRequestStatus | null
    toStatus: $Enums.ServiceRequestStatus
    actorId?: string | null
    reason?: string | null
    createdAt?: Date | string
  }

  export type RequestStatusHistoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    fromStatus?: NullableEnumServiceRequestStatusFieldUpdateOperationsInput | $Enums.ServiceRequestStatus | null
    toStatus?: EnumServiceRequestStatusFieldUpdateOperationsInput | $Enums.ServiceRequestStatus
    actorId?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RequestStatusHistoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    requestId?: StringFieldUpdateOperationsInput | string
    fromStatus?: NullableEnumServiceRequestStatusFieldUpdateOperationsInput | $Enums.ServiceRequestStatus | null
    toStatus?: EnumServiceRequestStatusFieldUpdateOperationsInput | $Enums.ServiceRequestStatus
    actorId?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkshopCreateInput = {
    id?: string
    name: string
    address: string
    district: string
    phone: string
    ruc?: string | null
    description?: string | null
    photoUrl?: string | null
    status?: $Enums.WorkshopStatus
    transparencyAccepted?: boolean
    guaranteePolicy?: string | null
    latitude?: number | null
    longitude?: number | null
    rating?: number
    totalServices?: number
    evidenceRate?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserProfileCreateNestedOneWithoutWorkshopInput
    categories?: WorkshopCategoryCreateNestedManyWithoutWorkshopInput
    quotes?: QuoteCreateNestedManyWithoutWorkshopInput
    workOrders?: WorkOrderCreateNestedManyWithoutWorkshopInput
    reviews?: ReviewCreateNestedManyWithoutWorkshopInput
    incidentReports?: IncidentReportCreateNestedManyWithoutWorkshopInput
    verifications?: WorkshopVerificationCreateNestedManyWithoutWorkshopInput
  }

  export type WorkshopUncheckedCreateInput = {
    id?: string
    userId: string
    name: string
    address: string
    district: string
    phone: string
    ruc?: string | null
    description?: string | null
    photoUrl?: string | null
    status?: $Enums.WorkshopStatus
    transparencyAccepted?: boolean
    guaranteePolicy?: string | null
    latitude?: number | null
    longitude?: number | null
    rating?: number
    totalServices?: number
    evidenceRate?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    categories?: WorkshopCategoryUncheckedCreateNestedManyWithoutWorkshopInput
    quotes?: QuoteUncheckedCreateNestedManyWithoutWorkshopInput
    workOrders?: WorkOrderUncheckedCreateNestedManyWithoutWorkshopInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutWorkshopInput
    incidentReports?: IncidentReportUncheckedCreateNestedManyWithoutWorkshopInput
    verifications?: WorkshopVerificationUncheckedCreateNestedManyWithoutWorkshopInput
  }

  export type WorkshopUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    district?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    ruc?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumWorkshopStatusFieldUpdateOperationsInput | $Enums.WorkshopStatus
    transparencyAccepted?: BoolFieldUpdateOperationsInput | boolean
    guaranteePolicy?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    rating?: FloatFieldUpdateOperationsInput | number
    totalServices?: IntFieldUpdateOperationsInput | number
    evidenceRate?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserProfileUpdateOneRequiredWithoutWorkshopNestedInput
    categories?: WorkshopCategoryUpdateManyWithoutWorkshopNestedInput
    quotes?: QuoteUpdateManyWithoutWorkshopNestedInput
    workOrders?: WorkOrderUpdateManyWithoutWorkshopNestedInput
    reviews?: ReviewUpdateManyWithoutWorkshopNestedInput
    incidentReports?: IncidentReportUpdateManyWithoutWorkshopNestedInput
    verifications?: WorkshopVerificationUpdateManyWithoutWorkshopNestedInput
  }

  export type WorkshopUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    district?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    ruc?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumWorkshopStatusFieldUpdateOperationsInput | $Enums.WorkshopStatus
    transparencyAccepted?: BoolFieldUpdateOperationsInput | boolean
    guaranteePolicy?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    rating?: FloatFieldUpdateOperationsInput | number
    totalServices?: IntFieldUpdateOperationsInput | number
    evidenceRate?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    categories?: WorkshopCategoryUncheckedUpdateManyWithoutWorkshopNestedInput
    quotes?: QuoteUncheckedUpdateManyWithoutWorkshopNestedInput
    workOrders?: WorkOrderUncheckedUpdateManyWithoutWorkshopNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutWorkshopNestedInput
    incidentReports?: IncidentReportUncheckedUpdateManyWithoutWorkshopNestedInput
    verifications?: WorkshopVerificationUncheckedUpdateManyWithoutWorkshopNestedInput
  }

  export type WorkshopCreateManyInput = {
    id?: string
    userId: string
    name: string
    address: string
    district: string
    phone: string
    ruc?: string | null
    description?: string | null
    photoUrl?: string | null
    status?: $Enums.WorkshopStatus
    transparencyAccepted?: boolean
    guaranteePolicy?: string | null
    latitude?: number | null
    longitude?: number | null
    rating?: number
    totalServices?: number
    evidenceRate?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WorkshopUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    district?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    ruc?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumWorkshopStatusFieldUpdateOperationsInput | $Enums.WorkshopStatus
    transparencyAccepted?: BoolFieldUpdateOperationsInput | boolean
    guaranteePolicy?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    rating?: FloatFieldUpdateOperationsInput | number
    totalServices?: IntFieldUpdateOperationsInput | number
    evidenceRate?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkshopUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    district?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    ruc?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumWorkshopStatusFieldUpdateOperationsInput | $Enums.WorkshopStatus
    transparencyAccepted?: BoolFieldUpdateOperationsInput | boolean
    guaranteePolicy?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    rating?: FloatFieldUpdateOperationsInput | number
    totalServices?: IntFieldUpdateOperationsInput | number
    evidenceRate?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkshopCategoryCreateInput = {
    id?: string
    workshop: WorkshopCreateNestedOneWithoutCategoriesInput
    category: CategoryCreateNestedOneWithoutWorkshopCategoriesInput
  }

  export type WorkshopCategoryUncheckedCreateInput = {
    id?: string
    workshopId: string
    categoryId: string
  }

  export type WorkshopCategoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    workshop?: WorkshopUpdateOneRequiredWithoutCategoriesNestedInput
    category?: CategoryUpdateOneRequiredWithoutWorkshopCategoriesNestedInput
  }

  export type WorkshopCategoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    workshopId?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
  }

  export type WorkshopCategoryCreateManyInput = {
    id?: string
    workshopId: string
    categoryId: string
  }

  export type WorkshopCategoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
  }

  export type WorkshopCategoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    workshopId?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
  }

  export type WorkshopVerificationCreateInput = {
    id?: string
    adminId: string
    decision: $Enums.WorkshopStatus
    reason: string
    createdAt?: Date | string
    workshop: WorkshopCreateNestedOneWithoutVerificationsInput
  }

  export type WorkshopVerificationUncheckedCreateInput = {
    id?: string
    workshopId: string
    adminId: string
    decision: $Enums.WorkshopStatus
    reason: string
    createdAt?: Date | string
  }

  export type WorkshopVerificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    adminId?: StringFieldUpdateOperationsInput | string
    decision?: EnumWorkshopStatusFieldUpdateOperationsInput | $Enums.WorkshopStatus
    reason?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workshop?: WorkshopUpdateOneRequiredWithoutVerificationsNestedInput
  }

  export type WorkshopVerificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    workshopId?: StringFieldUpdateOperationsInput | string
    adminId?: StringFieldUpdateOperationsInput | string
    decision?: EnumWorkshopStatusFieldUpdateOperationsInput | $Enums.WorkshopStatus
    reason?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkshopVerificationCreateManyInput = {
    id?: string
    workshopId: string
    adminId: string
    decision: $Enums.WorkshopStatus
    reason: string
    createdAt?: Date | string
  }

  export type WorkshopVerificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    adminId?: StringFieldUpdateOperationsInput | string
    decision?: EnumWorkshopStatusFieldUpdateOperationsInput | $Enums.WorkshopStatus
    reason?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkshopVerificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    workshopId?: StringFieldUpdateOperationsInput | string
    adminId?: StringFieldUpdateOperationsInput | string
    decision?: EnumWorkshopStatusFieldUpdateOperationsInput | $Enums.WorkshopStatus
    reason?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuoteCreateInput = {
    id?: string
    version?: number
    diagnosis: string
    laborCost: number
    totalParts?: number
    totalCost: number
    estimatedTime: string
    validUntil: Date | string
    notes?: string | null
    status?: $Enums.QuoteStatus
    rejectionReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    request: ServiceRequestCreateNestedOneWithoutQuotesInput
    workshop: WorkshopCreateNestedOneWithoutQuotesInput
    parts?: QuotePartItemCreateNestedManyWithoutQuoteInput
    workOrder?: WorkOrderCreateNestedOneWithoutQuoteInput
    aiAnalysis?: AiQuoteAnalysisCreateNestedManyWithoutQuoteInput
  }

  export type QuoteUncheckedCreateInput = {
    id?: string
    requestId: string
    workshopId: string
    version?: number
    diagnosis: string
    laborCost: number
    totalParts?: number
    totalCost: number
    estimatedTime: string
    validUntil: Date | string
    notes?: string | null
    status?: $Enums.QuoteStatus
    rejectionReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    parts?: QuotePartItemUncheckedCreateNestedManyWithoutQuoteInput
    workOrder?: WorkOrderUncheckedCreateNestedOneWithoutQuoteInput
    aiAnalysis?: AiQuoteAnalysisUncheckedCreateNestedManyWithoutQuoteInput
  }

  export type QuoteUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    diagnosis?: StringFieldUpdateOperationsInput | string
    laborCost?: FloatFieldUpdateOperationsInput | number
    totalParts?: FloatFieldUpdateOperationsInput | number
    totalCost?: FloatFieldUpdateOperationsInput | number
    estimatedTime?: StringFieldUpdateOperationsInput | string
    validUntil?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumQuoteStatusFieldUpdateOperationsInput | $Enums.QuoteStatus
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    request?: ServiceRequestUpdateOneRequiredWithoutQuotesNestedInput
    workshop?: WorkshopUpdateOneRequiredWithoutQuotesNestedInput
    parts?: QuotePartItemUpdateManyWithoutQuoteNestedInput
    workOrder?: WorkOrderUpdateOneWithoutQuoteNestedInput
    aiAnalysis?: AiQuoteAnalysisUpdateManyWithoutQuoteNestedInput
  }

  export type QuoteUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    requestId?: StringFieldUpdateOperationsInput | string
    workshopId?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    diagnosis?: StringFieldUpdateOperationsInput | string
    laborCost?: FloatFieldUpdateOperationsInput | number
    totalParts?: FloatFieldUpdateOperationsInput | number
    totalCost?: FloatFieldUpdateOperationsInput | number
    estimatedTime?: StringFieldUpdateOperationsInput | string
    validUntil?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumQuoteStatusFieldUpdateOperationsInput | $Enums.QuoteStatus
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parts?: QuotePartItemUncheckedUpdateManyWithoutQuoteNestedInput
    workOrder?: WorkOrderUncheckedUpdateOneWithoutQuoteNestedInput
    aiAnalysis?: AiQuoteAnalysisUncheckedUpdateManyWithoutQuoteNestedInput
  }

  export type QuoteCreateManyInput = {
    id?: string
    requestId: string
    workshopId: string
    version?: number
    diagnosis: string
    laborCost: number
    totalParts?: number
    totalCost: number
    estimatedTime: string
    validUntil: Date | string
    notes?: string | null
    status?: $Enums.QuoteStatus
    rejectionReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuoteUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    diagnosis?: StringFieldUpdateOperationsInput | string
    laborCost?: FloatFieldUpdateOperationsInput | number
    totalParts?: FloatFieldUpdateOperationsInput | number
    totalCost?: FloatFieldUpdateOperationsInput | number
    estimatedTime?: StringFieldUpdateOperationsInput | string
    validUntil?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumQuoteStatusFieldUpdateOperationsInput | $Enums.QuoteStatus
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuoteUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    requestId?: StringFieldUpdateOperationsInput | string
    workshopId?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    diagnosis?: StringFieldUpdateOperationsInput | string
    laborCost?: FloatFieldUpdateOperationsInput | number
    totalParts?: FloatFieldUpdateOperationsInput | number
    totalCost?: FloatFieldUpdateOperationsInput | number
    estimatedTime?: StringFieldUpdateOperationsInput | string
    validUntil?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumQuoteStatusFieldUpdateOperationsInput | $Enums.QuoteStatus
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuotePartItemCreateInput = {
    id?: string
    name: string
    quantity?: number
    unitPrice: number
    partType?: $Enums.PartType
    notes?: string | null
    alternativeName?: string | null
    alternativePrice?: number | null
    alternativeType?: $Enums.PartType | null
    alternativeNotes?: string | null
    selectedAlternative?: boolean
    createdAt?: Date | string
    quote: QuoteCreateNestedOneWithoutPartsInput
  }

  export type QuotePartItemUncheckedCreateInput = {
    id?: string
    quoteId: string
    name: string
    quantity?: number
    unitPrice: number
    partType?: $Enums.PartType
    notes?: string | null
    alternativeName?: string | null
    alternativePrice?: number | null
    alternativeType?: $Enums.PartType | null
    alternativeNotes?: string | null
    selectedAlternative?: boolean
    createdAt?: Date | string
  }

  export type QuotePartItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    partType?: EnumPartTypeFieldUpdateOperationsInput | $Enums.PartType
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    alternativeName?: NullableStringFieldUpdateOperationsInput | string | null
    alternativePrice?: NullableFloatFieldUpdateOperationsInput | number | null
    alternativeType?: NullableEnumPartTypeFieldUpdateOperationsInput | $Enums.PartType | null
    alternativeNotes?: NullableStringFieldUpdateOperationsInput | string | null
    selectedAlternative?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quote?: QuoteUpdateOneRequiredWithoutPartsNestedInput
  }

  export type QuotePartItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    quoteId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    partType?: EnumPartTypeFieldUpdateOperationsInput | $Enums.PartType
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    alternativeName?: NullableStringFieldUpdateOperationsInput | string | null
    alternativePrice?: NullableFloatFieldUpdateOperationsInput | number | null
    alternativeType?: NullableEnumPartTypeFieldUpdateOperationsInput | $Enums.PartType | null
    alternativeNotes?: NullableStringFieldUpdateOperationsInput | string | null
    selectedAlternative?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuotePartItemCreateManyInput = {
    id?: string
    quoteId: string
    name: string
    quantity?: number
    unitPrice: number
    partType?: $Enums.PartType
    notes?: string | null
    alternativeName?: string | null
    alternativePrice?: number | null
    alternativeType?: $Enums.PartType | null
    alternativeNotes?: string | null
    selectedAlternative?: boolean
    createdAt?: Date | string
  }

  export type QuotePartItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    partType?: EnumPartTypeFieldUpdateOperationsInput | $Enums.PartType
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    alternativeName?: NullableStringFieldUpdateOperationsInput | string | null
    alternativePrice?: NullableFloatFieldUpdateOperationsInput | number | null
    alternativeType?: NullableEnumPartTypeFieldUpdateOperationsInput | $Enums.PartType | null
    alternativeNotes?: NullableStringFieldUpdateOperationsInput | string | null
    selectedAlternative?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuotePartItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    quoteId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    partType?: EnumPartTypeFieldUpdateOperationsInput | $Enums.PartType
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    alternativeName?: NullableStringFieldUpdateOperationsInput | string | null
    alternativePrice?: NullableFloatFieldUpdateOperationsInput | number | null
    alternativeType?: NullableEnumPartTypeFieldUpdateOperationsInput | $Enums.PartType | null
    alternativeNotes?: NullableStringFieldUpdateOperationsInput | string | null
    selectedAlternative?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkOrderCreateInput = {
    id?: string
    orderNumber: string
    diagnosis: string
    totalAgreed: number
    totalFinal?: number | null
    status?: $Enums.WorkOrderStatus
    userAcceptedAt?: Date | string | null
    workshopAcceptedAt?: Date | string | null
    startedAt?: Date | string | null
    startNote?: string | null
    completedAt?: Date | string | null
    closedAt?: Date | string | null
    closureChecklist?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    request: ServiceRequestCreateNestedOneWithoutWorkOrderInput
    quote: QuoteCreateNestedOneWithoutWorkOrderInput
    workshop: WorkshopCreateNestedOneWithoutWorkOrdersInput
    changeRequests?: ChangeRequestCreateNestedManyWithoutWorkOrderInput
    evidences?: EvidenceCreateNestedManyWithoutWorkOrderInput
    review?: ReviewCreateNestedOneWithoutWorkOrderInput
    receipt?: ReceiptCreateNestedOneWithoutWorkOrderInput
  }

  export type WorkOrderUncheckedCreateInput = {
    id?: string
    orderNumber: string
    requestId: string
    quoteId: string
    workshopId: string
    diagnosis: string
    totalAgreed: number
    totalFinal?: number | null
    status?: $Enums.WorkOrderStatus
    userAcceptedAt?: Date | string | null
    workshopAcceptedAt?: Date | string | null
    startedAt?: Date | string | null
    startNote?: string | null
    completedAt?: Date | string | null
    closedAt?: Date | string | null
    closureChecklist?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    changeRequests?: ChangeRequestUncheckedCreateNestedManyWithoutWorkOrderInput
    evidences?: EvidenceUncheckedCreateNestedManyWithoutWorkOrderInput
    review?: ReviewUncheckedCreateNestedOneWithoutWorkOrderInput
    receipt?: ReceiptUncheckedCreateNestedOneWithoutWorkOrderInput
  }

  export type WorkOrderUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    diagnosis?: StringFieldUpdateOperationsInput | string
    totalAgreed?: FloatFieldUpdateOperationsInput | number
    totalFinal?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumWorkOrderStatusFieldUpdateOperationsInput | $Enums.WorkOrderStatus
    userAcceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    workshopAcceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startNote?: NullableStringFieldUpdateOperationsInput | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closureChecklist?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    request?: ServiceRequestUpdateOneRequiredWithoutWorkOrderNestedInput
    quote?: QuoteUpdateOneRequiredWithoutWorkOrderNestedInput
    workshop?: WorkshopUpdateOneRequiredWithoutWorkOrdersNestedInput
    changeRequests?: ChangeRequestUpdateManyWithoutWorkOrderNestedInput
    evidences?: EvidenceUpdateManyWithoutWorkOrderNestedInput
    review?: ReviewUpdateOneWithoutWorkOrderNestedInput
    receipt?: ReceiptUpdateOneWithoutWorkOrderNestedInput
  }

  export type WorkOrderUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    requestId?: StringFieldUpdateOperationsInput | string
    quoteId?: StringFieldUpdateOperationsInput | string
    workshopId?: StringFieldUpdateOperationsInput | string
    diagnosis?: StringFieldUpdateOperationsInput | string
    totalAgreed?: FloatFieldUpdateOperationsInput | number
    totalFinal?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumWorkOrderStatusFieldUpdateOperationsInput | $Enums.WorkOrderStatus
    userAcceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    workshopAcceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startNote?: NullableStringFieldUpdateOperationsInput | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closureChecklist?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    changeRequests?: ChangeRequestUncheckedUpdateManyWithoutWorkOrderNestedInput
    evidences?: EvidenceUncheckedUpdateManyWithoutWorkOrderNestedInput
    review?: ReviewUncheckedUpdateOneWithoutWorkOrderNestedInput
    receipt?: ReceiptUncheckedUpdateOneWithoutWorkOrderNestedInput
  }

  export type WorkOrderCreateManyInput = {
    id?: string
    orderNumber: string
    requestId: string
    quoteId: string
    workshopId: string
    diagnosis: string
    totalAgreed: number
    totalFinal?: number | null
    status?: $Enums.WorkOrderStatus
    userAcceptedAt?: Date | string | null
    workshopAcceptedAt?: Date | string | null
    startedAt?: Date | string | null
    startNote?: string | null
    completedAt?: Date | string | null
    closedAt?: Date | string | null
    closureChecklist?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WorkOrderUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    diagnosis?: StringFieldUpdateOperationsInput | string
    totalAgreed?: FloatFieldUpdateOperationsInput | number
    totalFinal?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumWorkOrderStatusFieldUpdateOperationsInput | $Enums.WorkOrderStatus
    userAcceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    workshopAcceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startNote?: NullableStringFieldUpdateOperationsInput | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closureChecklist?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkOrderUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    requestId?: StringFieldUpdateOperationsInput | string
    quoteId?: StringFieldUpdateOperationsInput | string
    workshopId?: StringFieldUpdateOperationsInput | string
    diagnosis?: StringFieldUpdateOperationsInput | string
    totalAgreed?: FloatFieldUpdateOperationsInput | number
    totalFinal?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumWorkOrderStatusFieldUpdateOperationsInput | $Enums.WorkOrderStatus
    userAcceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    workshopAcceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startNote?: NullableStringFieldUpdateOperationsInput | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closureChecklist?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChangeRequestCreateInput = {
    id?: string
    description: string
    justification: string
    additionalCost: number
    additionalTime?: string | null
    status?: $Enums.ChangeRequestStatus
    decidedAt?: Date | string | null
    decidedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    workOrder: WorkOrderCreateNestedOneWithoutChangeRequestsInput
  }

  export type ChangeRequestUncheckedCreateInput = {
    id?: string
    workOrderId: string
    description: string
    justification: string
    additionalCost: number
    additionalTime?: string | null
    status?: $Enums.ChangeRequestStatus
    decidedAt?: Date | string | null
    decidedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ChangeRequestUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    justification?: StringFieldUpdateOperationsInput | string
    additionalCost?: FloatFieldUpdateOperationsInput | number
    additionalTime?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumChangeRequestStatusFieldUpdateOperationsInput | $Enums.ChangeRequestStatus
    decidedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    decidedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workOrder?: WorkOrderUpdateOneRequiredWithoutChangeRequestsNestedInput
  }

  export type ChangeRequestUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    workOrderId?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    justification?: StringFieldUpdateOperationsInput | string
    additionalCost?: FloatFieldUpdateOperationsInput | number
    additionalTime?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumChangeRequestStatusFieldUpdateOperationsInput | $Enums.ChangeRequestStatus
    decidedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    decidedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChangeRequestCreateManyInput = {
    id?: string
    workOrderId: string
    description: string
    justification: string
    additionalCost: number
    additionalTime?: string | null
    status?: $Enums.ChangeRequestStatus
    decidedAt?: Date | string | null
    decidedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ChangeRequestUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    justification?: StringFieldUpdateOperationsInput | string
    additionalCost?: FloatFieldUpdateOperationsInput | number
    additionalTime?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumChangeRequestStatusFieldUpdateOperationsInput | $Enums.ChangeRequestStatus
    decidedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    decidedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChangeRequestUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    workOrderId?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    justification?: StringFieldUpdateOperationsInput | string
    additionalCost?: FloatFieldUpdateOperationsInput | number
    additionalTime?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumChangeRequestStatusFieldUpdateOperationsInput | $Enums.ChangeRequestStatus
    decidedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    decidedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EvidenceCreateInput = {
    id?: string
    stage: $Enums.EvidenceStage
    url: string
    mediaType: $Enums.MediaType
    fileName?: string | null
    description?: string | null
    flagged?: boolean
    createdAt?: Date | string
    workOrder: WorkOrderCreateNestedOneWithoutEvidencesInput
  }

  export type EvidenceUncheckedCreateInput = {
    id?: string
    workOrderId: string
    stage: $Enums.EvidenceStage
    url: string
    mediaType: $Enums.MediaType
    fileName?: string | null
    description?: string | null
    flagged?: boolean
    createdAt?: Date | string
  }

  export type EvidenceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    stage?: EnumEvidenceStageFieldUpdateOperationsInput | $Enums.EvidenceStage
    url?: StringFieldUpdateOperationsInput | string
    mediaType?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    fileName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    flagged?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workOrder?: WorkOrderUpdateOneRequiredWithoutEvidencesNestedInput
  }

  export type EvidenceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    workOrderId?: StringFieldUpdateOperationsInput | string
    stage?: EnumEvidenceStageFieldUpdateOperationsInput | $Enums.EvidenceStage
    url?: StringFieldUpdateOperationsInput | string
    mediaType?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    fileName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    flagged?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EvidenceCreateManyInput = {
    id?: string
    workOrderId: string
    stage: $Enums.EvidenceStage
    url: string
    mediaType: $Enums.MediaType
    fileName?: string | null
    description?: string | null
    flagged?: boolean
    createdAt?: Date | string
  }

  export type EvidenceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    stage?: EnumEvidenceStageFieldUpdateOperationsInput | $Enums.EvidenceStage
    url?: StringFieldUpdateOperationsInput | string
    mediaType?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    fileName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    flagged?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EvidenceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    workOrderId?: StringFieldUpdateOperationsInput | string
    stage?: EnumEvidenceStageFieldUpdateOperationsInput | $Enums.EvidenceStage
    url?: StringFieldUpdateOperationsInput | string
    mediaType?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    fileName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    flagged?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewCreateInput = {
    id?: string
    rating: number
    comment?: string | null
    editableUntil: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    workOrder: WorkOrderCreateNestedOneWithoutReviewInput
    workshop: WorkshopCreateNestedOneWithoutReviewsInput
    user: UserProfileCreateNestedOneWithoutReviewsInput
  }

  export type ReviewUncheckedCreateInput = {
    id?: string
    workOrderId: string
    workshopId: string
    userId: string
    rating: number
    comment?: string | null
    editableUntil: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReviewUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    editableUntil?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workOrder?: WorkOrderUpdateOneRequiredWithoutReviewNestedInput
    workshop?: WorkshopUpdateOneRequiredWithoutReviewsNestedInput
    user?: UserProfileUpdateOneRequiredWithoutReviewsNestedInput
  }

  export type ReviewUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    workOrderId?: StringFieldUpdateOperationsInput | string
    workshopId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    editableUntil?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewCreateManyInput = {
    id?: string
    workOrderId: string
    workshopId: string
    userId: string
    rating: number
    comment?: string | null
    editableUntil: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReviewUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    editableUntil?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    workOrderId?: StringFieldUpdateOperationsInput | string
    workshopId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    editableUntil?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReceiptCreateInput = {
    id?: string
    totalOriginal: number
    totalChanges: number
    totalFinal: number
    pdfUrl?: string | null
    createdAt?: Date | string
    workOrder: WorkOrderCreateNestedOneWithoutReceiptInput
  }

  export type ReceiptUncheckedCreateInput = {
    id?: string
    workOrderId: string
    totalOriginal: number
    totalChanges: number
    totalFinal: number
    pdfUrl?: string | null
    createdAt?: Date | string
  }

  export type ReceiptUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalOriginal?: FloatFieldUpdateOperationsInput | number
    totalChanges?: FloatFieldUpdateOperationsInput | number
    totalFinal?: FloatFieldUpdateOperationsInput | number
    pdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workOrder?: WorkOrderUpdateOneRequiredWithoutReceiptNestedInput
  }

  export type ReceiptUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    workOrderId?: StringFieldUpdateOperationsInput | string
    totalOriginal?: FloatFieldUpdateOperationsInput | number
    totalChanges?: FloatFieldUpdateOperationsInput | number
    totalFinal?: FloatFieldUpdateOperationsInput | number
    pdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReceiptCreateManyInput = {
    id?: string
    workOrderId: string
    totalOriginal: number
    totalChanges: number
    totalFinal: number
    pdfUrl?: string | null
    createdAt?: Date | string
  }

  export type ReceiptUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalOriginal?: FloatFieldUpdateOperationsInput | number
    totalChanges?: FloatFieldUpdateOperationsInput | number
    totalFinal?: FloatFieldUpdateOperationsInput | number
    pdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReceiptUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    workOrderId?: StringFieldUpdateOperationsInput | string
    totalOriginal?: FloatFieldUpdateOperationsInput | number
    totalChanges?: FloatFieldUpdateOperationsInput | number
    totalFinal?: FloatFieldUpdateOperationsInput | number
    pdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IncidentReportCreateInput = {
    id?: string
    type: $Enums.IncidentType
    description: string
    evidenceUrl?: string | null
    status?: $Enums.IncidentStatus
    resolution?: string | null
    resolvedAt?: Date | string | null
    resolvedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reporter: UserProfileCreateNestedOneWithoutIncidentReportsInput
    workshop: WorkshopCreateNestedOneWithoutIncidentReportsInput
  }

  export type IncidentReportUncheckedCreateInput = {
    id?: string
    reporterId: string
    workshopId: string
    type: $Enums.IncidentType
    description: string
    evidenceUrl?: string | null
    status?: $Enums.IncidentStatus
    resolution?: string | null
    resolvedAt?: Date | string | null
    resolvedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IncidentReportUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumIncidentTypeFieldUpdateOperationsInput | $Enums.IncidentType
    description?: StringFieldUpdateOperationsInput | string
    evidenceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumIncidentStatusFieldUpdateOperationsInput | $Enums.IncidentStatus
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reporter?: UserProfileUpdateOneRequiredWithoutIncidentReportsNestedInput
    workshop?: WorkshopUpdateOneRequiredWithoutIncidentReportsNestedInput
  }

  export type IncidentReportUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    reporterId?: StringFieldUpdateOperationsInput | string
    workshopId?: StringFieldUpdateOperationsInput | string
    type?: EnumIncidentTypeFieldUpdateOperationsInput | $Enums.IncidentType
    description?: StringFieldUpdateOperationsInput | string
    evidenceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumIncidentStatusFieldUpdateOperationsInput | $Enums.IncidentStatus
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IncidentReportCreateManyInput = {
    id?: string
    reporterId: string
    workshopId: string
    type: $Enums.IncidentType
    description: string
    evidenceUrl?: string | null
    status?: $Enums.IncidentStatus
    resolution?: string | null
    resolvedAt?: Date | string | null
    resolvedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IncidentReportUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumIncidentTypeFieldUpdateOperationsInput | $Enums.IncidentType
    description?: StringFieldUpdateOperationsInput | string
    evidenceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumIncidentStatusFieldUpdateOperationsInput | $Enums.IncidentStatus
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IncidentReportUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    reporterId?: StringFieldUpdateOperationsInput | string
    workshopId?: StringFieldUpdateOperationsInput | string
    type?: EnumIncidentTypeFieldUpdateOperationsInput | $Enums.IncidentType
    description?: StringFieldUpdateOperationsInput | string
    evidenceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumIncidentStatusFieldUpdateOperationsInput | $Enums.IncidentStatus
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatMessageCreateInput = {
    id?: string
    content: string
    imageUrl?: string | null
    isRead?: boolean
    createdAt?: Date | string
    request: ServiceRequestCreateNestedOneWithoutChatMessagesInput
    sender: UserProfileCreateNestedOneWithoutChatMessagesInput
  }

  export type ChatMessageUncheckedCreateInput = {
    id?: string
    requestId: string
    senderId: string
    content: string
    imageUrl?: string | null
    isRead?: boolean
    createdAt?: Date | string
  }

  export type ChatMessageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    request?: ServiceRequestUpdateOneRequiredWithoutChatMessagesNestedInput
    sender?: UserProfileUpdateOneRequiredWithoutChatMessagesNestedInput
  }

  export type ChatMessageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    requestId?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatMessageCreateManyInput = {
    id?: string
    requestId: string
    senderId: string
    content: string
    imageUrl?: string | null
    isRead?: boolean
    createdAt?: Date | string
  }

  export type ChatMessageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatMessageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    requestId?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateInput = {
    id?: string
    title: string
    body: string
    channel?: $Enums.NotificationChannel
    isRead?: boolean
    link?: string | null
    createdAt?: Date | string
    user: UserProfileCreateNestedOneWithoutNotificationsInput
    request?: ServiceRequestCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateInput = {
    id?: string
    userId: string
    requestId?: string | null
    title: string
    body: string
    channel?: $Enums.NotificationChannel
    isRead?: boolean
    link?: string | null
    createdAt?: Date | string
  }

  export type NotificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    channel?: EnumNotificationChannelFieldUpdateOperationsInput | $Enums.NotificationChannel
    isRead?: BoolFieldUpdateOperationsInput | boolean
    link?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserProfileUpdateOneRequiredWithoutNotificationsNestedInput
    request?: ServiceRequestUpdateOneWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    requestId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    channel?: EnumNotificationChannelFieldUpdateOperationsInput | $Enums.NotificationChannel
    isRead?: BoolFieldUpdateOperationsInput | boolean
    link?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateManyInput = {
    id?: string
    userId: string
    requestId?: string | null
    title: string
    body: string
    channel?: $Enums.NotificationChannel
    isRead?: boolean
    link?: string | null
    createdAt?: Date | string
  }

  export type NotificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    channel?: EnumNotificationChannelFieldUpdateOperationsInput | $Enums.NotificationChannel
    isRead?: BoolFieldUpdateOperationsInput | boolean
    link?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    requestId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    channel?: EnumNotificationChannelFieldUpdateOperationsInput | $Enums.NotificationChannel
    isRead?: BoolFieldUpdateOperationsInput | boolean
    link?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogCreateInput = {
    id?: string
    actorId: string
    action: $Enums.AdminActionType
    targetType: string
    targetId: string
    reason?: string | null
    metadata?: string | null
    createdAt?: Date | string
  }

  export type AuditLogUncheckedCreateInput = {
    id?: string
    actorId: string
    action: $Enums.AdminActionType
    targetType: string
    targetId: string
    reason?: string | null
    metadata?: string | null
    createdAt?: Date | string
  }

  export type AuditLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    actorId?: StringFieldUpdateOperationsInput | string
    action?: EnumAdminActionTypeFieldUpdateOperationsInput | $Enums.AdminActionType
    targetType?: StringFieldUpdateOperationsInput | string
    targetId?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    actorId?: StringFieldUpdateOperationsInput | string
    action?: EnumAdminActionTypeFieldUpdateOperationsInput | $Enums.AdminActionType
    targetType?: StringFieldUpdateOperationsInput | string
    targetId?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogCreateManyInput = {
    id?: string
    actorId: string
    action: $Enums.AdminActionType
    targetType: string
    targetId: string
    reason?: string | null
    metadata?: string | null
    createdAt?: Date | string
  }

  export type AuditLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    actorId?: StringFieldUpdateOperationsInput | string
    action?: EnumAdminActionTypeFieldUpdateOperationsInput | $Enums.AdminActionType
    targetType?: StringFieldUpdateOperationsInput | string
    targetId?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    actorId?: StringFieldUpdateOperationsInput | string
    action?: EnumAdminActionTypeFieldUpdateOperationsInput | $Enums.AdminActionType
    targetType?: StringFieldUpdateOperationsInput | string
    targetId?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeatureFlagCreateInput = {
    id?: string
    key: string
    name: string
    description?: string | null
    enabled?: boolean
    isMvp?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FeatureFlagUncheckedCreateInput = {
    id?: string
    key: string
    name: string
    description?: string | null
    enabled?: boolean
    isMvp?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FeatureFlagUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    enabled?: BoolFieldUpdateOperationsInput | boolean
    isMvp?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeatureFlagUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    enabled?: BoolFieldUpdateOperationsInput | boolean
    isMvp?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeatureFlagCreateManyInput = {
    id?: string
    key: string
    name: string
    description?: string | null
    enabled?: boolean
    isMvp?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FeatureFlagUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    enabled?: BoolFieldUpdateOperationsInput | boolean
    isMvp?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeatureFlagUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    enabled?: BoolFieldUpdateOperationsInput | boolean
    isMvp?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AiSuggestionCreateInput = {
    id?: string
    type: string
    input?: string | null
    output?: string | null
    confidence?: number | null
    modelVersion?: string | null
    isConclusive?: boolean
    disclaimer?: string | null
    createdAt?: Date | string
    request: ServiceRequestCreateNestedOneWithoutAiSuggestionsInput
  }

  export type AiSuggestionUncheckedCreateInput = {
    id?: string
    requestId: string
    type: string
    input?: string | null
    output?: string | null
    confidence?: number | null
    modelVersion?: string | null
    isConclusive?: boolean
    disclaimer?: string | null
    createdAt?: Date | string
  }

  export type AiSuggestionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    input?: NullableStringFieldUpdateOperationsInput | string | null
    output?: NullableStringFieldUpdateOperationsInput | string | null
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    modelVersion?: NullableStringFieldUpdateOperationsInput | string | null
    isConclusive?: BoolFieldUpdateOperationsInput | boolean
    disclaimer?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    request?: ServiceRequestUpdateOneRequiredWithoutAiSuggestionsNestedInput
  }

  export type AiSuggestionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    requestId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    input?: NullableStringFieldUpdateOperationsInput | string | null
    output?: NullableStringFieldUpdateOperationsInput | string | null
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    modelVersion?: NullableStringFieldUpdateOperationsInput | string | null
    isConclusive?: BoolFieldUpdateOperationsInput | boolean
    disclaimer?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AiSuggestionCreateManyInput = {
    id?: string
    requestId: string
    type: string
    input?: string | null
    output?: string | null
    confidence?: number | null
    modelVersion?: string | null
    isConclusive?: boolean
    disclaimer?: string | null
    createdAt?: Date | string
  }

  export type AiSuggestionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    input?: NullableStringFieldUpdateOperationsInput | string | null
    output?: NullableStringFieldUpdateOperationsInput | string | null
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    modelVersion?: NullableStringFieldUpdateOperationsInput | string | null
    isConclusive?: BoolFieldUpdateOperationsInput | boolean
    disclaimer?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AiSuggestionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    requestId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    input?: NullableStringFieldUpdateOperationsInput | string | null
    output?: NullableStringFieldUpdateOperationsInput | string | null
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    modelVersion?: NullableStringFieldUpdateOperationsInput | string | null
    isConclusive?: BoolFieldUpdateOperationsInput | boolean
    disclaimer?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AiQuoteAnalysisCreateInput = {
    id?: string
    type: string
    input?: string | null
    output?: string | null
    traceability?: string | null
    modelVersion?: string | null
    createdAt?: Date | string
    quote: QuoteCreateNestedOneWithoutAiAnalysisInput
  }

  export type AiQuoteAnalysisUncheckedCreateInput = {
    id?: string
    quoteId: string
    type: string
    input?: string | null
    output?: string | null
    traceability?: string | null
    modelVersion?: string | null
    createdAt?: Date | string
  }

  export type AiQuoteAnalysisUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    input?: NullableStringFieldUpdateOperationsInput | string | null
    output?: NullableStringFieldUpdateOperationsInput | string | null
    traceability?: NullableStringFieldUpdateOperationsInput | string | null
    modelVersion?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quote?: QuoteUpdateOneRequiredWithoutAiAnalysisNestedInput
  }

  export type AiQuoteAnalysisUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    quoteId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    input?: NullableStringFieldUpdateOperationsInput | string | null
    output?: NullableStringFieldUpdateOperationsInput | string | null
    traceability?: NullableStringFieldUpdateOperationsInput | string | null
    modelVersion?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AiQuoteAnalysisCreateManyInput = {
    id?: string
    quoteId: string
    type: string
    input?: string | null
    output?: string | null
    traceability?: string | null
    modelVersion?: string | null
    createdAt?: Date | string
  }

  export type AiQuoteAnalysisUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    input?: NullableStringFieldUpdateOperationsInput | string | null
    output?: NullableStringFieldUpdateOperationsInput | string | null
    traceability?: NullableStringFieldUpdateOperationsInput | string | null
    modelVersion?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AiQuoteAnalysisUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    quoteId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    input?: NullableStringFieldUpdateOperationsInput | string | null
    output?: NullableStringFieldUpdateOperationsInput | string | null
    traceability?: NullableStringFieldUpdateOperationsInput | string | null
    modelVersion?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AppConfigCreateInput = {
    id?: string
    key: string
    value: string
    description?: string | null
    updatedAt?: Date | string
  }

  export type AppConfigUncheckedCreateInput = {
    id?: string
    key: string
    value: string
    description?: string | null
    updatedAt?: Date | string
  }

  export type AppConfigUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AppConfigUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AppConfigCreateManyInput = {
    id?: string
    key: string
    value: string
    description?: string | null
    updatedAt?: Date | string
  }

  export type AppConfigUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AppConfigUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type EnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type EnumNotificationChannelFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationChannel | EnumNotificationChannelFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationChannel[] | ListEnumNotificationChannelFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationChannel[] | ListEnumNotificationChannelFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationChannelFilter<$PrismaModel> | $Enums.NotificationChannel
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type MotorcycleListRelationFilter = {
    every?: MotorcycleWhereInput
    some?: MotorcycleWhereInput
    none?: MotorcycleWhereInput
  }

  export type ServiceRequestListRelationFilter = {
    every?: ServiceRequestWhereInput
    some?: ServiceRequestWhereInput
    none?: ServiceRequestWhereInput
  }

  export type ReviewListRelationFilter = {
    every?: ReviewWhereInput
    some?: ReviewWhereInput
    none?: ReviewWhereInput
  }

  export type IncidentReportListRelationFilter = {
    every?: IncidentReportWhereInput
    some?: IncidentReportWhereInput
    none?: IncidentReportWhereInput
  }

  export type NotificationListRelationFilter = {
    every?: NotificationWhereInput
    some?: NotificationWhereInput
    none?: NotificationWhereInput
  }

  export type ChatMessageListRelationFilter = {
    every?: ChatMessageWhereInput
    some?: ChatMessageWhereInput
    none?: ChatMessageWhereInput
  }

  export type WorkshopNullableScalarRelationFilter = {
    is?: WorkshopWhereInput | null
    isNot?: WorkshopWhereInput | null
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type MotorcycleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ServiceRequestOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ReviewOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type IncidentReportOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NotificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ChatMessageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserProfileCountOrderByAggregateInput = {
    id?: SortOrder
    clerkUserId?: SortOrder
    role?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    name?: SortOrder
    district?: SortOrder
    avatarUrl?: SortOrder
    notifChannel?: SortOrder
    phoneVisible?: SortOrder
    termsAccepted?: SortOrder
    termsVersion?: SortOrder
    termsAcceptedAt?: SortOrder
    privacyAccepted?: SortOrder
    privacyVersion?: SortOrder
    privacyAcceptedAt?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserProfileMaxOrderByAggregateInput = {
    id?: SortOrder
    clerkUserId?: SortOrder
    role?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    name?: SortOrder
    district?: SortOrder
    avatarUrl?: SortOrder
    notifChannel?: SortOrder
    phoneVisible?: SortOrder
    termsAccepted?: SortOrder
    termsVersion?: SortOrder
    termsAcceptedAt?: SortOrder
    privacyAccepted?: SortOrder
    privacyVersion?: SortOrder
    privacyAcceptedAt?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserProfileMinOrderByAggregateInput = {
    id?: SortOrder
    clerkUserId?: SortOrder
    role?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    name?: SortOrder
    district?: SortOrder
    avatarUrl?: SortOrder
    notifChannel?: SortOrder
    phoneVisible?: SortOrder
    termsAccepted?: SortOrder
    termsVersion?: SortOrder
    termsAcceptedAt?: SortOrder
    privacyAccepted?: SortOrder
    privacyVersion?: SortOrder
    privacyAcceptedAt?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type EnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type EnumNotificationChannelWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationChannel | EnumNotificationChannelFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationChannel[] | ListEnumNotificationChannelFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationChannel[] | ListEnumNotificationChannelFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationChannelWithAggregatesFilter<$PrismaModel> | $Enums.NotificationChannel
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationChannelFilter<$PrismaModel>
    _max?: NestedEnumNotificationChannelFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type EnumMotorcycleUseNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.MotorcycleUse | EnumMotorcycleUseFieldRefInput<$PrismaModel> | null
    in?: $Enums.MotorcycleUse[] | ListEnumMotorcycleUseFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.MotorcycleUse[] | ListEnumMotorcycleUseFieldRefInput<$PrismaModel> | null
    not?: NestedEnumMotorcycleUseNullableFilter<$PrismaModel> | $Enums.MotorcycleUse | null
  }

  export type UserProfileScalarRelationFilter = {
    is?: UserProfileWhereInput
    isNot?: UserProfileWhereInput
  }

  export type MotorcycleUserIdBrandModelYearAliasCompoundUniqueInput = {
    userId: string
    brand: string
    model: string
    year: number
    alias: string
  }

  export type MotorcycleCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    brand?: SortOrder
    model?: SortOrder
    year?: SortOrder
    displacement?: SortOrder
    use?: SortOrder
    kmApprox?: SortOrder
    placa?: SortOrder
    alias?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MotorcycleAvgOrderByAggregateInput = {
    year?: SortOrder
    displacement?: SortOrder
    kmApprox?: SortOrder
  }

  export type MotorcycleMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    brand?: SortOrder
    model?: SortOrder
    year?: SortOrder
    displacement?: SortOrder
    use?: SortOrder
    kmApprox?: SortOrder
    placa?: SortOrder
    alias?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MotorcycleMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    brand?: SortOrder
    model?: SortOrder
    year?: SortOrder
    displacement?: SortOrder
    use?: SortOrder
    kmApprox?: SortOrder
    placa?: SortOrder
    alias?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MotorcycleSumOrderByAggregateInput = {
    year?: SortOrder
    displacement?: SortOrder
    kmApprox?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type EnumMotorcycleUseNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MotorcycleUse | EnumMotorcycleUseFieldRefInput<$PrismaModel> | null
    in?: $Enums.MotorcycleUse[] | ListEnumMotorcycleUseFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.MotorcycleUse[] | ListEnumMotorcycleUseFieldRefInput<$PrismaModel> | null
    not?: NestedEnumMotorcycleUseNullableWithAggregatesFilter<$PrismaModel> | $Enums.MotorcycleUse | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumMotorcycleUseNullableFilter<$PrismaModel>
    _max?: NestedEnumMotorcycleUseNullableFilter<$PrismaModel>
  }

  export type CategoryNullableScalarRelationFilter = {
    is?: CategoryWhereInput | null
    isNot?: CategoryWhereInput | null
  }

  export type CategoryListRelationFilter = {
    every?: CategoryWhereInput
    some?: CategoryWhereInput
    none?: CategoryWhereInput
  }

  export type GuideQuestionListRelationFilter = {
    every?: GuideQuestionWhereInput
    some?: GuideQuestionWhereInput
    none?: GuideQuestionWhereInput
  }

  export type WorkshopCategoryListRelationFilter = {
    every?: WorkshopCategoryWhereInput
    some?: WorkshopCategoryWhereInput
    none?: WorkshopCategoryWhereInput
  }

  export type CategoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type GuideQuestionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WorkshopCategoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CategoryCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    parentId?: SortOrder
    version?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CategoryAvgOrderByAggregateInput = {
    version?: SortOrder
  }

  export type CategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    parentId?: SortOrder
    version?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CategoryMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    parentId?: SortOrder
    version?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CategorySumOrderByAggregateInput = {
    version?: SortOrder
  }

  export type CategoryScalarRelationFilter = {
    is?: CategoryWhereInput
    isNot?: CategoryWhereInput
  }

  export type GuideAnswerListRelationFilter = {
    every?: GuideAnswerWhereInput
    some?: GuideAnswerWhereInput
    none?: GuideAnswerWhereInput
  }

  export type GuideAnswerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type GuideQuestionCountOrderByAggregateInput = {
    id?: SortOrder
    categoryId?: SortOrder
    question?: SortOrder
    inputType?: SortOrder
    options?: SortOrder
    order?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type GuideQuestionAvgOrderByAggregateInput = {
    order?: SortOrder
  }

  export type GuideQuestionMaxOrderByAggregateInput = {
    id?: SortOrder
    categoryId?: SortOrder
    question?: SortOrder
    inputType?: SortOrder
    options?: SortOrder
    order?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type GuideQuestionMinOrderByAggregateInput = {
    id?: SortOrder
    categoryId?: SortOrder
    question?: SortOrder
    inputType?: SortOrder
    options?: SortOrder
    order?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type GuideQuestionSumOrderByAggregateInput = {
    order?: SortOrder
  }

  export type GuideQuestionScalarRelationFilter = {
    is?: GuideQuestionWhereInput
    isNot?: GuideQuestionWhereInput
  }

  export type ServiceRequestScalarRelationFilter = {
    is?: ServiceRequestWhereInput
    isNot?: ServiceRequestWhereInput
  }

  export type GuideAnswerCountOrderByAggregateInput = {
    id?: SortOrder
    questionId?: SortOrder
    requestId?: SortOrder
    answer?: SortOrder
    createdAt?: SortOrder
  }

  export type GuideAnswerMaxOrderByAggregateInput = {
    id?: SortOrder
    questionId?: SortOrder
    requestId?: SortOrder
    answer?: SortOrder
    createdAt?: SortOrder
  }

  export type GuideAnswerMinOrderByAggregateInput = {
    id?: SortOrder
    questionId?: SortOrder
    requestId?: SortOrder
    answer?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumUrgencyLevelFilter<$PrismaModel = never> = {
    equals?: $Enums.UrgencyLevel | EnumUrgencyLevelFieldRefInput<$PrismaModel>
    in?: $Enums.UrgencyLevel[] | ListEnumUrgencyLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.UrgencyLevel[] | ListEnumUrgencyLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumUrgencyLevelFilter<$PrismaModel> | $Enums.UrgencyLevel
  }

  export type EnumServiceRequestStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ServiceRequestStatus | EnumServiceRequestStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ServiceRequestStatus[] | ListEnumServiceRequestStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ServiceRequestStatus[] | ListEnumServiceRequestStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumServiceRequestStatusFilter<$PrismaModel> | $Enums.ServiceRequestStatus
  }

  export type MotorcycleScalarRelationFilter = {
    is?: MotorcycleWhereInput
    isNot?: MotorcycleWhereInput
  }

  export type RequestMediaListRelationFilter = {
    every?: RequestMediaWhereInput
    some?: RequestMediaWhereInput
    none?: RequestMediaWhereInput
  }

  export type QuoteListRelationFilter = {
    every?: QuoteWhereInput
    some?: QuoteWhereInput
    none?: QuoteWhereInput
  }

  export type RequestStatusHistoryListRelationFilter = {
    every?: RequestStatusHistoryWhereInput
    some?: RequestStatusHistoryWhereInput
    none?: RequestStatusHistoryWhereInput
  }

  export type WorkOrderNullableScalarRelationFilter = {
    is?: WorkOrderWhereInput | null
    isNot?: WorkOrderWhereInput | null
  }

  export type AiSuggestionListRelationFilter = {
    every?: AiSuggestionWhereInput
    some?: AiSuggestionWhereInput
    none?: AiSuggestionWhereInput
  }

  export type RequestMediaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type QuoteOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RequestStatusHistoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AiSuggestionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ServiceRequestCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    motorcycleId?: SortOrder
    categoryId?: SortOrder
    description?: SortOrder
    district?: SortOrder
    urgency?: SortOrder
    status?: SortOrder
    completionScore?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ServiceRequestAvgOrderByAggregateInput = {
    completionScore?: SortOrder
  }

  export type ServiceRequestMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    motorcycleId?: SortOrder
    categoryId?: SortOrder
    description?: SortOrder
    district?: SortOrder
    urgency?: SortOrder
    status?: SortOrder
    completionScore?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ServiceRequestMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    motorcycleId?: SortOrder
    categoryId?: SortOrder
    description?: SortOrder
    district?: SortOrder
    urgency?: SortOrder
    status?: SortOrder
    completionScore?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ServiceRequestSumOrderByAggregateInput = {
    completionScore?: SortOrder
  }

  export type EnumUrgencyLevelWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UrgencyLevel | EnumUrgencyLevelFieldRefInput<$PrismaModel>
    in?: $Enums.UrgencyLevel[] | ListEnumUrgencyLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.UrgencyLevel[] | ListEnumUrgencyLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumUrgencyLevelWithAggregatesFilter<$PrismaModel> | $Enums.UrgencyLevel
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUrgencyLevelFilter<$PrismaModel>
    _max?: NestedEnumUrgencyLevelFilter<$PrismaModel>
  }

  export type EnumServiceRequestStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ServiceRequestStatus | EnumServiceRequestStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ServiceRequestStatus[] | ListEnumServiceRequestStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ServiceRequestStatus[] | ListEnumServiceRequestStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumServiceRequestStatusWithAggregatesFilter<$PrismaModel> | $Enums.ServiceRequestStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumServiceRequestStatusFilter<$PrismaModel>
    _max?: NestedEnumServiceRequestStatusFilter<$PrismaModel>
  }

  export type EnumMediaTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.MediaType | EnumMediaTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MediaType[] | ListEnumMediaTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MediaType[] | ListEnumMediaTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMediaTypeFilter<$PrismaModel> | $Enums.MediaType
  }

  export type RequestMediaCountOrderByAggregateInput = {
    id?: SortOrder
    requestId?: SortOrder
    url?: SortOrder
    mediaType?: SortOrder
    fileName?: SortOrder
    fileSize?: SortOrder
    createdAt?: SortOrder
  }

  export type RequestMediaAvgOrderByAggregateInput = {
    fileSize?: SortOrder
  }

  export type RequestMediaMaxOrderByAggregateInput = {
    id?: SortOrder
    requestId?: SortOrder
    url?: SortOrder
    mediaType?: SortOrder
    fileName?: SortOrder
    fileSize?: SortOrder
    createdAt?: SortOrder
  }

  export type RequestMediaMinOrderByAggregateInput = {
    id?: SortOrder
    requestId?: SortOrder
    url?: SortOrder
    mediaType?: SortOrder
    fileName?: SortOrder
    fileSize?: SortOrder
    createdAt?: SortOrder
  }

  export type RequestMediaSumOrderByAggregateInput = {
    fileSize?: SortOrder
  }

  export type EnumMediaTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MediaType | EnumMediaTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MediaType[] | ListEnumMediaTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MediaType[] | ListEnumMediaTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMediaTypeWithAggregatesFilter<$PrismaModel> | $Enums.MediaType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMediaTypeFilter<$PrismaModel>
    _max?: NestedEnumMediaTypeFilter<$PrismaModel>
  }

  export type EnumServiceRequestStatusNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.ServiceRequestStatus | EnumServiceRequestStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.ServiceRequestStatus[] | ListEnumServiceRequestStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ServiceRequestStatus[] | ListEnumServiceRequestStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumServiceRequestStatusNullableFilter<$PrismaModel> | $Enums.ServiceRequestStatus | null
  }

  export type RequestStatusHistoryCountOrderByAggregateInput = {
    id?: SortOrder
    requestId?: SortOrder
    fromStatus?: SortOrder
    toStatus?: SortOrder
    actorId?: SortOrder
    reason?: SortOrder
    createdAt?: SortOrder
  }

  export type RequestStatusHistoryMaxOrderByAggregateInput = {
    id?: SortOrder
    requestId?: SortOrder
    fromStatus?: SortOrder
    toStatus?: SortOrder
    actorId?: SortOrder
    reason?: SortOrder
    createdAt?: SortOrder
  }

  export type RequestStatusHistoryMinOrderByAggregateInput = {
    id?: SortOrder
    requestId?: SortOrder
    fromStatus?: SortOrder
    toStatus?: SortOrder
    actorId?: SortOrder
    reason?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumServiceRequestStatusNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ServiceRequestStatus | EnumServiceRequestStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.ServiceRequestStatus[] | ListEnumServiceRequestStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ServiceRequestStatus[] | ListEnumServiceRequestStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumServiceRequestStatusNullableWithAggregatesFilter<$PrismaModel> | $Enums.ServiceRequestStatus | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumServiceRequestStatusNullableFilter<$PrismaModel>
    _max?: NestedEnumServiceRequestStatusNullableFilter<$PrismaModel>
  }

  export type EnumWorkshopStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.WorkshopStatus | EnumWorkshopStatusFieldRefInput<$PrismaModel>
    in?: $Enums.WorkshopStatus[] | ListEnumWorkshopStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.WorkshopStatus[] | ListEnumWorkshopStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumWorkshopStatusFilter<$PrismaModel> | $Enums.WorkshopStatus
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type WorkOrderListRelationFilter = {
    every?: WorkOrderWhereInput
    some?: WorkOrderWhereInput
    none?: WorkOrderWhereInput
  }

  export type WorkshopVerificationListRelationFilter = {
    every?: WorkshopVerificationWhereInput
    some?: WorkshopVerificationWhereInput
    none?: WorkshopVerificationWhereInput
  }

  export type WorkOrderOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WorkshopVerificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WorkshopCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    address?: SortOrder
    district?: SortOrder
    phone?: SortOrder
    ruc?: SortOrder
    description?: SortOrder
    photoUrl?: SortOrder
    status?: SortOrder
    transparencyAccepted?: SortOrder
    guaranteePolicy?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    rating?: SortOrder
    totalServices?: SortOrder
    evidenceRate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WorkshopAvgOrderByAggregateInput = {
    latitude?: SortOrder
    longitude?: SortOrder
    rating?: SortOrder
    totalServices?: SortOrder
    evidenceRate?: SortOrder
  }

  export type WorkshopMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    address?: SortOrder
    district?: SortOrder
    phone?: SortOrder
    ruc?: SortOrder
    description?: SortOrder
    photoUrl?: SortOrder
    status?: SortOrder
    transparencyAccepted?: SortOrder
    guaranteePolicy?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    rating?: SortOrder
    totalServices?: SortOrder
    evidenceRate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WorkshopMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    address?: SortOrder
    district?: SortOrder
    phone?: SortOrder
    ruc?: SortOrder
    description?: SortOrder
    photoUrl?: SortOrder
    status?: SortOrder
    transparencyAccepted?: SortOrder
    guaranteePolicy?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    rating?: SortOrder
    totalServices?: SortOrder
    evidenceRate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WorkshopSumOrderByAggregateInput = {
    latitude?: SortOrder
    longitude?: SortOrder
    rating?: SortOrder
    totalServices?: SortOrder
    evidenceRate?: SortOrder
  }

  export type EnumWorkshopStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.WorkshopStatus | EnumWorkshopStatusFieldRefInput<$PrismaModel>
    in?: $Enums.WorkshopStatus[] | ListEnumWorkshopStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.WorkshopStatus[] | ListEnumWorkshopStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumWorkshopStatusWithAggregatesFilter<$PrismaModel> | $Enums.WorkshopStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumWorkshopStatusFilter<$PrismaModel>
    _max?: NestedEnumWorkshopStatusFilter<$PrismaModel>
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type WorkshopScalarRelationFilter = {
    is?: WorkshopWhereInput
    isNot?: WorkshopWhereInput
  }

  export type WorkshopCategoryWorkshopIdCategoryIdCompoundUniqueInput = {
    workshopId: string
    categoryId: string
  }

  export type WorkshopCategoryCountOrderByAggregateInput = {
    id?: SortOrder
    workshopId?: SortOrder
    categoryId?: SortOrder
  }

  export type WorkshopCategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    workshopId?: SortOrder
    categoryId?: SortOrder
  }

  export type WorkshopCategoryMinOrderByAggregateInput = {
    id?: SortOrder
    workshopId?: SortOrder
    categoryId?: SortOrder
  }

  export type WorkshopVerificationCountOrderByAggregateInput = {
    id?: SortOrder
    workshopId?: SortOrder
    adminId?: SortOrder
    decision?: SortOrder
    reason?: SortOrder
    createdAt?: SortOrder
  }

  export type WorkshopVerificationMaxOrderByAggregateInput = {
    id?: SortOrder
    workshopId?: SortOrder
    adminId?: SortOrder
    decision?: SortOrder
    reason?: SortOrder
    createdAt?: SortOrder
  }

  export type WorkshopVerificationMinOrderByAggregateInput = {
    id?: SortOrder
    workshopId?: SortOrder
    adminId?: SortOrder
    decision?: SortOrder
    reason?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumQuoteStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.QuoteStatus | EnumQuoteStatusFieldRefInput<$PrismaModel>
    in?: $Enums.QuoteStatus[] | ListEnumQuoteStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.QuoteStatus[] | ListEnumQuoteStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumQuoteStatusFilter<$PrismaModel> | $Enums.QuoteStatus
  }

  export type QuotePartItemListRelationFilter = {
    every?: QuotePartItemWhereInput
    some?: QuotePartItemWhereInput
    none?: QuotePartItemWhereInput
  }

  export type AiQuoteAnalysisListRelationFilter = {
    every?: AiQuoteAnalysisWhereInput
    some?: AiQuoteAnalysisWhereInput
    none?: AiQuoteAnalysisWhereInput
  }

  export type QuotePartItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AiQuoteAnalysisOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type QuoteCountOrderByAggregateInput = {
    id?: SortOrder
    requestId?: SortOrder
    workshopId?: SortOrder
    version?: SortOrder
    diagnosis?: SortOrder
    laborCost?: SortOrder
    totalParts?: SortOrder
    totalCost?: SortOrder
    estimatedTime?: SortOrder
    validUntil?: SortOrder
    notes?: SortOrder
    status?: SortOrder
    rejectionReason?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QuoteAvgOrderByAggregateInput = {
    version?: SortOrder
    laborCost?: SortOrder
    totalParts?: SortOrder
    totalCost?: SortOrder
  }

  export type QuoteMaxOrderByAggregateInput = {
    id?: SortOrder
    requestId?: SortOrder
    workshopId?: SortOrder
    version?: SortOrder
    diagnosis?: SortOrder
    laborCost?: SortOrder
    totalParts?: SortOrder
    totalCost?: SortOrder
    estimatedTime?: SortOrder
    validUntil?: SortOrder
    notes?: SortOrder
    status?: SortOrder
    rejectionReason?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QuoteMinOrderByAggregateInput = {
    id?: SortOrder
    requestId?: SortOrder
    workshopId?: SortOrder
    version?: SortOrder
    diagnosis?: SortOrder
    laborCost?: SortOrder
    totalParts?: SortOrder
    totalCost?: SortOrder
    estimatedTime?: SortOrder
    validUntil?: SortOrder
    notes?: SortOrder
    status?: SortOrder
    rejectionReason?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QuoteSumOrderByAggregateInput = {
    version?: SortOrder
    laborCost?: SortOrder
    totalParts?: SortOrder
    totalCost?: SortOrder
  }

  export type EnumQuoteStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.QuoteStatus | EnumQuoteStatusFieldRefInput<$PrismaModel>
    in?: $Enums.QuoteStatus[] | ListEnumQuoteStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.QuoteStatus[] | ListEnumQuoteStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumQuoteStatusWithAggregatesFilter<$PrismaModel> | $Enums.QuoteStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumQuoteStatusFilter<$PrismaModel>
    _max?: NestedEnumQuoteStatusFilter<$PrismaModel>
  }

  export type EnumPartTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.PartType | EnumPartTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PartType[] | ListEnumPartTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PartType[] | ListEnumPartTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPartTypeFilter<$PrismaModel> | $Enums.PartType
  }

  export type EnumPartTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.PartType | EnumPartTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.PartType[] | ListEnumPartTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.PartType[] | ListEnumPartTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPartTypeNullableFilter<$PrismaModel> | $Enums.PartType | null
  }

  export type QuoteScalarRelationFilter = {
    is?: QuoteWhereInput
    isNot?: QuoteWhereInput
  }

  export type QuotePartItemCountOrderByAggregateInput = {
    id?: SortOrder
    quoteId?: SortOrder
    name?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    partType?: SortOrder
    notes?: SortOrder
    alternativeName?: SortOrder
    alternativePrice?: SortOrder
    alternativeType?: SortOrder
    alternativeNotes?: SortOrder
    selectedAlternative?: SortOrder
    createdAt?: SortOrder
  }

  export type QuotePartItemAvgOrderByAggregateInput = {
    quantity?: SortOrder
    unitPrice?: SortOrder
    alternativePrice?: SortOrder
  }

  export type QuotePartItemMaxOrderByAggregateInput = {
    id?: SortOrder
    quoteId?: SortOrder
    name?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    partType?: SortOrder
    notes?: SortOrder
    alternativeName?: SortOrder
    alternativePrice?: SortOrder
    alternativeType?: SortOrder
    alternativeNotes?: SortOrder
    selectedAlternative?: SortOrder
    createdAt?: SortOrder
  }

  export type QuotePartItemMinOrderByAggregateInput = {
    id?: SortOrder
    quoteId?: SortOrder
    name?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    partType?: SortOrder
    notes?: SortOrder
    alternativeName?: SortOrder
    alternativePrice?: SortOrder
    alternativeType?: SortOrder
    alternativeNotes?: SortOrder
    selectedAlternative?: SortOrder
    createdAt?: SortOrder
  }

  export type QuotePartItemSumOrderByAggregateInput = {
    quantity?: SortOrder
    unitPrice?: SortOrder
    alternativePrice?: SortOrder
  }

  export type EnumPartTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PartType | EnumPartTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PartType[] | ListEnumPartTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PartType[] | ListEnumPartTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPartTypeWithAggregatesFilter<$PrismaModel> | $Enums.PartType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPartTypeFilter<$PrismaModel>
    _max?: NestedEnumPartTypeFilter<$PrismaModel>
  }

  export type EnumPartTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PartType | EnumPartTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.PartType[] | ListEnumPartTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.PartType[] | ListEnumPartTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPartTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.PartType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumPartTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumPartTypeNullableFilter<$PrismaModel>
  }

  export type EnumWorkOrderStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.WorkOrderStatus | EnumWorkOrderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.WorkOrderStatus[] | ListEnumWorkOrderStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.WorkOrderStatus[] | ListEnumWorkOrderStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumWorkOrderStatusFilter<$PrismaModel> | $Enums.WorkOrderStatus
  }

  export type ChangeRequestListRelationFilter = {
    every?: ChangeRequestWhereInput
    some?: ChangeRequestWhereInput
    none?: ChangeRequestWhereInput
  }

  export type EvidenceListRelationFilter = {
    every?: EvidenceWhereInput
    some?: EvidenceWhereInput
    none?: EvidenceWhereInput
  }

  export type ReviewNullableScalarRelationFilter = {
    is?: ReviewWhereInput | null
    isNot?: ReviewWhereInput | null
  }

  export type ReceiptNullableScalarRelationFilter = {
    is?: ReceiptWhereInput | null
    isNot?: ReceiptWhereInput | null
  }

  export type ChangeRequestOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EvidenceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WorkOrderCountOrderByAggregateInput = {
    id?: SortOrder
    orderNumber?: SortOrder
    requestId?: SortOrder
    quoteId?: SortOrder
    workshopId?: SortOrder
    diagnosis?: SortOrder
    totalAgreed?: SortOrder
    totalFinal?: SortOrder
    status?: SortOrder
    userAcceptedAt?: SortOrder
    workshopAcceptedAt?: SortOrder
    startedAt?: SortOrder
    startNote?: SortOrder
    completedAt?: SortOrder
    closedAt?: SortOrder
    closureChecklist?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WorkOrderAvgOrderByAggregateInput = {
    totalAgreed?: SortOrder
    totalFinal?: SortOrder
  }

  export type WorkOrderMaxOrderByAggregateInput = {
    id?: SortOrder
    orderNumber?: SortOrder
    requestId?: SortOrder
    quoteId?: SortOrder
    workshopId?: SortOrder
    diagnosis?: SortOrder
    totalAgreed?: SortOrder
    totalFinal?: SortOrder
    status?: SortOrder
    userAcceptedAt?: SortOrder
    workshopAcceptedAt?: SortOrder
    startedAt?: SortOrder
    startNote?: SortOrder
    completedAt?: SortOrder
    closedAt?: SortOrder
    closureChecklist?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WorkOrderMinOrderByAggregateInput = {
    id?: SortOrder
    orderNumber?: SortOrder
    requestId?: SortOrder
    quoteId?: SortOrder
    workshopId?: SortOrder
    diagnosis?: SortOrder
    totalAgreed?: SortOrder
    totalFinal?: SortOrder
    status?: SortOrder
    userAcceptedAt?: SortOrder
    workshopAcceptedAt?: SortOrder
    startedAt?: SortOrder
    startNote?: SortOrder
    completedAt?: SortOrder
    closedAt?: SortOrder
    closureChecklist?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WorkOrderSumOrderByAggregateInput = {
    totalAgreed?: SortOrder
    totalFinal?: SortOrder
  }

  export type EnumWorkOrderStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.WorkOrderStatus | EnumWorkOrderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.WorkOrderStatus[] | ListEnumWorkOrderStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.WorkOrderStatus[] | ListEnumWorkOrderStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumWorkOrderStatusWithAggregatesFilter<$PrismaModel> | $Enums.WorkOrderStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumWorkOrderStatusFilter<$PrismaModel>
    _max?: NestedEnumWorkOrderStatusFilter<$PrismaModel>
  }

  export type EnumChangeRequestStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ChangeRequestStatus | EnumChangeRequestStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ChangeRequestStatus[] | ListEnumChangeRequestStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ChangeRequestStatus[] | ListEnumChangeRequestStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumChangeRequestStatusFilter<$PrismaModel> | $Enums.ChangeRequestStatus
  }

  export type WorkOrderScalarRelationFilter = {
    is?: WorkOrderWhereInput
    isNot?: WorkOrderWhereInput
  }

  export type ChangeRequestCountOrderByAggregateInput = {
    id?: SortOrder
    workOrderId?: SortOrder
    description?: SortOrder
    justification?: SortOrder
    additionalCost?: SortOrder
    additionalTime?: SortOrder
    status?: SortOrder
    decidedAt?: SortOrder
    decidedBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ChangeRequestAvgOrderByAggregateInput = {
    additionalCost?: SortOrder
  }

  export type ChangeRequestMaxOrderByAggregateInput = {
    id?: SortOrder
    workOrderId?: SortOrder
    description?: SortOrder
    justification?: SortOrder
    additionalCost?: SortOrder
    additionalTime?: SortOrder
    status?: SortOrder
    decidedAt?: SortOrder
    decidedBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ChangeRequestMinOrderByAggregateInput = {
    id?: SortOrder
    workOrderId?: SortOrder
    description?: SortOrder
    justification?: SortOrder
    additionalCost?: SortOrder
    additionalTime?: SortOrder
    status?: SortOrder
    decidedAt?: SortOrder
    decidedBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ChangeRequestSumOrderByAggregateInput = {
    additionalCost?: SortOrder
  }

  export type EnumChangeRequestStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ChangeRequestStatus | EnumChangeRequestStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ChangeRequestStatus[] | ListEnumChangeRequestStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ChangeRequestStatus[] | ListEnumChangeRequestStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumChangeRequestStatusWithAggregatesFilter<$PrismaModel> | $Enums.ChangeRequestStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumChangeRequestStatusFilter<$PrismaModel>
    _max?: NestedEnumChangeRequestStatusFilter<$PrismaModel>
  }

  export type EnumEvidenceStageFilter<$PrismaModel = never> = {
    equals?: $Enums.EvidenceStage | EnumEvidenceStageFieldRefInput<$PrismaModel>
    in?: $Enums.EvidenceStage[] | ListEnumEvidenceStageFieldRefInput<$PrismaModel>
    notIn?: $Enums.EvidenceStage[] | ListEnumEvidenceStageFieldRefInput<$PrismaModel>
    not?: NestedEnumEvidenceStageFilter<$PrismaModel> | $Enums.EvidenceStage
  }

  export type EvidenceCountOrderByAggregateInput = {
    id?: SortOrder
    workOrderId?: SortOrder
    stage?: SortOrder
    url?: SortOrder
    mediaType?: SortOrder
    fileName?: SortOrder
    description?: SortOrder
    flagged?: SortOrder
    createdAt?: SortOrder
  }

  export type EvidenceMaxOrderByAggregateInput = {
    id?: SortOrder
    workOrderId?: SortOrder
    stage?: SortOrder
    url?: SortOrder
    mediaType?: SortOrder
    fileName?: SortOrder
    description?: SortOrder
    flagged?: SortOrder
    createdAt?: SortOrder
  }

  export type EvidenceMinOrderByAggregateInput = {
    id?: SortOrder
    workOrderId?: SortOrder
    stage?: SortOrder
    url?: SortOrder
    mediaType?: SortOrder
    fileName?: SortOrder
    description?: SortOrder
    flagged?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumEvidenceStageWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EvidenceStage | EnumEvidenceStageFieldRefInput<$PrismaModel>
    in?: $Enums.EvidenceStage[] | ListEnumEvidenceStageFieldRefInput<$PrismaModel>
    notIn?: $Enums.EvidenceStage[] | ListEnumEvidenceStageFieldRefInput<$PrismaModel>
    not?: NestedEnumEvidenceStageWithAggregatesFilter<$PrismaModel> | $Enums.EvidenceStage
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEvidenceStageFilter<$PrismaModel>
    _max?: NestedEnumEvidenceStageFilter<$PrismaModel>
  }

  export type ReviewCountOrderByAggregateInput = {
    id?: SortOrder
    workOrderId?: SortOrder
    workshopId?: SortOrder
    userId?: SortOrder
    rating?: SortOrder
    comment?: SortOrder
    editableUntil?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReviewAvgOrderByAggregateInput = {
    rating?: SortOrder
  }

  export type ReviewMaxOrderByAggregateInput = {
    id?: SortOrder
    workOrderId?: SortOrder
    workshopId?: SortOrder
    userId?: SortOrder
    rating?: SortOrder
    comment?: SortOrder
    editableUntil?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReviewMinOrderByAggregateInput = {
    id?: SortOrder
    workOrderId?: SortOrder
    workshopId?: SortOrder
    userId?: SortOrder
    rating?: SortOrder
    comment?: SortOrder
    editableUntil?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReviewSumOrderByAggregateInput = {
    rating?: SortOrder
  }

  export type ReceiptCountOrderByAggregateInput = {
    id?: SortOrder
    workOrderId?: SortOrder
    totalOriginal?: SortOrder
    totalChanges?: SortOrder
    totalFinal?: SortOrder
    pdfUrl?: SortOrder
    createdAt?: SortOrder
  }

  export type ReceiptAvgOrderByAggregateInput = {
    totalOriginal?: SortOrder
    totalChanges?: SortOrder
    totalFinal?: SortOrder
  }

  export type ReceiptMaxOrderByAggregateInput = {
    id?: SortOrder
    workOrderId?: SortOrder
    totalOriginal?: SortOrder
    totalChanges?: SortOrder
    totalFinal?: SortOrder
    pdfUrl?: SortOrder
    createdAt?: SortOrder
  }

  export type ReceiptMinOrderByAggregateInput = {
    id?: SortOrder
    workOrderId?: SortOrder
    totalOriginal?: SortOrder
    totalChanges?: SortOrder
    totalFinal?: SortOrder
    pdfUrl?: SortOrder
    createdAt?: SortOrder
  }

  export type ReceiptSumOrderByAggregateInput = {
    totalOriginal?: SortOrder
    totalChanges?: SortOrder
    totalFinal?: SortOrder
  }

  export type EnumIncidentTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.IncidentType | EnumIncidentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.IncidentType[] | ListEnumIncidentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.IncidentType[] | ListEnumIncidentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumIncidentTypeFilter<$PrismaModel> | $Enums.IncidentType
  }

  export type EnumIncidentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.IncidentStatus | EnumIncidentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.IncidentStatus[] | ListEnumIncidentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.IncidentStatus[] | ListEnumIncidentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumIncidentStatusFilter<$PrismaModel> | $Enums.IncidentStatus
  }

  export type IncidentReportCountOrderByAggregateInput = {
    id?: SortOrder
    reporterId?: SortOrder
    workshopId?: SortOrder
    type?: SortOrder
    description?: SortOrder
    evidenceUrl?: SortOrder
    status?: SortOrder
    resolution?: SortOrder
    resolvedAt?: SortOrder
    resolvedBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IncidentReportMaxOrderByAggregateInput = {
    id?: SortOrder
    reporterId?: SortOrder
    workshopId?: SortOrder
    type?: SortOrder
    description?: SortOrder
    evidenceUrl?: SortOrder
    status?: SortOrder
    resolution?: SortOrder
    resolvedAt?: SortOrder
    resolvedBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IncidentReportMinOrderByAggregateInput = {
    id?: SortOrder
    reporterId?: SortOrder
    workshopId?: SortOrder
    type?: SortOrder
    description?: SortOrder
    evidenceUrl?: SortOrder
    status?: SortOrder
    resolution?: SortOrder
    resolvedAt?: SortOrder
    resolvedBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumIncidentTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.IncidentType | EnumIncidentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.IncidentType[] | ListEnumIncidentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.IncidentType[] | ListEnumIncidentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumIncidentTypeWithAggregatesFilter<$PrismaModel> | $Enums.IncidentType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumIncidentTypeFilter<$PrismaModel>
    _max?: NestedEnumIncidentTypeFilter<$PrismaModel>
  }

  export type EnumIncidentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.IncidentStatus | EnumIncidentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.IncidentStatus[] | ListEnumIncidentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.IncidentStatus[] | ListEnumIncidentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumIncidentStatusWithAggregatesFilter<$PrismaModel> | $Enums.IncidentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumIncidentStatusFilter<$PrismaModel>
    _max?: NestedEnumIncidentStatusFilter<$PrismaModel>
  }

  export type ChatMessageCountOrderByAggregateInput = {
    id?: SortOrder
    requestId?: SortOrder
    senderId?: SortOrder
    content?: SortOrder
    imageUrl?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
  }

  export type ChatMessageMaxOrderByAggregateInput = {
    id?: SortOrder
    requestId?: SortOrder
    senderId?: SortOrder
    content?: SortOrder
    imageUrl?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
  }

  export type ChatMessageMinOrderByAggregateInput = {
    id?: SortOrder
    requestId?: SortOrder
    senderId?: SortOrder
    content?: SortOrder
    imageUrl?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
  }

  export type ServiceRequestNullableScalarRelationFilter = {
    is?: ServiceRequestWhereInput | null
    isNot?: ServiceRequestWhereInput | null
  }

  export type NotificationCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    requestId?: SortOrder
    title?: SortOrder
    body?: SortOrder
    channel?: SortOrder
    isRead?: SortOrder
    link?: SortOrder
    createdAt?: SortOrder
  }

  export type NotificationMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    requestId?: SortOrder
    title?: SortOrder
    body?: SortOrder
    channel?: SortOrder
    isRead?: SortOrder
    link?: SortOrder
    createdAt?: SortOrder
  }

  export type NotificationMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    requestId?: SortOrder
    title?: SortOrder
    body?: SortOrder
    channel?: SortOrder
    isRead?: SortOrder
    link?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumAdminActionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AdminActionType | EnumAdminActionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AdminActionType[] | ListEnumAdminActionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AdminActionType[] | ListEnumAdminActionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAdminActionTypeFilter<$PrismaModel> | $Enums.AdminActionType
  }

  export type AuditLogCountOrderByAggregateInput = {
    id?: SortOrder
    actorId?: SortOrder
    action?: SortOrder
    targetType?: SortOrder
    targetId?: SortOrder
    reason?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditLogMaxOrderByAggregateInput = {
    id?: SortOrder
    actorId?: SortOrder
    action?: SortOrder
    targetType?: SortOrder
    targetId?: SortOrder
    reason?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditLogMinOrderByAggregateInput = {
    id?: SortOrder
    actorId?: SortOrder
    action?: SortOrder
    targetType?: SortOrder
    targetId?: SortOrder
    reason?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumAdminActionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AdminActionType | EnumAdminActionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AdminActionType[] | ListEnumAdminActionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AdminActionType[] | ListEnumAdminActionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAdminActionTypeWithAggregatesFilter<$PrismaModel> | $Enums.AdminActionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAdminActionTypeFilter<$PrismaModel>
    _max?: NestedEnumAdminActionTypeFilter<$PrismaModel>
  }

  export type FeatureFlagCountOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    name?: SortOrder
    description?: SortOrder
    enabled?: SortOrder
    isMvp?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FeatureFlagMaxOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    name?: SortOrder
    description?: SortOrder
    enabled?: SortOrder
    isMvp?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FeatureFlagMinOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    name?: SortOrder
    description?: SortOrder
    enabled?: SortOrder
    isMvp?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AiSuggestionCountOrderByAggregateInput = {
    id?: SortOrder
    requestId?: SortOrder
    type?: SortOrder
    input?: SortOrder
    output?: SortOrder
    confidence?: SortOrder
    modelVersion?: SortOrder
    isConclusive?: SortOrder
    disclaimer?: SortOrder
    createdAt?: SortOrder
  }

  export type AiSuggestionAvgOrderByAggregateInput = {
    confidence?: SortOrder
  }

  export type AiSuggestionMaxOrderByAggregateInput = {
    id?: SortOrder
    requestId?: SortOrder
    type?: SortOrder
    input?: SortOrder
    output?: SortOrder
    confidence?: SortOrder
    modelVersion?: SortOrder
    isConclusive?: SortOrder
    disclaimer?: SortOrder
    createdAt?: SortOrder
  }

  export type AiSuggestionMinOrderByAggregateInput = {
    id?: SortOrder
    requestId?: SortOrder
    type?: SortOrder
    input?: SortOrder
    output?: SortOrder
    confidence?: SortOrder
    modelVersion?: SortOrder
    isConclusive?: SortOrder
    disclaimer?: SortOrder
    createdAt?: SortOrder
  }

  export type AiSuggestionSumOrderByAggregateInput = {
    confidence?: SortOrder
  }

  export type AiQuoteAnalysisCountOrderByAggregateInput = {
    id?: SortOrder
    quoteId?: SortOrder
    type?: SortOrder
    input?: SortOrder
    output?: SortOrder
    traceability?: SortOrder
    modelVersion?: SortOrder
    createdAt?: SortOrder
  }

  export type AiQuoteAnalysisMaxOrderByAggregateInput = {
    id?: SortOrder
    quoteId?: SortOrder
    type?: SortOrder
    input?: SortOrder
    output?: SortOrder
    traceability?: SortOrder
    modelVersion?: SortOrder
    createdAt?: SortOrder
  }

  export type AiQuoteAnalysisMinOrderByAggregateInput = {
    id?: SortOrder
    quoteId?: SortOrder
    type?: SortOrder
    input?: SortOrder
    output?: SortOrder
    traceability?: SortOrder
    modelVersion?: SortOrder
    createdAt?: SortOrder
  }

  export type AppConfigCountOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    description?: SortOrder
    updatedAt?: SortOrder
  }

  export type AppConfigMaxOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    description?: SortOrder
    updatedAt?: SortOrder
  }

  export type AppConfigMinOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    description?: SortOrder
    updatedAt?: SortOrder
  }

  export type MotorcycleCreateNestedManyWithoutUserInput = {
    create?: XOR<MotorcycleCreateWithoutUserInput, MotorcycleUncheckedCreateWithoutUserInput> | MotorcycleCreateWithoutUserInput[] | MotorcycleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MotorcycleCreateOrConnectWithoutUserInput | MotorcycleCreateOrConnectWithoutUserInput[]
    createMany?: MotorcycleCreateManyUserInputEnvelope
    connect?: MotorcycleWhereUniqueInput | MotorcycleWhereUniqueInput[]
  }

  export type ServiceRequestCreateNestedManyWithoutUserInput = {
    create?: XOR<ServiceRequestCreateWithoutUserInput, ServiceRequestUncheckedCreateWithoutUserInput> | ServiceRequestCreateWithoutUserInput[] | ServiceRequestUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ServiceRequestCreateOrConnectWithoutUserInput | ServiceRequestCreateOrConnectWithoutUserInput[]
    createMany?: ServiceRequestCreateManyUserInputEnvelope
    connect?: ServiceRequestWhereUniqueInput | ServiceRequestWhereUniqueInput[]
  }

  export type ReviewCreateNestedManyWithoutUserInput = {
    create?: XOR<ReviewCreateWithoutUserInput, ReviewUncheckedCreateWithoutUserInput> | ReviewCreateWithoutUserInput[] | ReviewUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutUserInput | ReviewCreateOrConnectWithoutUserInput[]
    createMany?: ReviewCreateManyUserInputEnvelope
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
  }

  export type IncidentReportCreateNestedManyWithoutReporterInput = {
    create?: XOR<IncidentReportCreateWithoutReporterInput, IncidentReportUncheckedCreateWithoutReporterInput> | IncidentReportCreateWithoutReporterInput[] | IncidentReportUncheckedCreateWithoutReporterInput[]
    connectOrCreate?: IncidentReportCreateOrConnectWithoutReporterInput | IncidentReportCreateOrConnectWithoutReporterInput[]
    createMany?: IncidentReportCreateManyReporterInputEnvelope
    connect?: IncidentReportWhereUniqueInput | IncidentReportWhereUniqueInput[]
  }

  export type NotificationCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type ChatMessageCreateNestedManyWithoutSenderInput = {
    create?: XOR<ChatMessageCreateWithoutSenderInput, ChatMessageUncheckedCreateWithoutSenderInput> | ChatMessageCreateWithoutSenderInput[] | ChatMessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: ChatMessageCreateOrConnectWithoutSenderInput | ChatMessageCreateOrConnectWithoutSenderInput[]
    createMany?: ChatMessageCreateManySenderInputEnvelope
    connect?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
  }

  export type WorkshopCreateNestedOneWithoutUserInput = {
    create?: XOR<WorkshopCreateWithoutUserInput, WorkshopUncheckedCreateWithoutUserInput>
    connectOrCreate?: WorkshopCreateOrConnectWithoutUserInput
    connect?: WorkshopWhereUniqueInput
  }

  export type MotorcycleUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<MotorcycleCreateWithoutUserInput, MotorcycleUncheckedCreateWithoutUserInput> | MotorcycleCreateWithoutUserInput[] | MotorcycleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MotorcycleCreateOrConnectWithoutUserInput | MotorcycleCreateOrConnectWithoutUserInput[]
    createMany?: MotorcycleCreateManyUserInputEnvelope
    connect?: MotorcycleWhereUniqueInput | MotorcycleWhereUniqueInput[]
  }

  export type ServiceRequestUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ServiceRequestCreateWithoutUserInput, ServiceRequestUncheckedCreateWithoutUserInput> | ServiceRequestCreateWithoutUserInput[] | ServiceRequestUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ServiceRequestCreateOrConnectWithoutUserInput | ServiceRequestCreateOrConnectWithoutUserInput[]
    createMany?: ServiceRequestCreateManyUserInputEnvelope
    connect?: ServiceRequestWhereUniqueInput | ServiceRequestWhereUniqueInput[]
  }

  export type ReviewUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ReviewCreateWithoutUserInput, ReviewUncheckedCreateWithoutUserInput> | ReviewCreateWithoutUserInput[] | ReviewUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutUserInput | ReviewCreateOrConnectWithoutUserInput[]
    createMany?: ReviewCreateManyUserInputEnvelope
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
  }

  export type IncidentReportUncheckedCreateNestedManyWithoutReporterInput = {
    create?: XOR<IncidentReportCreateWithoutReporterInput, IncidentReportUncheckedCreateWithoutReporterInput> | IncidentReportCreateWithoutReporterInput[] | IncidentReportUncheckedCreateWithoutReporterInput[]
    connectOrCreate?: IncidentReportCreateOrConnectWithoutReporterInput | IncidentReportCreateOrConnectWithoutReporterInput[]
    createMany?: IncidentReportCreateManyReporterInputEnvelope
    connect?: IncidentReportWhereUniqueInput | IncidentReportWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type ChatMessageUncheckedCreateNestedManyWithoutSenderInput = {
    create?: XOR<ChatMessageCreateWithoutSenderInput, ChatMessageUncheckedCreateWithoutSenderInput> | ChatMessageCreateWithoutSenderInput[] | ChatMessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: ChatMessageCreateOrConnectWithoutSenderInput | ChatMessageCreateOrConnectWithoutSenderInput[]
    createMany?: ChatMessageCreateManySenderInputEnvelope
    connect?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
  }

  export type WorkshopUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<WorkshopCreateWithoutUserInput, WorkshopUncheckedCreateWithoutUserInput>
    connectOrCreate?: WorkshopCreateOrConnectWithoutUserInput
    connect?: WorkshopWhereUniqueInput
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type EnumUserRoleFieldUpdateOperationsInput = {
    set?: $Enums.UserRole
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type EnumNotificationChannelFieldUpdateOperationsInput = {
    set?: $Enums.NotificationChannel
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type MotorcycleUpdateManyWithoutUserNestedInput = {
    create?: XOR<MotorcycleCreateWithoutUserInput, MotorcycleUncheckedCreateWithoutUserInput> | MotorcycleCreateWithoutUserInput[] | MotorcycleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MotorcycleCreateOrConnectWithoutUserInput | MotorcycleCreateOrConnectWithoutUserInput[]
    upsert?: MotorcycleUpsertWithWhereUniqueWithoutUserInput | MotorcycleUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: MotorcycleCreateManyUserInputEnvelope
    set?: MotorcycleWhereUniqueInput | MotorcycleWhereUniqueInput[]
    disconnect?: MotorcycleWhereUniqueInput | MotorcycleWhereUniqueInput[]
    delete?: MotorcycleWhereUniqueInput | MotorcycleWhereUniqueInput[]
    connect?: MotorcycleWhereUniqueInput | MotorcycleWhereUniqueInput[]
    update?: MotorcycleUpdateWithWhereUniqueWithoutUserInput | MotorcycleUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: MotorcycleUpdateManyWithWhereWithoutUserInput | MotorcycleUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: MotorcycleScalarWhereInput | MotorcycleScalarWhereInput[]
  }

  export type ServiceRequestUpdateManyWithoutUserNestedInput = {
    create?: XOR<ServiceRequestCreateWithoutUserInput, ServiceRequestUncheckedCreateWithoutUserInput> | ServiceRequestCreateWithoutUserInput[] | ServiceRequestUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ServiceRequestCreateOrConnectWithoutUserInput | ServiceRequestCreateOrConnectWithoutUserInput[]
    upsert?: ServiceRequestUpsertWithWhereUniqueWithoutUserInput | ServiceRequestUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ServiceRequestCreateManyUserInputEnvelope
    set?: ServiceRequestWhereUniqueInput | ServiceRequestWhereUniqueInput[]
    disconnect?: ServiceRequestWhereUniqueInput | ServiceRequestWhereUniqueInput[]
    delete?: ServiceRequestWhereUniqueInput | ServiceRequestWhereUniqueInput[]
    connect?: ServiceRequestWhereUniqueInput | ServiceRequestWhereUniqueInput[]
    update?: ServiceRequestUpdateWithWhereUniqueWithoutUserInput | ServiceRequestUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ServiceRequestUpdateManyWithWhereWithoutUserInput | ServiceRequestUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ServiceRequestScalarWhereInput | ServiceRequestScalarWhereInput[]
  }

  export type ReviewUpdateManyWithoutUserNestedInput = {
    create?: XOR<ReviewCreateWithoutUserInput, ReviewUncheckedCreateWithoutUserInput> | ReviewCreateWithoutUserInput[] | ReviewUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutUserInput | ReviewCreateOrConnectWithoutUserInput[]
    upsert?: ReviewUpsertWithWhereUniqueWithoutUserInput | ReviewUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ReviewCreateManyUserInputEnvelope
    set?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    disconnect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    delete?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    update?: ReviewUpdateWithWhereUniqueWithoutUserInput | ReviewUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ReviewUpdateManyWithWhereWithoutUserInput | ReviewUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
  }

  export type IncidentReportUpdateManyWithoutReporterNestedInput = {
    create?: XOR<IncidentReportCreateWithoutReporterInput, IncidentReportUncheckedCreateWithoutReporterInput> | IncidentReportCreateWithoutReporterInput[] | IncidentReportUncheckedCreateWithoutReporterInput[]
    connectOrCreate?: IncidentReportCreateOrConnectWithoutReporterInput | IncidentReportCreateOrConnectWithoutReporterInput[]
    upsert?: IncidentReportUpsertWithWhereUniqueWithoutReporterInput | IncidentReportUpsertWithWhereUniqueWithoutReporterInput[]
    createMany?: IncidentReportCreateManyReporterInputEnvelope
    set?: IncidentReportWhereUniqueInput | IncidentReportWhereUniqueInput[]
    disconnect?: IncidentReportWhereUniqueInput | IncidentReportWhereUniqueInput[]
    delete?: IncidentReportWhereUniqueInput | IncidentReportWhereUniqueInput[]
    connect?: IncidentReportWhereUniqueInput | IncidentReportWhereUniqueInput[]
    update?: IncidentReportUpdateWithWhereUniqueWithoutReporterInput | IncidentReportUpdateWithWhereUniqueWithoutReporterInput[]
    updateMany?: IncidentReportUpdateManyWithWhereWithoutReporterInput | IncidentReportUpdateManyWithWhereWithoutReporterInput[]
    deleteMany?: IncidentReportScalarWhereInput | IncidentReportScalarWhereInput[]
  }

  export type NotificationUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type ChatMessageUpdateManyWithoutSenderNestedInput = {
    create?: XOR<ChatMessageCreateWithoutSenderInput, ChatMessageUncheckedCreateWithoutSenderInput> | ChatMessageCreateWithoutSenderInput[] | ChatMessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: ChatMessageCreateOrConnectWithoutSenderInput | ChatMessageCreateOrConnectWithoutSenderInput[]
    upsert?: ChatMessageUpsertWithWhereUniqueWithoutSenderInput | ChatMessageUpsertWithWhereUniqueWithoutSenderInput[]
    createMany?: ChatMessageCreateManySenderInputEnvelope
    set?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    disconnect?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    delete?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    connect?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    update?: ChatMessageUpdateWithWhereUniqueWithoutSenderInput | ChatMessageUpdateWithWhereUniqueWithoutSenderInput[]
    updateMany?: ChatMessageUpdateManyWithWhereWithoutSenderInput | ChatMessageUpdateManyWithWhereWithoutSenderInput[]
    deleteMany?: ChatMessageScalarWhereInput | ChatMessageScalarWhereInput[]
  }

  export type WorkshopUpdateOneWithoutUserNestedInput = {
    create?: XOR<WorkshopCreateWithoutUserInput, WorkshopUncheckedCreateWithoutUserInput>
    connectOrCreate?: WorkshopCreateOrConnectWithoutUserInput
    upsert?: WorkshopUpsertWithoutUserInput
    disconnect?: WorkshopWhereInput | boolean
    delete?: WorkshopWhereInput | boolean
    connect?: WorkshopWhereUniqueInput
    update?: XOR<XOR<WorkshopUpdateToOneWithWhereWithoutUserInput, WorkshopUpdateWithoutUserInput>, WorkshopUncheckedUpdateWithoutUserInput>
  }

  export type MotorcycleUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<MotorcycleCreateWithoutUserInput, MotorcycleUncheckedCreateWithoutUserInput> | MotorcycleCreateWithoutUserInput[] | MotorcycleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MotorcycleCreateOrConnectWithoutUserInput | MotorcycleCreateOrConnectWithoutUserInput[]
    upsert?: MotorcycleUpsertWithWhereUniqueWithoutUserInput | MotorcycleUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: MotorcycleCreateManyUserInputEnvelope
    set?: MotorcycleWhereUniqueInput | MotorcycleWhereUniqueInput[]
    disconnect?: MotorcycleWhereUniqueInput | MotorcycleWhereUniqueInput[]
    delete?: MotorcycleWhereUniqueInput | MotorcycleWhereUniqueInput[]
    connect?: MotorcycleWhereUniqueInput | MotorcycleWhereUniqueInput[]
    update?: MotorcycleUpdateWithWhereUniqueWithoutUserInput | MotorcycleUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: MotorcycleUpdateManyWithWhereWithoutUserInput | MotorcycleUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: MotorcycleScalarWhereInput | MotorcycleScalarWhereInput[]
  }

  export type ServiceRequestUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ServiceRequestCreateWithoutUserInput, ServiceRequestUncheckedCreateWithoutUserInput> | ServiceRequestCreateWithoutUserInput[] | ServiceRequestUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ServiceRequestCreateOrConnectWithoutUserInput | ServiceRequestCreateOrConnectWithoutUserInput[]
    upsert?: ServiceRequestUpsertWithWhereUniqueWithoutUserInput | ServiceRequestUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ServiceRequestCreateManyUserInputEnvelope
    set?: ServiceRequestWhereUniqueInput | ServiceRequestWhereUniqueInput[]
    disconnect?: ServiceRequestWhereUniqueInput | ServiceRequestWhereUniqueInput[]
    delete?: ServiceRequestWhereUniqueInput | ServiceRequestWhereUniqueInput[]
    connect?: ServiceRequestWhereUniqueInput | ServiceRequestWhereUniqueInput[]
    update?: ServiceRequestUpdateWithWhereUniqueWithoutUserInput | ServiceRequestUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ServiceRequestUpdateManyWithWhereWithoutUserInput | ServiceRequestUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ServiceRequestScalarWhereInput | ServiceRequestScalarWhereInput[]
  }

  export type ReviewUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ReviewCreateWithoutUserInput, ReviewUncheckedCreateWithoutUserInput> | ReviewCreateWithoutUserInput[] | ReviewUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutUserInput | ReviewCreateOrConnectWithoutUserInput[]
    upsert?: ReviewUpsertWithWhereUniqueWithoutUserInput | ReviewUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ReviewCreateManyUserInputEnvelope
    set?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    disconnect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    delete?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    update?: ReviewUpdateWithWhereUniqueWithoutUserInput | ReviewUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ReviewUpdateManyWithWhereWithoutUserInput | ReviewUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
  }

  export type IncidentReportUncheckedUpdateManyWithoutReporterNestedInput = {
    create?: XOR<IncidentReportCreateWithoutReporterInput, IncidentReportUncheckedCreateWithoutReporterInput> | IncidentReportCreateWithoutReporterInput[] | IncidentReportUncheckedCreateWithoutReporterInput[]
    connectOrCreate?: IncidentReportCreateOrConnectWithoutReporterInput | IncidentReportCreateOrConnectWithoutReporterInput[]
    upsert?: IncidentReportUpsertWithWhereUniqueWithoutReporterInput | IncidentReportUpsertWithWhereUniqueWithoutReporterInput[]
    createMany?: IncidentReportCreateManyReporterInputEnvelope
    set?: IncidentReportWhereUniqueInput | IncidentReportWhereUniqueInput[]
    disconnect?: IncidentReportWhereUniqueInput | IncidentReportWhereUniqueInput[]
    delete?: IncidentReportWhereUniqueInput | IncidentReportWhereUniqueInput[]
    connect?: IncidentReportWhereUniqueInput | IncidentReportWhereUniqueInput[]
    update?: IncidentReportUpdateWithWhereUniqueWithoutReporterInput | IncidentReportUpdateWithWhereUniqueWithoutReporterInput[]
    updateMany?: IncidentReportUpdateManyWithWhereWithoutReporterInput | IncidentReportUpdateManyWithWhereWithoutReporterInput[]
    deleteMany?: IncidentReportScalarWhereInput | IncidentReportScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type ChatMessageUncheckedUpdateManyWithoutSenderNestedInput = {
    create?: XOR<ChatMessageCreateWithoutSenderInput, ChatMessageUncheckedCreateWithoutSenderInput> | ChatMessageCreateWithoutSenderInput[] | ChatMessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: ChatMessageCreateOrConnectWithoutSenderInput | ChatMessageCreateOrConnectWithoutSenderInput[]
    upsert?: ChatMessageUpsertWithWhereUniqueWithoutSenderInput | ChatMessageUpsertWithWhereUniqueWithoutSenderInput[]
    createMany?: ChatMessageCreateManySenderInputEnvelope
    set?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    disconnect?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    delete?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    connect?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    update?: ChatMessageUpdateWithWhereUniqueWithoutSenderInput | ChatMessageUpdateWithWhereUniqueWithoutSenderInput[]
    updateMany?: ChatMessageUpdateManyWithWhereWithoutSenderInput | ChatMessageUpdateManyWithWhereWithoutSenderInput[]
    deleteMany?: ChatMessageScalarWhereInput | ChatMessageScalarWhereInput[]
  }

  export type WorkshopUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<WorkshopCreateWithoutUserInput, WorkshopUncheckedCreateWithoutUserInput>
    connectOrCreate?: WorkshopCreateOrConnectWithoutUserInput
    upsert?: WorkshopUpsertWithoutUserInput
    disconnect?: WorkshopWhereInput | boolean
    delete?: WorkshopWhereInput | boolean
    connect?: WorkshopWhereUniqueInput
    update?: XOR<XOR<WorkshopUpdateToOneWithWhereWithoutUserInput, WorkshopUpdateWithoutUserInput>, WorkshopUncheckedUpdateWithoutUserInput>
  }

  export type UserProfileCreateNestedOneWithoutMotorcyclesInput = {
    create?: XOR<UserProfileCreateWithoutMotorcyclesInput, UserProfileUncheckedCreateWithoutMotorcyclesInput>
    connectOrCreate?: UserProfileCreateOrConnectWithoutMotorcyclesInput
    connect?: UserProfileWhereUniqueInput
  }

  export type ServiceRequestCreateNestedManyWithoutMotorcycleInput = {
    create?: XOR<ServiceRequestCreateWithoutMotorcycleInput, ServiceRequestUncheckedCreateWithoutMotorcycleInput> | ServiceRequestCreateWithoutMotorcycleInput[] | ServiceRequestUncheckedCreateWithoutMotorcycleInput[]
    connectOrCreate?: ServiceRequestCreateOrConnectWithoutMotorcycleInput | ServiceRequestCreateOrConnectWithoutMotorcycleInput[]
    createMany?: ServiceRequestCreateManyMotorcycleInputEnvelope
    connect?: ServiceRequestWhereUniqueInput | ServiceRequestWhereUniqueInput[]
  }

  export type ServiceRequestUncheckedCreateNestedManyWithoutMotorcycleInput = {
    create?: XOR<ServiceRequestCreateWithoutMotorcycleInput, ServiceRequestUncheckedCreateWithoutMotorcycleInput> | ServiceRequestCreateWithoutMotorcycleInput[] | ServiceRequestUncheckedCreateWithoutMotorcycleInput[]
    connectOrCreate?: ServiceRequestCreateOrConnectWithoutMotorcycleInput | ServiceRequestCreateOrConnectWithoutMotorcycleInput[]
    createMany?: ServiceRequestCreateManyMotorcycleInputEnvelope
    connect?: ServiceRequestWhereUniqueInput | ServiceRequestWhereUniqueInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableEnumMotorcycleUseFieldUpdateOperationsInput = {
    set?: $Enums.MotorcycleUse | null
  }

  export type UserProfileUpdateOneRequiredWithoutMotorcyclesNestedInput = {
    create?: XOR<UserProfileCreateWithoutMotorcyclesInput, UserProfileUncheckedCreateWithoutMotorcyclesInput>
    connectOrCreate?: UserProfileCreateOrConnectWithoutMotorcyclesInput
    upsert?: UserProfileUpsertWithoutMotorcyclesInput
    connect?: UserProfileWhereUniqueInput
    update?: XOR<XOR<UserProfileUpdateToOneWithWhereWithoutMotorcyclesInput, UserProfileUpdateWithoutMotorcyclesInput>, UserProfileUncheckedUpdateWithoutMotorcyclesInput>
  }

  export type ServiceRequestUpdateManyWithoutMotorcycleNestedInput = {
    create?: XOR<ServiceRequestCreateWithoutMotorcycleInput, ServiceRequestUncheckedCreateWithoutMotorcycleInput> | ServiceRequestCreateWithoutMotorcycleInput[] | ServiceRequestUncheckedCreateWithoutMotorcycleInput[]
    connectOrCreate?: ServiceRequestCreateOrConnectWithoutMotorcycleInput | ServiceRequestCreateOrConnectWithoutMotorcycleInput[]
    upsert?: ServiceRequestUpsertWithWhereUniqueWithoutMotorcycleInput | ServiceRequestUpsertWithWhereUniqueWithoutMotorcycleInput[]
    createMany?: ServiceRequestCreateManyMotorcycleInputEnvelope
    set?: ServiceRequestWhereUniqueInput | ServiceRequestWhereUniqueInput[]
    disconnect?: ServiceRequestWhereUniqueInput | ServiceRequestWhereUniqueInput[]
    delete?: ServiceRequestWhereUniqueInput | ServiceRequestWhereUniqueInput[]
    connect?: ServiceRequestWhereUniqueInput | ServiceRequestWhereUniqueInput[]
    update?: ServiceRequestUpdateWithWhereUniqueWithoutMotorcycleInput | ServiceRequestUpdateWithWhereUniqueWithoutMotorcycleInput[]
    updateMany?: ServiceRequestUpdateManyWithWhereWithoutMotorcycleInput | ServiceRequestUpdateManyWithWhereWithoutMotorcycleInput[]
    deleteMany?: ServiceRequestScalarWhereInput | ServiceRequestScalarWhereInput[]
  }

  export type ServiceRequestUncheckedUpdateManyWithoutMotorcycleNestedInput = {
    create?: XOR<ServiceRequestCreateWithoutMotorcycleInput, ServiceRequestUncheckedCreateWithoutMotorcycleInput> | ServiceRequestCreateWithoutMotorcycleInput[] | ServiceRequestUncheckedCreateWithoutMotorcycleInput[]
    connectOrCreate?: ServiceRequestCreateOrConnectWithoutMotorcycleInput | ServiceRequestCreateOrConnectWithoutMotorcycleInput[]
    upsert?: ServiceRequestUpsertWithWhereUniqueWithoutMotorcycleInput | ServiceRequestUpsertWithWhereUniqueWithoutMotorcycleInput[]
    createMany?: ServiceRequestCreateManyMotorcycleInputEnvelope
    set?: ServiceRequestWhereUniqueInput | ServiceRequestWhereUniqueInput[]
    disconnect?: ServiceRequestWhereUniqueInput | ServiceRequestWhereUniqueInput[]
    delete?: ServiceRequestWhereUniqueInput | ServiceRequestWhereUniqueInput[]
    connect?: ServiceRequestWhereUniqueInput | ServiceRequestWhereUniqueInput[]
    update?: ServiceRequestUpdateWithWhereUniqueWithoutMotorcycleInput | ServiceRequestUpdateWithWhereUniqueWithoutMotorcycleInput[]
    updateMany?: ServiceRequestUpdateManyWithWhereWithoutMotorcycleInput | ServiceRequestUpdateManyWithWhereWithoutMotorcycleInput[]
    deleteMany?: ServiceRequestScalarWhereInput | ServiceRequestScalarWhereInput[]
  }

  export type CategoryCreateNestedOneWithoutChildrenInput = {
    create?: XOR<CategoryCreateWithoutChildrenInput, CategoryUncheckedCreateWithoutChildrenInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutChildrenInput
    connect?: CategoryWhereUniqueInput
  }

  export type CategoryCreateNestedManyWithoutParentInput = {
    create?: XOR<CategoryCreateWithoutParentInput, CategoryUncheckedCreateWithoutParentInput> | CategoryCreateWithoutParentInput[] | CategoryUncheckedCreateWithoutParentInput[]
    connectOrCreate?: CategoryCreateOrConnectWithoutParentInput | CategoryCreateOrConnectWithoutParentInput[]
    createMany?: CategoryCreateManyParentInputEnvelope
    connect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
  }

  export type GuideQuestionCreateNestedManyWithoutCategoryInput = {
    create?: XOR<GuideQuestionCreateWithoutCategoryInput, GuideQuestionUncheckedCreateWithoutCategoryInput> | GuideQuestionCreateWithoutCategoryInput[] | GuideQuestionUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: GuideQuestionCreateOrConnectWithoutCategoryInput | GuideQuestionCreateOrConnectWithoutCategoryInput[]
    createMany?: GuideQuestionCreateManyCategoryInputEnvelope
    connect?: GuideQuestionWhereUniqueInput | GuideQuestionWhereUniqueInput[]
  }

  export type ServiceRequestCreateNestedManyWithoutCategoryInput = {
    create?: XOR<ServiceRequestCreateWithoutCategoryInput, ServiceRequestUncheckedCreateWithoutCategoryInput> | ServiceRequestCreateWithoutCategoryInput[] | ServiceRequestUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ServiceRequestCreateOrConnectWithoutCategoryInput | ServiceRequestCreateOrConnectWithoutCategoryInput[]
    createMany?: ServiceRequestCreateManyCategoryInputEnvelope
    connect?: ServiceRequestWhereUniqueInput | ServiceRequestWhereUniqueInput[]
  }

  export type WorkshopCategoryCreateNestedManyWithoutCategoryInput = {
    create?: XOR<WorkshopCategoryCreateWithoutCategoryInput, WorkshopCategoryUncheckedCreateWithoutCategoryInput> | WorkshopCategoryCreateWithoutCategoryInput[] | WorkshopCategoryUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: WorkshopCategoryCreateOrConnectWithoutCategoryInput | WorkshopCategoryCreateOrConnectWithoutCategoryInput[]
    createMany?: WorkshopCategoryCreateManyCategoryInputEnvelope
    connect?: WorkshopCategoryWhereUniqueInput | WorkshopCategoryWhereUniqueInput[]
  }

  export type CategoryUncheckedCreateNestedManyWithoutParentInput = {
    create?: XOR<CategoryCreateWithoutParentInput, CategoryUncheckedCreateWithoutParentInput> | CategoryCreateWithoutParentInput[] | CategoryUncheckedCreateWithoutParentInput[]
    connectOrCreate?: CategoryCreateOrConnectWithoutParentInput | CategoryCreateOrConnectWithoutParentInput[]
    createMany?: CategoryCreateManyParentInputEnvelope
    connect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
  }

  export type GuideQuestionUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<GuideQuestionCreateWithoutCategoryInput, GuideQuestionUncheckedCreateWithoutCategoryInput> | GuideQuestionCreateWithoutCategoryInput[] | GuideQuestionUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: GuideQuestionCreateOrConnectWithoutCategoryInput | GuideQuestionCreateOrConnectWithoutCategoryInput[]
    createMany?: GuideQuestionCreateManyCategoryInputEnvelope
    connect?: GuideQuestionWhereUniqueInput | GuideQuestionWhereUniqueInput[]
  }

  export type ServiceRequestUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<ServiceRequestCreateWithoutCategoryInput, ServiceRequestUncheckedCreateWithoutCategoryInput> | ServiceRequestCreateWithoutCategoryInput[] | ServiceRequestUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ServiceRequestCreateOrConnectWithoutCategoryInput | ServiceRequestCreateOrConnectWithoutCategoryInput[]
    createMany?: ServiceRequestCreateManyCategoryInputEnvelope
    connect?: ServiceRequestWhereUniqueInput | ServiceRequestWhereUniqueInput[]
  }

  export type WorkshopCategoryUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<WorkshopCategoryCreateWithoutCategoryInput, WorkshopCategoryUncheckedCreateWithoutCategoryInput> | WorkshopCategoryCreateWithoutCategoryInput[] | WorkshopCategoryUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: WorkshopCategoryCreateOrConnectWithoutCategoryInput | WorkshopCategoryCreateOrConnectWithoutCategoryInput[]
    createMany?: WorkshopCategoryCreateManyCategoryInputEnvelope
    connect?: WorkshopCategoryWhereUniqueInput | WorkshopCategoryWhereUniqueInput[]
  }

  export type CategoryUpdateOneWithoutChildrenNestedInput = {
    create?: XOR<CategoryCreateWithoutChildrenInput, CategoryUncheckedCreateWithoutChildrenInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutChildrenInput
    upsert?: CategoryUpsertWithoutChildrenInput
    disconnect?: CategoryWhereInput | boolean
    delete?: CategoryWhereInput | boolean
    connect?: CategoryWhereUniqueInput
    update?: XOR<XOR<CategoryUpdateToOneWithWhereWithoutChildrenInput, CategoryUpdateWithoutChildrenInput>, CategoryUncheckedUpdateWithoutChildrenInput>
  }

  export type CategoryUpdateManyWithoutParentNestedInput = {
    create?: XOR<CategoryCreateWithoutParentInput, CategoryUncheckedCreateWithoutParentInput> | CategoryCreateWithoutParentInput[] | CategoryUncheckedCreateWithoutParentInput[]
    connectOrCreate?: CategoryCreateOrConnectWithoutParentInput | CategoryCreateOrConnectWithoutParentInput[]
    upsert?: CategoryUpsertWithWhereUniqueWithoutParentInput | CategoryUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: CategoryCreateManyParentInputEnvelope
    set?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    disconnect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    delete?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    connect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    update?: CategoryUpdateWithWhereUniqueWithoutParentInput | CategoryUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: CategoryUpdateManyWithWhereWithoutParentInput | CategoryUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: CategoryScalarWhereInput | CategoryScalarWhereInput[]
  }

  export type GuideQuestionUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<GuideQuestionCreateWithoutCategoryInput, GuideQuestionUncheckedCreateWithoutCategoryInput> | GuideQuestionCreateWithoutCategoryInput[] | GuideQuestionUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: GuideQuestionCreateOrConnectWithoutCategoryInput | GuideQuestionCreateOrConnectWithoutCategoryInput[]
    upsert?: GuideQuestionUpsertWithWhereUniqueWithoutCategoryInput | GuideQuestionUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: GuideQuestionCreateManyCategoryInputEnvelope
    set?: GuideQuestionWhereUniqueInput | GuideQuestionWhereUniqueInput[]
    disconnect?: GuideQuestionWhereUniqueInput | GuideQuestionWhereUniqueInput[]
    delete?: GuideQuestionWhereUniqueInput | GuideQuestionWhereUniqueInput[]
    connect?: GuideQuestionWhereUniqueInput | GuideQuestionWhereUniqueInput[]
    update?: GuideQuestionUpdateWithWhereUniqueWithoutCategoryInput | GuideQuestionUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: GuideQuestionUpdateManyWithWhereWithoutCategoryInput | GuideQuestionUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: GuideQuestionScalarWhereInput | GuideQuestionScalarWhereInput[]
  }

  export type ServiceRequestUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<ServiceRequestCreateWithoutCategoryInput, ServiceRequestUncheckedCreateWithoutCategoryInput> | ServiceRequestCreateWithoutCategoryInput[] | ServiceRequestUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ServiceRequestCreateOrConnectWithoutCategoryInput | ServiceRequestCreateOrConnectWithoutCategoryInput[]
    upsert?: ServiceRequestUpsertWithWhereUniqueWithoutCategoryInput | ServiceRequestUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: ServiceRequestCreateManyCategoryInputEnvelope
    set?: ServiceRequestWhereUniqueInput | ServiceRequestWhereUniqueInput[]
    disconnect?: ServiceRequestWhereUniqueInput | ServiceRequestWhereUniqueInput[]
    delete?: ServiceRequestWhereUniqueInput | ServiceRequestWhereUniqueInput[]
    connect?: ServiceRequestWhereUniqueInput | ServiceRequestWhereUniqueInput[]
    update?: ServiceRequestUpdateWithWhereUniqueWithoutCategoryInput | ServiceRequestUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: ServiceRequestUpdateManyWithWhereWithoutCategoryInput | ServiceRequestUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: ServiceRequestScalarWhereInput | ServiceRequestScalarWhereInput[]
  }

  export type WorkshopCategoryUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<WorkshopCategoryCreateWithoutCategoryInput, WorkshopCategoryUncheckedCreateWithoutCategoryInput> | WorkshopCategoryCreateWithoutCategoryInput[] | WorkshopCategoryUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: WorkshopCategoryCreateOrConnectWithoutCategoryInput | WorkshopCategoryCreateOrConnectWithoutCategoryInput[]
    upsert?: WorkshopCategoryUpsertWithWhereUniqueWithoutCategoryInput | WorkshopCategoryUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: WorkshopCategoryCreateManyCategoryInputEnvelope
    set?: WorkshopCategoryWhereUniqueInput | WorkshopCategoryWhereUniqueInput[]
    disconnect?: WorkshopCategoryWhereUniqueInput | WorkshopCategoryWhereUniqueInput[]
    delete?: WorkshopCategoryWhereUniqueInput | WorkshopCategoryWhereUniqueInput[]
    connect?: WorkshopCategoryWhereUniqueInput | WorkshopCategoryWhereUniqueInput[]
    update?: WorkshopCategoryUpdateWithWhereUniqueWithoutCategoryInput | WorkshopCategoryUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: WorkshopCategoryUpdateManyWithWhereWithoutCategoryInput | WorkshopCategoryUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: WorkshopCategoryScalarWhereInput | WorkshopCategoryScalarWhereInput[]
  }

  export type CategoryUncheckedUpdateManyWithoutParentNestedInput = {
    create?: XOR<CategoryCreateWithoutParentInput, CategoryUncheckedCreateWithoutParentInput> | CategoryCreateWithoutParentInput[] | CategoryUncheckedCreateWithoutParentInput[]
    connectOrCreate?: CategoryCreateOrConnectWithoutParentInput | CategoryCreateOrConnectWithoutParentInput[]
    upsert?: CategoryUpsertWithWhereUniqueWithoutParentInput | CategoryUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: CategoryCreateManyParentInputEnvelope
    set?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    disconnect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    delete?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    connect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    update?: CategoryUpdateWithWhereUniqueWithoutParentInput | CategoryUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: CategoryUpdateManyWithWhereWithoutParentInput | CategoryUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: CategoryScalarWhereInput | CategoryScalarWhereInput[]
  }

  export type GuideQuestionUncheckedUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<GuideQuestionCreateWithoutCategoryInput, GuideQuestionUncheckedCreateWithoutCategoryInput> | GuideQuestionCreateWithoutCategoryInput[] | GuideQuestionUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: GuideQuestionCreateOrConnectWithoutCategoryInput | GuideQuestionCreateOrConnectWithoutCategoryInput[]
    upsert?: GuideQuestionUpsertWithWhereUniqueWithoutCategoryInput | GuideQuestionUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: GuideQuestionCreateManyCategoryInputEnvelope
    set?: GuideQuestionWhereUniqueInput | GuideQuestionWhereUniqueInput[]
    disconnect?: GuideQuestionWhereUniqueInput | GuideQuestionWhereUniqueInput[]
    delete?: GuideQuestionWhereUniqueInput | GuideQuestionWhereUniqueInput[]
    connect?: GuideQuestionWhereUniqueInput | GuideQuestionWhereUniqueInput[]
    update?: GuideQuestionUpdateWithWhereUniqueWithoutCategoryInput | GuideQuestionUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: GuideQuestionUpdateManyWithWhereWithoutCategoryInput | GuideQuestionUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: GuideQuestionScalarWhereInput | GuideQuestionScalarWhereInput[]
  }

  export type ServiceRequestUncheckedUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<ServiceRequestCreateWithoutCategoryInput, ServiceRequestUncheckedCreateWithoutCategoryInput> | ServiceRequestCreateWithoutCategoryInput[] | ServiceRequestUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ServiceRequestCreateOrConnectWithoutCategoryInput | ServiceRequestCreateOrConnectWithoutCategoryInput[]
    upsert?: ServiceRequestUpsertWithWhereUniqueWithoutCategoryInput | ServiceRequestUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: ServiceRequestCreateManyCategoryInputEnvelope
    set?: ServiceRequestWhereUniqueInput | ServiceRequestWhereUniqueInput[]
    disconnect?: ServiceRequestWhereUniqueInput | ServiceRequestWhereUniqueInput[]
    delete?: ServiceRequestWhereUniqueInput | ServiceRequestWhereUniqueInput[]
    connect?: ServiceRequestWhereUniqueInput | ServiceRequestWhereUniqueInput[]
    update?: ServiceRequestUpdateWithWhereUniqueWithoutCategoryInput | ServiceRequestUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: ServiceRequestUpdateManyWithWhereWithoutCategoryInput | ServiceRequestUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: ServiceRequestScalarWhereInput | ServiceRequestScalarWhereInput[]
  }

  export type WorkshopCategoryUncheckedUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<WorkshopCategoryCreateWithoutCategoryInput, WorkshopCategoryUncheckedCreateWithoutCategoryInput> | WorkshopCategoryCreateWithoutCategoryInput[] | WorkshopCategoryUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: WorkshopCategoryCreateOrConnectWithoutCategoryInput | WorkshopCategoryCreateOrConnectWithoutCategoryInput[]
    upsert?: WorkshopCategoryUpsertWithWhereUniqueWithoutCategoryInput | WorkshopCategoryUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: WorkshopCategoryCreateManyCategoryInputEnvelope
    set?: WorkshopCategoryWhereUniqueInput | WorkshopCategoryWhereUniqueInput[]
    disconnect?: WorkshopCategoryWhereUniqueInput | WorkshopCategoryWhereUniqueInput[]
    delete?: WorkshopCategoryWhereUniqueInput | WorkshopCategoryWhereUniqueInput[]
    connect?: WorkshopCategoryWhereUniqueInput | WorkshopCategoryWhereUniqueInput[]
    update?: WorkshopCategoryUpdateWithWhereUniqueWithoutCategoryInput | WorkshopCategoryUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: WorkshopCategoryUpdateManyWithWhereWithoutCategoryInput | WorkshopCategoryUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: WorkshopCategoryScalarWhereInput | WorkshopCategoryScalarWhereInput[]
  }

  export type CategoryCreateNestedOneWithoutGuideQuestionsInput = {
    create?: XOR<CategoryCreateWithoutGuideQuestionsInput, CategoryUncheckedCreateWithoutGuideQuestionsInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutGuideQuestionsInput
    connect?: CategoryWhereUniqueInput
  }

  export type GuideAnswerCreateNestedManyWithoutQuestionInput = {
    create?: XOR<GuideAnswerCreateWithoutQuestionInput, GuideAnswerUncheckedCreateWithoutQuestionInput> | GuideAnswerCreateWithoutQuestionInput[] | GuideAnswerUncheckedCreateWithoutQuestionInput[]
    connectOrCreate?: GuideAnswerCreateOrConnectWithoutQuestionInput | GuideAnswerCreateOrConnectWithoutQuestionInput[]
    createMany?: GuideAnswerCreateManyQuestionInputEnvelope
    connect?: GuideAnswerWhereUniqueInput | GuideAnswerWhereUniqueInput[]
  }

  export type GuideAnswerUncheckedCreateNestedManyWithoutQuestionInput = {
    create?: XOR<GuideAnswerCreateWithoutQuestionInput, GuideAnswerUncheckedCreateWithoutQuestionInput> | GuideAnswerCreateWithoutQuestionInput[] | GuideAnswerUncheckedCreateWithoutQuestionInput[]
    connectOrCreate?: GuideAnswerCreateOrConnectWithoutQuestionInput | GuideAnswerCreateOrConnectWithoutQuestionInput[]
    createMany?: GuideAnswerCreateManyQuestionInputEnvelope
    connect?: GuideAnswerWhereUniqueInput | GuideAnswerWhereUniqueInput[]
  }

  export type CategoryUpdateOneRequiredWithoutGuideQuestionsNestedInput = {
    create?: XOR<CategoryCreateWithoutGuideQuestionsInput, CategoryUncheckedCreateWithoutGuideQuestionsInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutGuideQuestionsInput
    upsert?: CategoryUpsertWithoutGuideQuestionsInput
    connect?: CategoryWhereUniqueInput
    update?: XOR<XOR<CategoryUpdateToOneWithWhereWithoutGuideQuestionsInput, CategoryUpdateWithoutGuideQuestionsInput>, CategoryUncheckedUpdateWithoutGuideQuestionsInput>
  }

  export type GuideAnswerUpdateManyWithoutQuestionNestedInput = {
    create?: XOR<GuideAnswerCreateWithoutQuestionInput, GuideAnswerUncheckedCreateWithoutQuestionInput> | GuideAnswerCreateWithoutQuestionInput[] | GuideAnswerUncheckedCreateWithoutQuestionInput[]
    connectOrCreate?: GuideAnswerCreateOrConnectWithoutQuestionInput | GuideAnswerCreateOrConnectWithoutQuestionInput[]
    upsert?: GuideAnswerUpsertWithWhereUniqueWithoutQuestionInput | GuideAnswerUpsertWithWhereUniqueWithoutQuestionInput[]
    createMany?: GuideAnswerCreateManyQuestionInputEnvelope
    set?: GuideAnswerWhereUniqueInput | GuideAnswerWhereUniqueInput[]
    disconnect?: GuideAnswerWhereUniqueInput | GuideAnswerWhereUniqueInput[]
    delete?: GuideAnswerWhereUniqueInput | GuideAnswerWhereUniqueInput[]
    connect?: GuideAnswerWhereUniqueInput | GuideAnswerWhereUniqueInput[]
    update?: GuideAnswerUpdateWithWhereUniqueWithoutQuestionInput | GuideAnswerUpdateWithWhereUniqueWithoutQuestionInput[]
    updateMany?: GuideAnswerUpdateManyWithWhereWithoutQuestionInput | GuideAnswerUpdateManyWithWhereWithoutQuestionInput[]
    deleteMany?: GuideAnswerScalarWhereInput | GuideAnswerScalarWhereInput[]
  }

  export type GuideAnswerUncheckedUpdateManyWithoutQuestionNestedInput = {
    create?: XOR<GuideAnswerCreateWithoutQuestionInput, GuideAnswerUncheckedCreateWithoutQuestionInput> | GuideAnswerCreateWithoutQuestionInput[] | GuideAnswerUncheckedCreateWithoutQuestionInput[]
    connectOrCreate?: GuideAnswerCreateOrConnectWithoutQuestionInput | GuideAnswerCreateOrConnectWithoutQuestionInput[]
    upsert?: GuideAnswerUpsertWithWhereUniqueWithoutQuestionInput | GuideAnswerUpsertWithWhereUniqueWithoutQuestionInput[]
    createMany?: GuideAnswerCreateManyQuestionInputEnvelope
    set?: GuideAnswerWhereUniqueInput | GuideAnswerWhereUniqueInput[]
    disconnect?: GuideAnswerWhereUniqueInput | GuideAnswerWhereUniqueInput[]
    delete?: GuideAnswerWhereUniqueInput | GuideAnswerWhereUniqueInput[]
    connect?: GuideAnswerWhereUniqueInput | GuideAnswerWhereUniqueInput[]
    update?: GuideAnswerUpdateWithWhereUniqueWithoutQuestionInput | GuideAnswerUpdateWithWhereUniqueWithoutQuestionInput[]
    updateMany?: GuideAnswerUpdateManyWithWhereWithoutQuestionInput | GuideAnswerUpdateManyWithWhereWithoutQuestionInput[]
    deleteMany?: GuideAnswerScalarWhereInput | GuideAnswerScalarWhereInput[]
  }

  export type GuideQuestionCreateNestedOneWithoutAnswersInput = {
    create?: XOR<GuideQuestionCreateWithoutAnswersInput, GuideQuestionUncheckedCreateWithoutAnswersInput>
    connectOrCreate?: GuideQuestionCreateOrConnectWithoutAnswersInput
    connect?: GuideQuestionWhereUniqueInput
  }

  export type ServiceRequestCreateNestedOneWithoutGuideAnswersInput = {
    create?: XOR<ServiceRequestCreateWithoutGuideAnswersInput, ServiceRequestUncheckedCreateWithoutGuideAnswersInput>
    connectOrCreate?: ServiceRequestCreateOrConnectWithoutGuideAnswersInput
    connect?: ServiceRequestWhereUniqueInput
  }

  export type GuideQuestionUpdateOneRequiredWithoutAnswersNestedInput = {
    create?: XOR<GuideQuestionCreateWithoutAnswersInput, GuideQuestionUncheckedCreateWithoutAnswersInput>
    connectOrCreate?: GuideQuestionCreateOrConnectWithoutAnswersInput
    upsert?: GuideQuestionUpsertWithoutAnswersInput
    connect?: GuideQuestionWhereUniqueInput
    update?: XOR<XOR<GuideQuestionUpdateToOneWithWhereWithoutAnswersInput, GuideQuestionUpdateWithoutAnswersInput>, GuideQuestionUncheckedUpdateWithoutAnswersInput>
  }

  export type ServiceRequestUpdateOneRequiredWithoutGuideAnswersNestedInput = {
    create?: XOR<ServiceRequestCreateWithoutGuideAnswersInput, ServiceRequestUncheckedCreateWithoutGuideAnswersInput>
    connectOrCreate?: ServiceRequestCreateOrConnectWithoutGuideAnswersInput
    upsert?: ServiceRequestUpsertWithoutGuideAnswersInput
    connect?: ServiceRequestWhereUniqueInput
    update?: XOR<XOR<ServiceRequestUpdateToOneWithWhereWithoutGuideAnswersInput, ServiceRequestUpdateWithoutGuideAnswersInput>, ServiceRequestUncheckedUpdateWithoutGuideAnswersInput>
  }

  export type UserProfileCreateNestedOneWithoutServiceRequestsInput = {
    create?: XOR<UserProfileCreateWithoutServiceRequestsInput, UserProfileUncheckedCreateWithoutServiceRequestsInput>
    connectOrCreate?: UserProfileCreateOrConnectWithoutServiceRequestsInput
    connect?: UserProfileWhereUniqueInput
  }

  export type MotorcycleCreateNestedOneWithoutServiceRequestsInput = {
    create?: XOR<MotorcycleCreateWithoutServiceRequestsInput, MotorcycleUncheckedCreateWithoutServiceRequestsInput>
    connectOrCreate?: MotorcycleCreateOrConnectWithoutServiceRequestsInput
    connect?: MotorcycleWhereUniqueInput
  }

  export type CategoryCreateNestedOneWithoutServiceRequestsInput = {
    create?: XOR<CategoryCreateWithoutServiceRequestsInput, CategoryUncheckedCreateWithoutServiceRequestsInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutServiceRequestsInput
    connect?: CategoryWhereUniqueInput
  }

  export type RequestMediaCreateNestedManyWithoutRequestInput = {
    create?: XOR<RequestMediaCreateWithoutRequestInput, RequestMediaUncheckedCreateWithoutRequestInput> | RequestMediaCreateWithoutRequestInput[] | RequestMediaUncheckedCreateWithoutRequestInput[]
    connectOrCreate?: RequestMediaCreateOrConnectWithoutRequestInput | RequestMediaCreateOrConnectWithoutRequestInput[]
    createMany?: RequestMediaCreateManyRequestInputEnvelope
    connect?: RequestMediaWhereUniqueInput | RequestMediaWhereUniqueInput[]
  }

  export type GuideAnswerCreateNestedManyWithoutRequestInput = {
    create?: XOR<GuideAnswerCreateWithoutRequestInput, GuideAnswerUncheckedCreateWithoutRequestInput> | GuideAnswerCreateWithoutRequestInput[] | GuideAnswerUncheckedCreateWithoutRequestInput[]
    connectOrCreate?: GuideAnswerCreateOrConnectWithoutRequestInput | GuideAnswerCreateOrConnectWithoutRequestInput[]
    createMany?: GuideAnswerCreateManyRequestInputEnvelope
    connect?: GuideAnswerWhereUniqueInput | GuideAnswerWhereUniqueInput[]
  }

  export type QuoteCreateNestedManyWithoutRequestInput = {
    create?: XOR<QuoteCreateWithoutRequestInput, QuoteUncheckedCreateWithoutRequestInput> | QuoteCreateWithoutRequestInput[] | QuoteUncheckedCreateWithoutRequestInput[]
    connectOrCreate?: QuoteCreateOrConnectWithoutRequestInput | QuoteCreateOrConnectWithoutRequestInput[]
    createMany?: QuoteCreateManyRequestInputEnvelope
    connect?: QuoteWhereUniqueInput | QuoteWhereUniqueInput[]
  }

  export type RequestStatusHistoryCreateNestedManyWithoutRequestInput = {
    create?: XOR<RequestStatusHistoryCreateWithoutRequestInput, RequestStatusHistoryUncheckedCreateWithoutRequestInput> | RequestStatusHistoryCreateWithoutRequestInput[] | RequestStatusHistoryUncheckedCreateWithoutRequestInput[]
    connectOrCreate?: RequestStatusHistoryCreateOrConnectWithoutRequestInput | RequestStatusHistoryCreateOrConnectWithoutRequestInput[]
    createMany?: RequestStatusHistoryCreateManyRequestInputEnvelope
    connect?: RequestStatusHistoryWhereUniqueInput | RequestStatusHistoryWhereUniqueInput[]
  }

  export type NotificationCreateNestedManyWithoutRequestInput = {
    create?: XOR<NotificationCreateWithoutRequestInput, NotificationUncheckedCreateWithoutRequestInput> | NotificationCreateWithoutRequestInput[] | NotificationUncheckedCreateWithoutRequestInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutRequestInput | NotificationCreateOrConnectWithoutRequestInput[]
    createMany?: NotificationCreateManyRequestInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type WorkOrderCreateNestedOneWithoutRequestInput = {
    create?: XOR<WorkOrderCreateWithoutRequestInput, WorkOrderUncheckedCreateWithoutRequestInput>
    connectOrCreate?: WorkOrderCreateOrConnectWithoutRequestInput
    connect?: WorkOrderWhereUniqueInput
  }

  export type ChatMessageCreateNestedManyWithoutRequestInput = {
    create?: XOR<ChatMessageCreateWithoutRequestInput, ChatMessageUncheckedCreateWithoutRequestInput> | ChatMessageCreateWithoutRequestInput[] | ChatMessageUncheckedCreateWithoutRequestInput[]
    connectOrCreate?: ChatMessageCreateOrConnectWithoutRequestInput | ChatMessageCreateOrConnectWithoutRequestInput[]
    createMany?: ChatMessageCreateManyRequestInputEnvelope
    connect?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
  }

  export type AiSuggestionCreateNestedManyWithoutRequestInput = {
    create?: XOR<AiSuggestionCreateWithoutRequestInput, AiSuggestionUncheckedCreateWithoutRequestInput> | AiSuggestionCreateWithoutRequestInput[] | AiSuggestionUncheckedCreateWithoutRequestInput[]
    connectOrCreate?: AiSuggestionCreateOrConnectWithoutRequestInput | AiSuggestionCreateOrConnectWithoutRequestInput[]
    createMany?: AiSuggestionCreateManyRequestInputEnvelope
    connect?: AiSuggestionWhereUniqueInput | AiSuggestionWhereUniqueInput[]
  }

  export type RequestMediaUncheckedCreateNestedManyWithoutRequestInput = {
    create?: XOR<RequestMediaCreateWithoutRequestInput, RequestMediaUncheckedCreateWithoutRequestInput> | RequestMediaCreateWithoutRequestInput[] | RequestMediaUncheckedCreateWithoutRequestInput[]
    connectOrCreate?: RequestMediaCreateOrConnectWithoutRequestInput | RequestMediaCreateOrConnectWithoutRequestInput[]
    createMany?: RequestMediaCreateManyRequestInputEnvelope
    connect?: RequestMediaWhereUniqueInput | RequestMediaWhereUniqueInput[]
  }

  export type GuideAnswerUncheckedCreateNestedManyWithoutRequestInput = {
    create?: XOR<GuideAnswerCreateWithoutRequestInput, GuideAnswerUncheckedCreateWithoutRequestInput> | GuideAnswerCreateWithoutRequestInput[] | GuideAnswerUncheckedCreateWithoutRequestInput[]
    connectOrCreate?: GuideAnswerCreateOrConnectWithoutRequestInput | GuideAnswerCreateOrConnectWithoutRequestInput[]
    createMany?: GuideAnswerCreateManyRequestInputEnvelope
    connect?: GuideAnswerWhereUniqueInput | GuideAnswerWhereUniqueInput[]
  }

  export type QuoteUncheckedCreateNestedManyWithoutRequestInput = {
    create?: XOR<QuoteCreateWithoutRequestInput, QuoteUncheckedCreateWithoutRequestInput> | QuoteCreateWithoutRequestInput[] | QuoteUncheckedCreateWithoutRequestInput[]
    connectOrCreate?: QuoteCreateOrConnectWithoutRequestInput | QuoteCreateOrConnectWithoutRequestInput[]
    createMany?: QuoteCreateManyRequestInputEnvelope
    connect?: QuoteWhereUniqueInput | QuoteWhereUniqueInput[]
  }

  export type RequestStatusHistoryUncheckedCreateNestedManyWithoutRequestInput = {
    create?: XOR<RequestStatusHistoryCreateWithoutRequestInput, RequestStatusHistoryUncheckedCreateWithoutRequestInput> | RequestStatusHistoryCreateWithoutRequestInput[] | RequestStatusHistoryUncheckedCreateWithoutRequestInput[]
    connectOrCreate?: RequestStatusHistoryCreateOrConnectWithoutRequestInput | RequestStatusHistoryCreateOrConnectWithoutRequestInput[]
    createMany?: RequestStatusHistoryCreateManyRequestInputEnvelope
    connect?: RequestStatusHistoryWhereUniqueInput | RequestStatusHistoryWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutRequestInput = {
    create?: XOR<NotificationCreateWithoutRequestInput, NotificationUncheckedCreateWithoutRequestInput> | NotificationCreateWithoutRequestInput[] | NotificationUncheckedCreateWithoutRequestInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutRequestInput | NotificationCreateOrConnectWithoutRequestInput[]
    createMany?: NotificationCreateManyRequestInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type WorkOrderUncheckedCreateNestedOneWithoutRequestInput = {
    create?: XOR<WorkOrderCreateWithoutRequestInput, WorkOrderUncheckedCreateWithoutRequestInput>
    connectOrCreate?: WorkOrderCreateOrConnectWithoutRequestInput
    connect?: WorkOrderWhereUniqueInput
  }

  export type ChatMessageUncheckedCreateNestedManyWithoutRequestInput = {
    create?: XOR<ChatMessageCreateWithoutRequestInput, ChatMessageUncheckedCreateWithoutRequestInput> | ChatMessageCreateWithoutRequestInput[] | ChatMessageUncheckedCreateWithoutRequestInput[]
    connectOrCreate?: ChatMessageCreateOrConnectWithoutRequestInput | ChatMessageCreateOrConnectWithoutRequestInput[]
    createMany?: ChatMessageCreateManyRequestInputEnvelope
    connect?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
  }

  export type AiSuggestionUncheckedCreateNestedManyWithoutRequestInput = {
    create?: XOR<AiSuggestionCreateWithoutRequestInput, AiSuggestionUncheckedCreateWithoutRequestInput> | AiSuggestionCreateWithoutRequestInput[] | AiSuggestionUncheckedCreateWithoutRequestInput[]
    connectOrCreate?: AiSuggestionCreateOrConnectWithoutRequestInput | AiSuggestionCreateOrConnectWithoutRequestInput[]
    createMany?: AiSuggestionCreateManyRequestInputEnvelope
    connect?: AiSuggestionWhereUniqueInput | AiSuggestionWhereUniqueInput[]
  }

  export type EnumUrgencyLevelFieldUpdateOperationsInput = {
    set?: $Enums.UrgencyLevel
  }

  export type EnumServiceRequestStatusFieldUpdateOperationsInput = {
    set?: $Enums.ServiceRequestStatus
  }

  export type UserProfileUpdateOneRequiredWithoutServiceRequestsNestedInput = {
    create?: XOR<UserProfileCreateWithoutServiceRequestsInput, UserProfileUncheckedCreateWithoutServiceRequestsInput>
    connectOrCreate?: UserProfileCreateOrConnectWithoutServiceRequestsInput
    upsert?: UserProfileUpsertWithoutServiceRequestsInput
    connect?: UserProfileWhereUniqueInput
    update?: XOR<XOR<UserProfileUpdateToOneWithWhereWithoutServiceRequestsInput, UserProfileUpdateWithoutServiceRequestsInput>, UserProfileUncheckedUpdateWithoutServiceRequestsInput>
  }

  export type MotorcycleUpdateOneRequiredWithoutServiceRequestsNestedInput = {
    create?: XOR<MotorcycleCreateWithoutServiceRequestsInput, MotorcycleUncheckedCreateWithoutServiceRequestsInput>
    connectOrCreate?: MotorcycleCreateOrConnectWithoutServiceRequestsInput
    upsert?: MotorcycleUpsertWithoutServiceRequestsInput
    connect?: MotorcycleWhereUniqueInput
    update?: XOR<XOR<MotorcycleUpdateToOneWithWhereWithoutServiceRequestsInput, MotorcycleUpdateWithoutServiceRequestsInput>, MotorcycleUncheckedUpdateWithoutServiceRequestsInput>
  }

  export type CategoryUpdateOneRequiredWithoutServiceRequestsNestedInput = {
    create?: XOR<CategoryCreateWithoutServiceRequestsInput, CategoryUncheckedCreateWithoutServiceRequestsInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutServiceRequestsInput
    upsert?: CategoryUpsertWithoutServiceRequestsInput
    connect?: CategoryWhereUniqueInput
    update?: XOR<XOR<CategoryUpdateToOneWithWhereWithoutServiceRequestsInput, CategoryUpdateWithoutServiceRequestsInput>, CategoryUncheckedUpdateWithoutServiceRequestsInput>
  }

  export type RequestMediaUpdateManyWithoutRequestNestedInput = {
    create?: XOR<RequestMediaCreateWithoutRequestInput, RequestMediaUncheckedCreateWithoutRequestInput> | RequestMediaCreateWithoutRequestInput[] | RequestMediaUncheckedCreateWithoutRequestInput[]
    connectOrCreate?: RequestMediaCreateOrConnectWithoutRequestInput | RequestMediaCreateOrConnectWithoutRequestInput[]
    upsert?: RequestMediaUpsertWithWhereUniqueWithoutRequestInput | RequestMediaUpsertWithWhereUniqueWithoutRequestInput[]
    createMany?: RequestMediaCreateManyRequestInputEnvelope
    set?: RequestMediaWhereUniqueInput | RequestMediaWhereUniqueInput[]
    disconnect?: RequestMediaWhereUniqueInput | RequestMediaWhereUniqueInput[]
    delete?: RequestMediaWhereUniqueInput | RequestMediaWhereUniqueInput[]
    connect?: RequestMediaWhereUniqueInput | RequestMediaWhereUniqueInput[]
    update?: RequestMediaUpdateWithWhereUniqueWithoutRequestInput | RequestMediaUpdateWithWhereUniqueWithoutRequestInput[]
    updateMany?: RequestMediaUpdateManyWithWhereWithoutRequestInput | RequestMediaUpdateManyWithWhereWithoutRequestInput[]
    deleteMany?: RequestMediaScalarWhereInput | RequestMediaScalarWhereInput[]
  }

  export type GuideAnswerUpdateManyWithoutRequestNestedInput = {
    create?: XOR<GuideAnswerCreateWithoutRequestInput, GuideAnswerUncheckedCreateWithoutRequestInput> | GuideAnswerCreateWithoutRequestInput[] | GuideAnswerUncheckedCreateWithoutRequestInput[]
    connectOrCreate?: GuideAnswerCreateOrConnectWithoutRequestInput | GuideAnswerCreateOrConnectWithoutRequestInput[]
    upsert?: GuideAnswerUpsertWithWhereUniqueWithoutRequestInput | GuideAnswerUpsertWithWhereUniqueWithoutRequestInput[]
    createMany?: GuideAnswerCreateManyRequestInputEnvelope
    set?: GuideAnswerWhereUniqueInput | GuideAnswerWhereUniqueInput[]
    disconnect?: GuideAnswerWhereUniqueInput | GuideAnswerWhereUniqueInput[]
    delete?: GuideAnswerWhereUniqueInput | GuideAnswerWhereUniqueInput[]
    connect?: GuideAnswerWhereUniqueInput | GuideAnswerWhereUniqueInput[]
    update?: GuideAnswerUpdateWithWhereUniqueWithoutRequestInput | GuideAnswerUpdateWithWhereUniqueWithoutRequestInput[]
    updateMany?: GuideAnswerUpdateManyWithWhereWithoutRequestInput | GuideAnswerUpdateManyWithWhereWithoutRequestInput[]
    deleteMany?: GuideAnswerScalarWhereInput | GuideAnswerScalarWhereInput[]
  }

  export type QuoteUpdateManyWithoutRequestNestedInput = {
    create?: XOR<QuoteCreateWithoutRequestInput, QuoteUncheckedCreateWithoutRequestInput> | QuoteCreateWithoutRequestInput[] | QuoteUncheckedCreateWithoutRequestInput[]
    connectOrCreate?: QuoteCreateOrConnectWithoutRequestInput | QuoteCreateOrConnectWithoutRequestInput[]
    upsert?: QuoteUpsertWithWhereUniqueWithoutRequestInput | QuoteUpsertWithWhereUniqueWithoutRequestInput[]
    createMany?: QuoteCreateManyRequestInputEnvelope
    set?: QuoteWhereUniqueInput | QuoteWhereUniqueInput[]
    disconnect?: QuoteWhereUniqueInput | QuoteWhereUniqueInput[]
    delete?: QuoteWhereUniqueInput | QuoteWhereUniqueInput[]
    connect?: QuoteWhereUniqueInput | QuoteWhereUniqueInput[]
    update?: QuoteUpdateWithWhereUniqueWithoutRequestInput | QuoteUpdateWithWhereUniqueWithoutRequestInput[]
    updateMany?: QuoteUpdateManyWithWhereWithoutRequestInput | QuoteUpdateManyWithWhereWithoutRequestInput[]
    deleteMany?: QuoteScalarWhereInput | QuoteScalarWhereInput[]
  }

  export type RequestStatusHistoryUpdateManyWithoutRequestNestedInput = {
    create?: XOR<RequestStatusHistoryCreateWithoutRequestInput, RequestStatusHistoryUncheckedCreateWithoutRequestInput> | RequestStatusHistoryCreateWithoutRequestInput[] | RequestStatusHistoryUncheckedCreateWithoutRequestInput[]
    connectOrCreate?: RequestStatusHistoryCreateOrConnectWithoutRequestInput | RequestStatusHistoryCreateOrConnectWithoutRequestInput[]
    upsert?: RequestStatusHistoryUpsertWithWhereUniqueWithoutRequestInput | RequestStatusHistoryUpsertWithWhereUniqueWithoutRequestInput[]
    createMany?: RequestStatusHistoryCreateManyRequestInputEnvelope
    set?: RequestStatusHistoryWhereUniqueInput | RequestStatusHistoryWhereUniqueInput[]
    disconnect?: RequestStatusHistoryWhereUniqueInput | RequestStatusHistoryWhereUniqueInput[]
    delete?: RequestStatusHistoryWhereUniqueInput | RequestStatusHistoryWhereUniqueInput[]
    connect?: RequestStatusHistoryWhereUniqueInput | RequestStatusHistoryWhereUniqueInput[]
    update?: RequestStatusHistoryUpdateWithWhereUniqueWithoutRequestInput | RequestStatusHistoryUpdateWithWhereUniqueWithoutRequestInput[]
    updateMany?: RequestStatusHistoryUpdateManyWithWhereWithoutRequestInput | RequestStatusHistoryUpdateManyWithWhereWithoutRequestInput[]
    deleteMany?: RequestStatusHistoryScalarWhereInput | RequestStatusHistoryScalarWhereInput[]
  }

  export type NotificationUpdateManyWithoutRequestNestedInput = {
    create?: XOR<NotificationCreateWithoutRequestInput, NotificationUncheckedCreateWithoutRequestInput> | NotificationCreateWithoutRequestInput[] | NotificationUncheckedCreateWithoutRequestInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutRequestInput | NotificationCreateOrConnectWithoutRequestInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutRequestInput | NotificationUpsertWithWhereUniqueWithoutRequestInput[]
    createMany?: NotificationCreateManyRequestInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutRequestInput | NotificationUpdateWithWhereUniqueWithoutRequestInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutRequestInput | NotificationUpdateManyWithWhereWithoutRequestInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type WorkOrderUpdateOneWithoutRequestNestedInput = {
    create?: XOR<WorkOrderCreateWithoutRequestInput, WorkOrderUncheckedCreateWithoutRequestInput>
    connectOrCreate?: WorkOrderCreateOrConnectWithoutRequestInput
    upsert?: WorkOrderUpsertWithoutRequestInput
    disconnect?: WorkOrderWhereInput | boolean
    delete?: WorkOrderWhereInput | boolean
    connect?: WorkOrderWhereUniqueInput
    update?: XOR<XOR<WorkOrderUpdateToOneWithWhereWithoutRequestInput, WorkOrderUpdateWithoutRequestInput>, WorkOrderUncheckedUpdateWithoutRequestInput>
  }

  export type ChatMessageUpdateManyWithoutRequestNestedInput = {
    create?: XOR<ChatMessageCreateWithoutRequestInput, ChatMessageUncheckedCreateWithoutRequestInput> | ChatMessageCreateWithoutRequestInput[] | ChatMessageUncheckedCreateWithoutRequestInput[]
    connectOrCreate?: ChatMessageCreateOrConnectWithoutRequestInput | ChatMessageCreateOrConnectWithoutRequestInput[]
    upsert?: ChatMessageUpsertWithWhereUniqueWithoutRequestInput | ChatMessageUpsertWithWhereUniqueWithoutRequestInput[]
    createMany?: ChatMessageCreateManyRequestInputEnvelope
    set?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    disconnect?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    delete?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    connect?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    update?: ChatMessageUpdateWithWhereUniqueWithoutRequestInput | ChatMessageUpdateWithWhereUniqueWithoutRequestInput[]
    updateMany?: ChatMessageUpdateManyWithWhereWithoutRequestInput | ChatMessageUpdateManyWithWhereWithoutRequestInput[]
    deleteMany?: ChatMessageScalarWhereInput | ChatMessageScalarWhereInput[]
  }

  export type AiSuggestionUpdateManyWithoutRequestNestedInput = {
    create?: XOR<AiSuggestionCreateWithoutRequestInput, AiSuggestionUncheckedCreateWithoutRequestInput> | AiSuggestionCreateWithoutRequestInput[] | AiSuggestionUncheckedCreateWithoutRequestInput[]
    connectOrCreate?: AiSuggestionCreateOrConnectWithoutRequestInput | AiSuggestionCreateOrConnectWithoutRequestInput[]
    upsert?: AiSuggestionUpsertWithWhereUniqueWithoutRequestInput | AiSuggestionUpsertWithWhereUniqueWithoutRequestInput[]
    createMany?: AiSuggestionCreateManyRequestInputEnvelope
    set?: AiSuggestionWhereUniqueInput | AiSuggestionWhereUniqueInput[]
    disconnect?: AiSuggestionWhereUniqueInput | AiSuggestionWhereUniqueInput[]
    delete?: AiSuggestionWhereUniqueInput | AiSuggestionWhereUniqueInput[]
    connect?: AiSuggestionWhereUniqueInput | AiSuggestionWhereUniqueInput[]
    update?: AiSuggestionUpdateWithWhereUniqueWithoutRequestInput | AiSuggestionUpdateWithWhereUniqueWithoutRequestInput[]
    updateMany?: AiSuggestionUpdateManyWithWhereWithoutRequestInput | AiSuggestionUpdateManyWithWhereWithoutRequestInput[]
    deleteMany?: AiSuggestionScalarWhereInput | AiSuggestionScalarWhereInput[]
  }

  export type RequestMediaUncheckedUpdateManyWithoutRequestNestedInput = {
    create?: XOR<RequestMediaCreateWithoutRequestInput, RequestMediaUncheckedCreateWithoutRequestInput> | RequestMediaCreateWithoutRequestInput[] | RequestMediaUncheckedCreateWithoutRequestInput[]
    connectOrCreate?: RequestMediaCreateOrConnectWithoutRequestInput | RequestMediaCreateOrConnectWithoutRequestInput[]
    upsert?: RequestMediaUpsertWithWhereUniqueWithoutRequestInput | RequestMediaUpsertWithWhereUniqueWithoutRequestInput[]
    createMany?: RequestMediaCreateManyRequestInputEnvelope
    set?: RequestMediaWhereUniqueInput | RequestMediaWhereUniqueInput[]
    disconnect?: RequestMediaWhereUniqueInput | RequestMediaWhereUniqueInput[]
    delete?: RequestMediaWhereUniqueInput | RequestMediaWhereUniqueInput[]
    connect?: RequestMediaWhereUniqueInput | RequestMediaWhereUniqueInput[]
    update?: RequestMediaUpdateWithWhereUniqueWithoutRequestInput | RequestMediaUpdateWithWhereUniqueWithoutRequestInput[]
    updateMany?: RequestMediaUpdateManyWithWhereWithoutRequestInput | RequestMediaUpdateManyWithWhereWithoutRequestInput[]
    deleteMany?: RequestMediaScalarWhereInput | RequestMediaScalarWhereInput[]
  }

  export type GuideAnswerUncheckedUpdateManyWithoutRequestNestedInput = {
    create?: XOR<GuideAnswerCreateWithoutRequestInput, GuideAnswerUncheckedCreateWithoutRequestInput> | GuideAnswerCreateWithoutRequestInput[] | GuideAnswerUncheckedCreateWithoutRequestInput[]
    connectOrCreate?: GuideAnswerCreateOrConnectWithoutRequestInput | GuideAnswerCreateOrConnectWithoutRequestInput[]
    upsert?: GuideAnswerUpsertWithWhereUniqueWithoutRequestInput | GuideAnswerUpsertWithWhereUniqueWithoutRequestInput[]
    createMany?: GuideAnswerCreateManyRequestInputEnvelope
    set?: GuideAnswerWhereUniqueInput | GuideAnswerWhereUniqueInput[]
    disconnect?: GuideAnswerWhereUniqueInput | GuideAnswerWhereUniqueInput[]
    delete?: GuideAnswerWhereUniqueInput | GuideAnswerWhereUniqueInput[]
    connect?: GuideAnswerWhereUniqueInput | GuideAnswerWhereUniqueInput[]
    update?: GuideAnswerUpdateWithWhereUniqueWithoutRequestInput | GuideAnswerUpdateWithWhereUniqueWithoutRequestInput[]
    updateMany?: GuideAnswerUpdateManyWithWhereWithoutRequestInput | GuideAnswerUpdateManyWithWhereWithoutRequestInput[]
    deleteMany?: GuideAnswerScalarWhereInput | GuideAnswerScalarWhereInput[]
  }

  export type QuoteUncheckedUpdateManyWithoutRequestNestedInput = {
    create?: XOR<QuoteCreateWithoutRequestInput, QuoteUncheckedCreateWithoutRequestInput> | QuoteCreateWithoutRequestInput[] | QuoteUncheckedCreateWithoutRequestInput[]
    connectOrCreate?: QuoteCreateOrConnectWithoutRequestInput | QuoteCreateOrConnectWithoutRequestInput[]
    upsert?: QuoteUpsertWithWhereUniqueWithoutRequestInput | QuoteUpsertWithWhereUniqueWithoutRequestInput[]
    createMany?: QuoteCreateManyRequestInputEnvelope
    set?: QuoteWhereUniqueInput | QuoteWhereUniqueInput[]
    disconnect?: QuoteWhereUniqueInput | QuoteWhereUniqueInput[]
    delete?: QuoteWhereUniqueInput | QuoteWhereUniqueInput[]
    connect?: QuoteWhereUniqueInput | QuoteWhereUniqueInput[]
    update?: QuoteUpdateWithWhereUniqueWithoutRequestInput | QuoteUpdateWithWhereUniqueWithoutRequestInput[]
    updateMany?: QuoteUpdateManyWithWhereWithoutRequestInput | QuoteUpdateManyWithWhereWithoutRequestInput[]
    deleteMany?: QuoteScalarWhereInput | QuoteScalarWhereInput[]
  }

  export type RequestStatusHistoryUncheckedUpdateManyWithoutRequestNestedInput = {
    create?: XOR<RequestStatusHistoryCreateWithoutRequestInput, RequestStatusHistoryUncheckedCreateWithoutRequestInput> | RequestStatusHistoryCreateWithoutRequestInput[] | RequestStatusHistoryUncheckedCreateWithoutRequestInput[]
    connectOrCreate?: RequestStatusHistoryCreateOrConnectWithoutRequestInput | RequestStatusHistoryCreateOrConnectWithoutRequestInput[]
    upsert?: RequestStatusHistoryUpsertWithWhereUniqueWithoutRequestInput | RequestStatusHistoryUpsertWithWhereUniqueWithoutRequestInput[]
    createMany?: RequestStatusHistoryCreateManyRequestInputEnvelope
    set?: RequestStatusHistoryWhereUniqueInput | RequestStatusHistoryWhereUniqueInput[]
    disconnect?: RequestStatusHistoryWhereUniqueInput | RequestStatusHistoryWhereUniqueInput[]
    delete?: RequestStatusHistoryWhereUniqueInput | RequestStatusHistoryWhereUniqueInput[]
    connect?: RequestStatusHistoryWhereUniqueInput | RequestStatusHistoryWhereUniqueInput[]
    update?: RequestStatusHistoryUpdateWithWhereUniqueWithoutRequestInput | RequestStatusHistoryUpdateWithWhereUniqueWithoutRequestInput[]
    updateMany?: RequestStatusHistoryUpdateManyWithWhereWithoutRequestInput | RequestStatusHistoryUpdateManyWithWhereWithoutRequestInput[]
    deleteMany?: RequestStatusHistoryScalarWhereInput | RequestStatusHistoryScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutRequestNestedInput = {
    create?: XOR<NotificationCreateWithoutRequestInput, NotificationUncheckedCreateWithoutRequestInput> | NotificationCreateWithoutRequestInput[] | NotificationUncheckedCreateWithoutRequestInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutRequestInput | NotificationCreateOrConnectWithoutRequestInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutRequestInput | NotificationUpsertWithWhereUniqueWithoutRequestInput[]
    createMany?: NotificationCreateManyRequestInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutRequestInput | NotificationUpdateWithWhereUniqueWithoutRequestInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutRequestInput | NotificationUpdateManyWithWhereWithoutRequestInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type WorkOrderUncheckedUpdateOneWithoutRequestNestedInput = {
    create?: XOR<WorkOrderCreateWithoutRequestInput, WorkOrderUncheckedCreateWithoutRequestInput>
    connectOrCreate?: WorkOrderCreateOrConnectWithoutRequestInput
    upsert?: WorkOrderUpsertWithoutRequestInput
    disconnect?: WorkOrderWhereInput | boolean
    delete?: WorkOrderWhereInput | boolean
    connect?: WorkOrderWhereUniqueInput
    update?: XOR<XOR<WorkOrderUpdateToOneWithWhereWithoutRequestInput, WorkOrderUpdateWithoutRequestInput>, WorkOrderUncheckedUpdateWithoutRequestInput>
  }

  export type ChatMessageUncheckedUpdateManyWithoutRequestNestedInput = {
    create?: XOR<ChatMessageCreateWithoutRequestInput, ChatMessageUncheckedCreateWithoutRequestInput> | ChatMessageCreateWithoutRequestInput[] | ChatMessageUncheckedCreateWithoutRequestInput[]
    connectOrCreate?: ChatMessageCreateOrConnectWithoutRequestInput | ChatMessageCreateOrConnectWithoutRequestInput[]
    upsert?: ChatMessageUpsertWithWhereUniqueWithoutRequestInput | ChatMessageUpsertWithWhereUniqueWithoutRequestInput[]
    createMany?: ChatMessageCreateManyRequestInputEnvelope
    set?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    disconnect?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    delete?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    connect?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    update?: ChatMessageUpdateWithWhereUniqueWithoutRequestInput | ChatMessageUpdateWithWhereUniqueWithoutRequestInput[]
    updateMany?: ChatMessageUpdateManyWithWhereWithoutRequestInput | ChatMessageUpdateManyWithWhereWithoutRequestInput[]
    deleteMany?: ChatMessageScalarWhereInput | ChatMessageScalarWhereInput[]
  }

  export type AiSuggestionUncheckedUpdateManyWithoutRequestNestedInput = {
    create?: XOR<AiSuggestionCreateWithoutRequestInput, AiSuggestionUncheckedCreateWithoutRequestInput> | AiSuggestionCreateWithoutRequestInput[] | AiSuggestionUncheckedCreateWithoutRequestInput[]
    connectOrCreate?: AiSuggestionCreateOrConnectWithoutRequestInput | AiSuggestionCreateOrConnectWithoutRequestInput[]
    upsert?: AiSuggestionUpsertWithWhereUniqueWithoutRequestInput | AiSuggestionUpsertWithWhereUniqueWithoutRequestInput[]
    createMany?: AiSuggestionCreateManyRequestInputEnvelope
    set?: AiSuggestionWhereUniqueInput | AiSuggestionWhereUniqueInput[]
    disconnect?: AiSuggestionWhereUniqueInput | AiSuggestionWhereUniqueInput[]
    delete?: AiSuggestionWhereUniqueInput | AiSuggestionWhereUniqueInput[]
    connect?: AiSuggestionWhereUniqueInput | AiSuggestionWhereUniqueInput[]
    update?: AiSuggestionUpdateWithWhereUniqueWithoutRequestInput | AiSuggestionUpdateWithWhereUniqueWithoutRequestInput[]
    updateMany?: AiSuggestionUpdateManyWithWhereWithoutRequestInput | AiSuggestionUpdateManyWithWhereWithoutRequestInput[]
    deleteMany?: AiSuggestionScalarWhereInput | AiSuggestionScalarWhereInput[]
  }

  export type ServiceRequestCreateNestedOneWithoutMediaInput = {
    create?: XOR<ServiceRequestCreateWithoutMediaInput, ServiceRequestUncheckedCreateWithoutMediaInput>
    connectOrCreate?: ServiceRequestCreateOrConnectWithoutMediaInput
    connect?: ServiceRequestWhereUniqueInput
  }

  export type EnumMediaTypeFieldUpdateOperationsInput = {
    set?: $Enums.MediaType
  }

  export type ServiceRequestUpdateOneRequiredWithoutMediaNestedInput = {
    create?: XOR<ServiceRequestCreateWithoutMediaInput, ServiceRequestUncheckedCreateWithoutMediaInput>
    connectOrCreate?: ServiceRequestCreateOrConnectWithoutMediaInput
    upsert?: ServiceRequestUpsertWithoutMediaInput
    connect?: ServiceRequestWhereUniqueInput
    update?: XOR<XOR<ServiceRequestUpdateToOneWithWhereWithoutMediaInput, ServiceRequestUpdateWithoutMediaInput>, ServiceRequestUncheckedUpdateWithoutMediaInput>
  }

  export type ServiceRequestCreateNestedOneWithoutStatusHistoryInput = {
    create?: XOR<ServiceRequestCreateWithoutStatusHistoryInput, ServiceRequestUncheckedCreateWithoutStatusHistoryInput>
    connectOrCreate?: ServiceRequestCreateOrConnectWithoutStatusHistoryInput
    connect?: ServiceRequestWhereUniqueInput
  }

  export type NullableEnumServiceRequestStatusFieldUpdateOperationsInput = {
    set?: $Enums.ServiceRequestStatus | null
  }

  export type ServiceRequestUpdateOneRequiredWithoutStatusHistoryNestedInput = {
    create?: XOR<ServiceRequestCreateWithoutStatusHistoryInput, ServiceRequestUncheckedCreateWithoutStatusHistoryInput>
    connectOrCreate?: ServiceRequestCreateOrConnectWithoutStatusHistoryInput
    upsert?: ServiceRequestUpsertWithoutStatusHistoryInput
    connect?: ServiceRequestWhereUniqueInput
    update?: XOR<XOR<ServiceRequestUpdateToOneWithWhereWithoutStatusHistoryInput, ServiceRequestUpdateWithoutStatusHistoryInput>, ServiceRequestUncheckedUpdateWithoutStatusHistoryInput>
  }

  export type UserProfileCreateNestedOneWithoutWorkshopInput = {
    create?: XOR<UserProfileCreateWithoutWorkshopInput, UserProfileUncheckedCreateWithoutWorkshopInput>
    connectOrCreate?: UserProfileCreateOrConnectWithoutWorkshopInput
    connect?: UserProfileWhereUniqueInput
  }

  export type WorkshopCategoryCreateNestedManyWithoutWorkshopInput = {
    create?: XOR<WorkshopCategoryCreateWithoutWorkshopInput, WorkshopCategoryUncheckedCreateWithoutWorkshopInput> | WorkshopCategoryCreateWithoutWorkshopInput[] | WorkshopCategoryUncheckedCreateWithoutWorkshopInput[]
    connectOrCreate?: WorkshopCategoryCreateOrConnectWithoutWorkshopInput | WorkshopCategoryCreateOrConnectWithoutWorkshopInput[]
    createMany?: WorkshopCategoryCreateManyWorkshopInputEnvelope
    connect?: WorkshopCategoryWhereUniqueInput | WorkshopCategoryWhereUniqueInput[]
  }

  export type QuoteCreateNestedManyWithoutWorkshopInput = {
    create?: XOR<QuoteCreateWithoutWorkshopInput, QuoteUncheckedCreateWithoutWorkshopInput> | QuoteCreateWithoutWorkshopInput[] | QuoteUncheckedCreateWithoutWorkshopInput[]
    connectOrCreate?: QuoteCreateOrConnectWithoutWorkshopInput | QuoteCreateOrConnectWithoutWorkshopInput[]
    createMany?: QuoteCreateManyWorkshopInputEnvelope
    connect?: QuoteWhereUniqueInput | QuoteWhereUniqueInput[]
  }

  export type WorkOrderCreateNestedManyWithoutWorkshopInput = {
    create?: XOR<WorkOrderCreateWithoutWorkshopInput, WorkOrderUncheckedCreateWithoutWorkshopInput> | WorkOrderCreateWithoutWorkshopInput[] | WorkOrderUncheckedCreateWithoutWorkshopInput[]
    connectOrCreate?: WorkOrderCreateOrConnectWithoutWorkshopInput | WorkOrderCreateOrConnectWithoutWorkshopInput[]
    createMany?: WorkOrderCreateManyWorkshopInputEnvelope
    connect?: WorkOrderWhereUniqueInput | WorkOrderWhereUniqueInput[]
  }

  export type ReviewCreateNestedManyWithoutWorkshopInput = {
    create?: XOR<ReviewCreateWithoutWorkshopInput, ReviewUncheckedCreateWithoutWorkshopInput> | ReviewCreateWithoutWorkshopInput[] | ReviewUncheckedCreateWithoutWorkshopInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutWorkshopInput | ReviewCreateOrConnectWithoutWorkshopInput[]
    createMany?: ReviewCreateManyWorkshopInputEnvelope
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
  }

  export type IncidentReportCreateNestedManyWithoutWorkshopInput = {
    create?: XOR<IncidentReportCreateWithoutWorkshopInput, IncidentReportUncheckedCreateWithoutWorkshopInput> | IncidentReportCreateWithoutWorkshopInput[] | IncidentReportUncheckedCreateWithoutWorkshopInput[]
    connectOrCreate?: IncidentReportCreateOrConnectWithoutWorkshopInput | IncidentReportCreateOrConnectWithoutWorkshopInput[]
    createMany?: IncidentReportCreateManyWorkshopInputEnvelope
    connect?: IncidentReportWhereUniqueInput | IncidentReportWhereUniqueInput[]
  }

  export type WorkshopVerificationCreateNestedManyWithoutWorkshopInput = {
    create?: XOR<WorkshopVerificationCreateWithoutWorkshopInput, WorkshopVerificationUncheckedCreateWithoutWorkshopInput> | WorkshopVerificationCreateWithoutWorkshopInput[] | WorkshopVerificationUncheckedCreateWithoutWorkshopInput[]
    connectOrCreate?: WorkshopVerificationCreateOrConnectWithoutWorkshopInput | WorkshopVerificationCreateOrConnectWithoutWorkshopInput[]
    createMany?: WorkshopVerificationCreateManyWorkshopInputEnvelope
    connect?: WorkshopVerificationWhereUniqueInput | WorkshopVerificationWhereUniqueInput[]
  }

  export type WorkshopCategoryUncheckedCreateNestedManyWithoutWorkshopInput = {
    create?: XOR<WorkshopCategoryCreateWithoutWorkshopInput, WorkshopCategoryUncheckedCreateWithoutWorkshopInput> | WorkshopCategoryCreateWithoutWorkshopInput[] | WorkshopCategoryUncheckedCreateWithoutWorkshopInput[]
    connectOrCreate?: WorkshopCategoryCreateOrConnectWithoutWorkshopInput | WorkshopCategoryCreateOrConnectWithoutWorkshopInput[]
    createMany?: WorkshopCategoryCreateManyWorkshopInputEnvelope
    connect?: WorkshopCategoryWhereUniqueInput | WorkshopCategoryWhereUniqueInput[]
  }

  export type QuoteUncheckedCreateNestedManyWithoutWorkshopInput = {
    create?: XOR<QuoteCreateWithoutWorkshopInput, QuoteUncheckedCreateWithoutWorkshopInput> | QuoteCreateWithoutWorkshopInput[] | QuoteUncheckedCreateWithoutWorkshopInput[]
    connectOrCreate?: QuoteCreateOrConnectWithoutWorkshopInput | QuoteCreateOrConnectWithoutWorkshopInput[]
    createMany?: QuoteCreateManyWorkshopInputEnvelope
    connect?: QuoteWhereUniqueInput | QuoteWhereUniqueInput[]
  }

  export type WorkOrderUncheckedCreateNestedManyWithoutWorkshopInput = {
    create?: XOR<WorkOrderCreateWithoutWorkshopInput, WorkOrderUncheckedCreateWithoutWorkshopInput> | WorkOrderCreateWithoutWorkshopInput[] | WorkOrderUncheckedCreateWithoutWorkshopInput[]
    connectOrCreate?: WorkOrderCreateOrConnectWithoutWorkshopInput | WorkOrderCreateOrConnectWithoutWorkshopInput[]
    createMany?: WorkOrderCreateManyWorkshopInputEnvelope
    connect?: WorkOrderWhereUniqueInput | WorkOrderWhereUniqueInput[]
  }

  export type ReviewUncheckedCreateNestedManyWithoutWorkshopInput = {
    create?: XOR<ReviewCreateWithoutWorkshopInput, ReviewUncheckedCreateWithoutWorkshopInput> | ReviewCreateWithoutWorkshopInput[] | ReviewUncheckedCreateWithoutWorkshopInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutWorkshopInput | ReviewCreateOrConnectWithoutWorkshopInput[]
    createMany?: ReviewCreateManyWorkshopInputEnvelope
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
  }

  export type IncidentReportUncheckedCreateNestedManyWithoutWorkshopInput = {
    create?: XOR<IncidentReportCreateWithoutWorkshopInput, IncidentReportUncheckedCreateWithoutWorkshopInput> | IncidentReportCreateWithoutWorkshopInput[] | IncidentReportUncheckedCreateWithoutWorkshopInput[]
    connectOrCreate?: IncidentReportCreateOrConnectWithoutWorkshopInput | IncidentReportCreateOrConnectWithoutWorkshopInput[]
    createMany?: IncidentReportCreateManyWorkshopInputEnvelope
    connect?: IncidentReportWhereUniqueInput | IncidentReportWhereUniqueInput[]
  }

  export type WorkshopVerificationUncheckedCreateNestedManyWithoutWorkshopInput = {
    create?: XOR<WorkshopVerificationCreateWithoutWorkshopInput, WorkshopVerificationUncheckedCreateWithoutWorkshopInput> | WorkshopVerificationCreateWithoutWorkshopInput[] | WorkshopVerificationUncheckedCreateWithoutWorkshopInput[]
    connectOrCreate?: WorkshopVerificationCreateOrConnectWithoutWorkshopInput | WorkshopVerificationCreateOrConnectWithoutWorkshopInput[]
    createMany?: WorkshopVerificationCreateManyWorkshopInputEnvelope
    connect?: WorkshopVerificationWhereUniqueInput | WorkshopVerificationWhereUniqueInput[]
  }

  export type EnumWorkshopStatusFieldUpdateOperationsInput = {
    set?: $Enums.WorkshopStatus
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserProfileUpdateOneRequiredWithoutWorkshopNestedInput = {
    create?: XOR<UserProfileCreateWithoutWorkshopInput, UserProfileUncheckedCreateWithoutWorkshopInput>
    connectOrCreate?: UserProfileCreateOrConnectWithoutWorkshopInput
    upsert?: UserProfileUpsertWithoutWorkshopInput
    connect?: UserProfileWhereUniqueInput
    update?: XOR<XOR<UserProfileUpdateToOneWithWhereWithoutWorkshopInput, UserProfileUpdateWithoutWorkshopInput>, UserProfileUncheckedUpdateWithoutWorkshopInput>
  }

  export type WorkshopCategoryUpdateManyWithoutWorkshopNestedInput = {
    create?: XOR<WorkshopCategoryCreateWithoutWorkshopInput, WorkshopCategoryUncheckedCreateWithoutWorkshopInput> | WorkshopCategoryCreateWithoutWorkshopInput[] | WorkshopCategoryUncheckedCreateWithoutWorkshopInput[]
    connectOrCreate?: WorkshopCategoryCreateOrConnectWithoutWorkshopInput | WorkshopCategoryCreateOrConnectWithoutWorkshopInput[]
    upsert?: WorkshopCategoryUpsertWithWhereUniqueWithoutWorkshopInput | WorkshopCategoryUpsertWithWhereUniqueWithoutWorkshopInput[]
    createMany?: WorkshopCategoryCreateManyWorkshopInputEnvelope
    set?: WorkshopCategoryWhereUniqueInput | WorkshopCategoryWhereUniqueInput[]
    disconnect?: WorkshopCategoryWhereUniqueInput | WorkshopCategoryWhereUniqueInput[]
    delete?: WorkshopCategoryWhereUniqueInput | WorkshopCategoryWhereUniqueInput[]
    connect?: WorkshopCategoryWhereUniqueInput | WorkshopCategoryWhereUniqueInput[]
    update?: WorkshopCategoryUpdateWithWhereUniqueWithoutWorkshopInput | WorkshopCategoryUpdateWithWhereUniqueWithoutWorkshopInput[]
    updateMany?: WorkshopCategoryUpdateManyWithWhereWithoutWorkshopInput | WorkshopCategoryUpdateManyWithWhereWithoutWorkshopInput[]
    deleteMany?: WorkshopCategoryScalarWhereInput | WorkshopCategoryScalarWhereInput[]
  }

  export type QuoteUpdateManyWithoutWorkshopNestedInput = {
    create?: XOR<QuoteCreateWithoutWorkshopInput, QuoteUncheckedCreateWithoutWorkshopInput> | QuoteCreateWithoutWorkshopInput[] | QuoteUncheckedCreateWithoutWorkshopInput[]
    connectOrCreate?: QuoteCreateOrConnectWithoutWorkshopInput | QuoteCreateOrConnectWithoutWorkshopInput[]
    upsert?: QuoteUpsertWithWhereUniqueWithoutWorkshopInput | QuoteUpsertWithWhereUniqueWithoutWorkshopInput[]
    createMany?: QuoteCreateManyWorkshopInputEnvelope
    set?: QuoteWhereUniqueInput | QuoteWhereUniqueInput[]
    disconnect?: QuoteWhereUniqueInput | QuoteWhereUniqueInput[]
    delete?: QuoteWhereUniqueInput | QuoteWhereUniqueInput[]
    connect?: QuoteWhereUniqueInput | QuoteWhereUniqueInput[]
    update?: QuoteUpdateWithWhereUniqueWithoutWorkshopInput | QuoteUpdateWithWhereUniqueWithoutWorkshopInput[]
    updateMany?: QuoteUpdateManyWithWhereWithoutWorkshopInput | QuoteUpdateManyWithWhereWithoutWorkshopInput[]
    deleteMany?: QuoteScalarWhereInput | QuoteScalarWhereInput[]
  }

  export type WorkOrderUpdateManyWithoutWorkshopNestedInput = {
    create?: XOR<WorkOrderCreateWithoutWorkshopInput, WorkOrderUncheckedCreateWithoutWorkshopInput> | WorkOrderCreateWithoutWorkshopInput[] | WorkOrderUncheckedCreateWithoutWorkshopInput[]
    connectOrCreate?: WorkOrderCreateOrConnectWithoutWorkshopInput | WorkOrderCreateOrConnectWithoutWorkshopInput[]
    upsert?: WorkOrderUpsertWithWhereUniqueWithoutWorkshopInput | WorkOrderUpsertWithWhereUniqueWithoutWorkshopInput[]
    createMany?: WorkOrderCreateManyWorkshopInputEnvelope
    set?: WorkOrderWhereUniqueInput | WorkOrderWhereUniqueInput[]
    disconnect?: WorkOrderWhereUniqueInput | WorkOrderWhereUniqueInput[]
    delete?: WorkOrderWhereUniqueInput | WorkOrderWhereUniqueInput[]
    connect?: WorkOrderWhereUniqueInput | WorkOrderWhereUniqueInput[]
    update?: WorkOrderUpdateWithWhereUniqueWithoutWorkshopInput | WorkOrderUpdateWithWhereUniqueWithoutWorkshopInput[]
    updateMany?: WorkOrderUpdateManyWithWhereWithoutWorkshopInput | WorkOrderUpdateManyWithWhereWithoutWorkshopInput[]
    deleteMany?: WorkOrderScalarWhereInput | WorkOrderScalarWhereInput[]
  }

  export type ReviewUpdateManyWithoutWorkshopNestedInput = {
    create?: XOR<ReviewCreateWithoutWorkshopInput, ReviewUncheckedCreateWithoutWorkshopInput> | ReviewCreateWithoutWorkshopInput[] | ReviewUncheckedCreateWithoutWorkshopInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutWorkshopInput | ReviewCreateOrConnectWithoutWorkshopInput[]
    upsert?: ReviewUpsertWithWhereUniqueWithoutWorkshopInput | ReviewUpsertWithWhereUniqueWithoutWorkshopInput[]
    createMany?: ReviewCreateManyWorkshopInputEnvelope
    set?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    disconnect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    delete?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    update?: ReviewUpdateWithWhereUniqueWithoutWorkshopInput | ReviewUpdateWithWhereUniqueWithoutWorkshopInput[]
    updateMany?: ReviewUpdateManyWithWhereWithoutWorkshopInput | ReviewUpdateManyWithWhereWithoutWorkshopInput[]
    deleteMany?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
  }

  export type IncidentReportUpdateManyWithoutWorkshopNestedInput = {
    create?: XOR<IncidentReportCreateWithoutWorkshopInput, IncidentReportUncheckedCreateWithoutWorkshopInput> | IncidentReportCreateWithoutWorkshopInput[] | IncidentReportUncheckedCreateWithoutWorkshopInput[]
    connectOrCreate?: IncidentReportCreateOrConnectWithoutWorkshopInput | IncidentReportCreateOrConnectWithoutWorkshopInput[]
    upsert?: IncidentReportUpsertWithWhereUniqueWithoutWorkshopInput | IncidentReportUpsertWithWhereUniqueWithoutWorkshopInput[]
    createMany?: IncidentReportCreateManyWorkshopInputEnvelope
    set?: IncidentReportWhereUniqueInput | IncidentReportWhereUniqueInput[]
    disconnect?: IncidentReportWhereUniqueInput | IncidentReportWhereUniqueInput[]
    delete?: IncidentReportWhereUniqueInput | IncidentReportWhereUniqueInput[]
    connect?: IncidentReportWhereUniqueInput | IncidentReportWhereUniqueInput[]
    update?: IncidentReportUpdateWithWhereUniqueWithoutWorkshopInput | IncidentReportUpdateWithWhereUniqueWithoutWorkshopInput[]
    updateMany?: IncidentReportUpdateManyWithWhereWithoutWorkshopInput | IncidentReportUpdateManyWithWhereWithoutWorkshopInput[]
    deleteMany?: IncidentReportScalarWhereInput | IncidentReportScalarWhereInput[]
  }

  export type WorkshopVerificationUpdateManyWithoutWorkshopNestedInput = {
    create?: XOR<WorkshopVerificationCreateWithoutWorkshopInput, WorkshopVerificationUncheckedCreateWithoutWorkshopInput> | WorkshopVerificationCreateWithoutWorkshopInput[] | WorkshopVerificationUncheckedCreateWithoutWorkshopInput[]
    connectOrCreate?: WorkshopVerificationCreateOrConnectWithoutWorkshopInput | WorkshopVerificationCreateOrConnectWithoutWorkshopInput[]
    upsert?: WorkshopVerificationUpsertWithWhereUniqueWithoutWorkshopInput | WorkshopVerificationUpsertWithWhereUniqueWithoutWorkshopInput[]
    createMany?: WorkshopVerificationCreateManyWorkshopInputEnvelope
    set?: WorkshopVerificationWhereUniqueInput | WorkshopVerificationWhereUniqueInput[]
    disconnect?: WorkshopVerificationWhereUniqueInput | WorkshopVerificationWhereUniqueInput[]
    delete?: WorkshopVerificationWhereUniqueInput | WorkshopVerificationWhereUniqueInput[]
    connect?: WorkshopVerificationWhereUniqueInput | WorkshopVerificationWhereUniqueInput[]
    update?: WorkshopVerificationUpdateWithWhereUniqueWithoutWorkshopInput | WorkshopVerificationUpdateWithWhereUniqueWithoutWorkshopInput[]
    updateMany?: WorkshopVerificationUpdateManyWithWhereWithoutWorkshopInput | WorkshopVerificationUpdateManyWithWhereWithoutWorkshopInput[]
    deleteMany?: WorkshopVerificationScalarWhereInput | WorkshopVerificationScalarWhereInput[]
  }

  export type WorkshopCategoryUncheckedUpdateManyWithoutWorkshopNestedInput = {
    create?: XOR<WorkshopCategoryCreateWithoutWorkshopInput, WorkshopCategoryUncheckedCreateWithoutWorkshopInput> | WorkshopCategoryCreateWithoutWorkshopInput[] | WorkshopCategoryUncheckedCreateWithoutWorkshopInput[]
    connectOrCreate?: WorkshopCategoryCreateOrConnectWithoutWorkshopInput | WorkshopCategoryCreateOrConnectWithoutWorkshopInput[]
    upsert?: WorkshopCategoryUpsertWithWhereUniqueWithoutWorkshopInput | WorkshopCategoryUpsertWithWhereUniqueWithoutWorkshopInput[]
    createMany?: WorkshopCategoryCreateManyWorkshopInputEnvelope
    set?: WorkshopCategoryWhereUniqueInput | WorkshopCategoryWhereUniqueInput[]
    disconnect?: WorkshopCategoryWhereUniqueInput | WorkshopCategoryWhereUniqueInput[]
    delete?: WorkshopCategoryWhereUniqueInput | WorkshopCategoryWhereUniqueInput[]
    connect?: WorkshopCategoryWhereUniqueInput | WorkshopCategoryWhereUniqueInput[]
    update?: WorkshopCategoryUpdateWithWhereUniqueWithoutWorkshopInput | WorkshopCategoryUpdateWithWhereUniqueWithoutWorkshopInput[]
    updateMany?: WorkshopCategoryUpdateManyWithWhereWithoutWorkshopInput | WorkshopCategoryUpdateManyWithWhereWithoutWorkshopInput[]
    deleteMany?: WorkshopCategoryScalarWhereInput | WorkshopCategoryScalarWhereInput[]
  }

  export type QuoteUncheckedUpdateManyWithoutWorkshopNestedInput = {
    create?: XOR<QuoteCreateWithoutWorkshopInput, QuoteUncheckedCreateWithoutWorkshopInput> | QuoteCreateWithoutWorkshopInput[] | QuoteUncheckedCreateWithoutWorkshopInput[]
    connectOrCreate?: QuoteCreateOrConnectWithoutWorkshopInput | QuoteCreateOrConnectWithoutWorkshopInput[]
    upsert?: QuoteUpsertWithWhereUniqueWithoutWorkshopInput | QuoteUpsertWithWhereUniqueWithoutWorkshopInput[]
    createMany?: QuoteCreateManyWorkshopInputEnvelope
    set?: QuoteWhereUniqueInput | QuoteWhereUniqueInput[]
    disconnect?: QuoteWhereUniqueInput | QuoteWhereUniqueInput[]
    delete?: QuoteWhereUniqueInput | QuoteWhereUniqueInput[]
    connect?: QuoteWhereUniqueInput | QuoteWhereUniqueInput[]
    update?: QuoteUpdateWithWhereUniqueWithoutWorkshopInput | QuoteUpdateWithWhereUniqueWithoutWorkshopInput[]
    updateMany?: QuoteUpdateManyWithWhereWithoutWorkshopInput | QuoteUpdateManyWithWhereWithoutWorkshopInput[]
    deleteMany?: QuoteScalarWhereInput | QuoteScalarWhereInput[]
  }

  export type WorkOrderUncheckedUpdateManyWithoutWorkshopNestedInput = {
    create?: XOR<WorkOrderCreateWithoutWorkshopInput, WorkOrderUncheckedCreateWithoutWorkshopInput> | WorkOrderCreateWithoutWorkshopInput[] | WorkOrderUncheckedCreateWithoutWorkshopInput[]
    connectOrCreate?: WorkOrderCreateOrConnectWithoutWorkshopInput | WorkOrderCreateOrConnectWithoutWorkshopInput[]
    upsert?: WorkOrderUpsertWithWhereUniqueWithoutWorkshopInput | WorkOrderUpsertWithWhereUniqueWithoutWorkshopInput[]
    createMany?: WorkOrderCreateManyWorkshopInputEnvelope
    set?: WorkOrderWhereUniqueInput | WorkOrderWhereUniqueInput[]
    disconnect?: WorkOrderWhereUniqueInput | WorkOrderWhereUniqueInput[]
    delete?: WorkOrderWhereUniqueInput | WorkOrderWhereUniqueInput[]
    connect?: WorkOrderWhereUniqueInput | WorkOrderWhereUniqueInput[]
    update?: WorkOrderUpdateWithWhereUniqueWithoutWorkshopInput | WorkOrderUpdateWithWhereUniqueWithoutWorkshopInput[]
    updateMany?: WorkOrderUpdateManyWithWhereWithoutWorkshopInput | WorkOrderUpdateManyWithWhereWithoutWorkshopInput[]
    deleteMany?: WorkOrderScalarWhereInput | WorkOrderScalarWhereInput[]
  }

  export type ReviewUncheckedUpdateManyWithoutWorkshopNestedInput = {
    create?: XOR<ReviewCreateWithoutWorkshopInput, ReviewUncheckedCreateWithoutWorkshopInput> | ReviewCreateWithoutWorkshopInput[] | ReviewUncheckedCreateWithoutWorkshopInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutWorkshopInput | ReviewCreateOrConnectWithoutWorkshopInput[]
    upsert?: ReviewUpsertWithWhereUniqueWithoutWorkshopInput | ReviewUpsertWithWhereUniqueWithoutWorkshopInput[]
    createMany?: ReviewCreateManyWorkshopInputEnvelope
    set?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    disconnect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    delete?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    update?: ReviewUpdateWithWhereUniqueWithoutWorkshopInput | ReviewUpdateWithWhereUniqueWithoutWorkshopInput[]
    updateMany?: ReviewUpdateManyWithWhereWithoutWorkshopInput | ReviewUpdateManyWithWhereWithoutWorkshopInput[]
    deleteMany?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
  }

  export type IncidentReportUncheckedUpdateManyWithoutWorkshopNestedInput = {
    create?: XOR<IncidentReportCreateWithoutWorkshopInput, IncidentReportUncheckedCreateWithoutWorkshopInput> | IncidentReportCreateWithoutWorkshopInput[] | IncidentReportUncheckedCreateWithoutWorkshopInput[]
    connectOrCreate?: IncidentReportCreateOrConnectWithoutWorkshopInput | IncidentReportCreateOrConnectWithoutWorkshopInput[]
    upsert?: IncidentReportUpsertWithWhereUniqueWithoutWorkshopInput | IncidentReportUpsertWithWhereUniqueWithoutWorkshopInput[]
    createMany?: IncidentReportCreateManyWorkshopInputEnvelope
    set?: IncidentReportWhereUniqueInput | IncidentReportWhereUniqueInput[]
    disconnect?: IncidentReportWhereUniqueInput | IncidentReportWhereUniqueInput[]
    delete?: IncidentReportWhereUniqueInput | IncidentReportWhereUniqueInput[]
    connect?: IncidentReportWhereUniqueInput | IncidentReportWhereUniqueInput[]
    update?: IncidentReportUpdateWithWhereUniqueWithoutWorkshopInput | IncidentReportUpdateWithWhereUniqueWithoutWorkshopInput[]
    updateMany?: IncidentReportUpdateManyWithWhereWithoutWorkshopInput | IncidentReportUpdateManyWithWhereWithoutWorkshopInput[]
    deleteMany?: IncidentReportScalarWhereInput | IncidentReportScalarWhereInput[]
  }

  export type WorkshopVerificationUncheckedUpdateManyWithoutWorkshopNestedInput = {
    create?: XOR<WorkshopVerificationCreateWithoutWorkshopInput, WorkshopVerificationUncheckedCreateWithoutWorkshopInput> | WorkshopVerificationCreateWithoutWorkshopInput[] | WorkshopVerificationUncheckedCreateWithoutWorkshopInput[]
    connectOrCreate?: WorkshopVerificationCreateOrConnectWithoutWorkshopInput | WorkshopVerificationCreateOrConnectWithoutWorkshopInput[]
    upsert?: WorkshopVerificationUpsertWithWhereUniqueWithoutWorkshopInput | WorkshopVerificationUpsertWithWhereUniqueWithoutWorkshopInput[]
    createMany?: WorkshopVerificationCreateManyWorkshopInputEnvelope
    set?: WorkshopVerificationWhereUniqueInput | WorkshopVerificationWhereUniqueInput[]
    disconnect?: WorkshopVerificationWhereUniqueInput | WorkshopVerificationWhereUniqueInput[]
    delete?: WorkshopVerificationWhereUniqueInput | WorkshopVerificationWhereUniqueInput[]
    connect?: WorkshopVerificationWhereUniqueInput | WorkshopVerificationWhereUniqueInput[]
    update?: WorkshopVerificationUpdateWithWhereUniqueWithoutWorkshopInput | WorkshopVerificationUpdateWithWhereUniqueWithoutWorkshopInput[]
    updateMany?: WorkshopVerificationUpdateManyWithWhereWithoutWorkshopInput | WorkshopVerificationUpdateManyWithWhereWithoutWorkshopInput[]
    deleteMany?: WorkshopVerificationScalarWhereInput | WorkshopVerificationScalarWhereInput[]
  }

  export type WorkshopCreateNestedOneWithoutCategoriesInput = {
    create?: XOR<WorkshopCreateWithoutCategoriesInput, WorkshopUncheckedCreateWithoutCategoriesInput>
    connectOrCreate?: WorkshopCreateOrConnectWithoutCategoriesInput
    connect?: WorkshopWhereUniqueInput
  }

  export type CategoryCreateNestedOneWithoutWorkshopCategoriesInput = {
    create?: XOR<CategoryCreateWithoutWorkshopCategoriesInput, CategoryUncheckedCreateWithoutWorkshopCategoriesInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutWorkshopCategoriesInput
    connect?: CategoryWhereUniqueInput
  }

  export type WorkshopUpdateOneRequiredWithoutCategoriesNestedInput = {
    create?: XOR<WorkshopCreateWithoutCategoriesInput, WorkshopUncheckedCreateWithoutCategoriesInput>
    connectOrCreate?: WorkshopCreateOrConnectWithoutCategoriesInput
    upsert?: WorkshopUpsertWithoutCategoriesInput
    connect?: WorkshopWhereUniqueInput
    update?: XOR<XOR<WorkshopUpdateToOneWithWhereWithoutCategoriesInput, WorkshopUpdateWithoutCategoriesInput>, WorkshopUncheckedUpdateWithoutCategoriesInput>
  }

  export type CategoryUpdateOneRequiredWithoutWorkshopCategoriesNestedInput = {
    create?: XOR<CategoryCreateWithoutWorkshopCategoriesInput, CategoryUncheckedCreateWithoutWorkshopCategoriesInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutWorkshopCategoriesInput
    upsert?: CategoryUpsertWithoutWorkshopCategoriesInput
    connect?: CategoryWhereUniqueInput
    update?: XOR<XOR<CategoryUpdateToOneWithWhereWithoutWorkshopCategoriesInput, CategoryUpdateWithoutWorkshopCategoriesInput>, CategoryUncheckedUpdateWithoutWorkshopCategoriesInput>
  }

  export type WorkshopCreateNestedOneWithoutVerificationsInput = {
    create?: XOR<WorkshopCreateWithoutVerificationsInput, WorkshopUncheckedCreateWithoutVerificationsInput>
    connectOrCreate?: WorkshopCreateOrConnectWithoutVerificationsInput
    connect?: WorkshopWhereUniqueInput
  }

  export type WorkshopUpdateOneRequiredWithoutVerificationsNestedInput = {
    create?: XOR<WorkshopCreateWithoutVerificationsInput, WorkshopUncheckedCreateWithoutVerificationsInput>
    connectOrCreate?: WorkshopCreateOrConnectWithoutVerificationsInput
    upsert?: WorkshopUpsertWithoutVerificationsInput
    connect?: WorkshopWhereUniqueInput
    update?: XOR<XOR<WorkshopUpdateToOneWithWhereWithoutVerificationsInput, WorkshopUpdateWithoutVerificationsInput>, WorkshopUncheckedUpdateWithoutVerificationsInput>
  }

  export type ServiceRequestCreateNestedOneWithoutQuotesInput = {
    create?: XOR<ServiceRequestCreateWithoutQuotesInput, ServiceRequestUncheckedCreateWithoutQuotesInput>
    connectOrCreate?: ServiceRequestCreateOrConnectWithoutQuotesInput
    connect?: ServiceRequestWhereUniqueInput
  }

  export type WorkshopCreateNestedOneWithoutQuotesInput = {
    create?: XOR<WorkshopCreateWithoutQuotesInput, WorkshopUncheckedCreateWithoutQuotesInput>
    connectOrCreate?: WorkshopCreateOrConnectWithoutQuotesInput
    connect?: WorkshopWhereUniqueInput
  }

  export type QuotePartItemCreateNestedManyWithoutQuoteInput = {
    create?: XOR<QuotePartItemCreateWithoutQuoteInput, QuotePartItemUncheckedCreateWithoutQuoteInput> | QuotePartItemCreateWithoutQuoteInput[] | QuotePartItemUncheckedCreateWithoutQuoteInput[]
    connectOrCreate?: QuotePartItemCreateOrConnectWithoutQuoteInput | QuotePartItemCreateOrConnectWithoutQuoteInput[]
    createMany?: QuotePartItemCreateManyQuoteInputEnvelope
    connect?: QuotePartItemWhereUniqueInput | QuotePartItemWhereUniqueInput[]
  }

  export type WorkOrderCreateNestedOneWithoutQuoteInput = {
    create?: XOR<WorkOrderCreateWithoutQuoteInput, WorkOrderUncheckedCreateWithoutQuoteInput>
    connectOrCreate?: WorkOrderCreateOrConnectWithoutQuoteInput
    connect?: WorkOrderWhereUniqueInput
  }

  export type AiQuoteAnalysisCreateNestedManyWithoutQuoteInput = {
    create?: XOR<AiQuoteAnalysisCreateWithoutQuoteInput, AiQuoteAnalysisUncheckedCreateWithoutQuoteInput> | AiQuoteAnalysisCreateWithoutQuoteInput[] | AiQuoteAnalysisUncheckedCreateWithoutQuoteInput[]
    connectOrCreate?: AiQuoteAnalysisCreateOrConnectWithoutQuoteInput | AiQuoteAnalysisCreateOrConnectWithoutQuoteInput[]
    createMany?: AiQuoteAnalysisCreateManyQuoteInputEnvelope
    connect?: AiQuoteAnalysisWhereUniqueInput | AiQuoteAnalysisWhereUniqueInput[]
  }

  export type QuotePartItemUncheckedCreateNestedManyWithoutQuoteInput = {
    create?: XOR<QuotePartItemCreateWithoutQuoteInput, QuotePartItemUncheckedCreateWithoutQuoteInput> | QuotePartItemCreateWithoutQuoteInput[] | QuotePartItemUncheckedCreateWithoutQuoteInput[]
    connectOrCreate?: QuotePartItemCreateOrConnectWithoutQuoteInput | QuotePartItemCreateOrConnectWithoutQuoteInput[]
    createMany?: QuotePartItemCreateManyQuoteInputEnvelope
    connect?: QuotePartItemWhereUniqueInput | QuotePartItemWhereUniqueInput[]
  }

  export type WorkOrderUncheckedCreateNestedOneWithoutQuoteInput = {
    create?: XOR<WorkOrderCreateWithoutQuoteInput, WorkOrderUncheckedCreateWithoutQuoteInput>
    connectOrCreate?: WorkOrderCreateOrConnectWithoutQuoteInput
    connect?: WorkOrderWhereUniqueInput
  }

  export type AiQuoteAnalysisUncheckedCreateNestedManyWithoutQuoteInput = {
    create?: XOR<AiQuoteAnalysisCreateWithoutQuoteInput, AiQuoteAnalysisUncheckedCreateWithoutQuoteInput> | AiQuoteAnalysisCreateWithoutQuoteInput[] | AiQuoteAnalysisUncheckedCreateWithoutQuoteInput[]
    connectOrCreate?: AiQuoteAnalysisCreateOrConnectWithoutQuoteInput | AiQuoteAnalysisCreateOrConnectWithoutQuoteInput[]
    createMany?: AiQuoteAnalysisCreateManyQuoteInputEnvelope
    connect?: AiQuoteAnalysisWhereUniqueInput | AiQuoteAnalysisWhereUniqueInput[]
  }

  export type EnumQuoteStatusFieldUpdateOperationsInput = {
    set?: $Enums.QuoteStatus
  }

  export type ServiceRequestUpdateOneRequiredWithoutQuotesNestedInput = {
    create?: XOR<ServiceRequestCreateWithoutQuotesInput, ServiceRequestUncheckedCreateWithoutQuotesInput>
    connectOrCreate?: ServiceRequestCreateOrConnectWithoutQuotesInput
    upsert?: ServiceRequestUpsertWithoutQuotesInput
    connect?: ServiceRequestWhereUniqueInput
    update?: XOR<XOR<ServiceRequestUpdateToOneWithWhereWithoutQuotesInput, ServiceRequestUpdateWithoutQuotesInput>, ServiceRequestUncheckedUpdateWithoutQuotesInput>
  }

  export type WorkshopUpdateOneRequiredWithoutQuotesNestedInput = {
    create?: XOR<WorkshopCreateWithoutQuotesInput, WorkshopUncheckedCreateWithoutQuotesInput>
    connectOrCreate?: WorkshopCreateOrConnectWithoutQuotesInput
    upsert?: WorkshopUpsertWithoutQuotesInput
    connect?: WorkshopWhereUniqueInput
    update?: XOR<XOR<WorkshopUpdateToOneWithWhereWithoutQuotesInput, WorkshopUpdateWithoutQuotesInput>, WorkshopUncheckedUpdateWithoutQuotesInput>
  }

  export type QuotePartItemUpdateManyWithoutQuoteNestedInput = {
    create?: XOR<QuotePartItemCreateWithoutQuoteInput, QuotePartItemUncheckedCreateWithoutQuoteInput> | QuotePartItemCreateWithoutQuoteInput[] | QuotePartItemUncheckedCreateWithoutQuoteInput[]
    connectOrCreate?: QuotePartItemCreateOrConnectWithoutQuoteInput | QuotePartItemCreateOrConnectWithoutQuoteInput[]
    upsert?: QuotePartItemUpsertWithWhereUniqueWithoutQuoteInput | QuotePartItemUpsertWithWhereUniqueWithoutQuoteInput[]
    createMany?: QuotePartItemCreateManyQuoteInputEnvelope
    set?: QuotePartItemWhereUniqueInput | QuotePartItemWhereUniqueInput[]
    disconnect?: QuotePartItemWhereUniqueInput | QuotePartItemWhereUniqueInput[]
    delete?: QuotePartItemWhereUniqueInput | QuotePartItemWhereUniqueInput[]
    connect?: QuotePartItemWhereUniqueInput | QuotePartItemWhereUniqueInput[]
    update?: QuotePartItemUpdateWithWhereUniqueWithoutQuoteInput | QuotePartItemUpdateWithWhereUniqueWithoutQuoteInput[]
    updateMany?: QuotePartItemUpdateManyWithWhereWithoutQuoteInput | QuotePartItemUpdateManyWithWhereWithoutQuoteInput[]
    deleteMany?: QuotePartItemScalarWhereInput | QuotePartItemScalarWhereInput[]
  }

  export type WorkOrderUpdateOneWithoutQuoteNestedInput = {
    create?: XOR<WorkOrderCreateWithoutQuoteInput, WorkOrderUncheckedCreateWithoutQuoteInput>
    connectOrCreate?: WorkOrderCreateOrConnectWithoutQuoteInput
    upsert?: WorkOrderUpsertWithoutQuoteInput
    disconnect?: WorkOrderWhereInput | boolean
    delete?: WorkOrderWhereInput | boolean
    connect?: WorkOrderWhereUniqueInput
    update?: XOR<XOR<WorkOrderUpdateToOneWithWhereWithoutQuoteInput, WorkOrderUpdateWithoutQuoteInput>, WorkOrderUncheckedUpdateWithoutQuoteInput>
  }

  export type AiQuoteAnalysisUpdateManyWithoutQuoteNestedInput = {
    create?: XOR<AiQuoteAnalysisCreateWithoutQuoteInput, AiQuoteAnalysisUncheckedCreateWithoutQuoteInput> | AiQuoteAnalysisCreateWithoutQuoteInput[] | AiQuoteAnalysisUncheckedCreateWithoutQuoteInput[]
    connectOrCreate?: AiQuoteAnalysisCreateOrConnectWithoutQuoteInput | AiQuoteAnalysisCreateOrConnectWithoutQuoteInput[]
    upsert?: AiQuoteAnalysisUpsertWithWhereUniqueWithoutQuoteInput | AiQuoteAnalysisUpsertWithWhereUniqueWithoutQuoteInput[]
    createMany?: AiQuoteAnalysisCreateManyQuoteInputEnvelope
    set?: AiQuoteAnalysisWhereUniqueInput | AiQuoteAnalysisWhereUniqueInput[]
    disconnect?: AiQuoteAnalysisWhereUniqueInput | AiQuoteAnalysisWhereUniqueInput[]
    delete?: AiQuoteAnalysisWhereUniqueInput | AiQuoteAnalysisWhereUniqueInput[]
    connect?: AiQuoteAnalysisWhereUniqueInput | AiQuoteAnalysisWhereUniqueInput[]
    update?: AiQuoteAnalysisUpdateWithWhereUniqueWithoutQuoteInput | AiQuoteAnalysisUpdateWithWhereUniqueWithoutQuoteInput[]
    updateMany?: AiQuoteAnalysisUpdateManyWithWhereWithoutQuoteInput | AiQuoteAnalysisUpdateManyWithWhereWithoutQuoteInput[]
    deleteMany?: AiQuoteAnalysisScalarWhereInput | AiQuoteAnalysisScalarWhereInput[]
  }

  export type QuotePartItemUncheckedUpdateManyWithoutQuoteNestedInput = {
    create?: XOR<QuotePartItemCreateWithoutQuoteInput, QuotePartItemUncheckedCreateWithoutQuoteInput> | QuotePartItemCreateWithoutQuoteInput[] | QuotePartItemUncheckedCreateWithoutQuoteInput[]
    connectOrCreate?: QuotePartItemCreateOrConnectWithoutQuoteInput | QuotePartItemCreateOrConnectWithoutQuoteInput[]
    upsert?: QuotePartItemUpsertWithWhereUniqueWithoutQuoteInput | QuotePartItemUpsertWithWhereUniqueWithoutQuoteInput[]
    createMany?: QuotePartItemCreateManyQuoteInputEnvelope
    set?: QuotePartItemWhereUniqueInput | QuotePartItemWhereUniqueInput[]
    disconnect?: QuotePartItemWhereUniqueInput | QuotePartItemWhereUniqueInput[]
    delete?: QuotePartItemWhereUniqueInput | QuotePartItemWhereUniqueInput[]
    connect?: QuotePartItemWhereUniqueInput | QuotePartItemWhereUniqueInput[]
    update?: QuotePartItemUpdateWithWhereUniqueWithoutQuoteInput | QuotePartItemUpdateWithWhereUniqueWithoutQuoteInput[]
    updateMany?: QuotePartItemUpdateManyWithWhereWithoutQuoteInput | QuotePartItemUpdateManyWithWhereWithoutQuoteInput[]
    deleteMany?: QuotePartItemScalarWhereInput | QuotePartItemScalarWhereInput[]
  }

  export type WorkOrderUncheckedUpdateOneWithoutQuoteNestedInput = {
    create?: XOR<WorkOrderCreateWithoutQuoteInput, WorkOrderUncheckedCreateWithoutQuoteInput>
    connectOrCreate?: WorkOrderCreateOrConnectWithoutQuoteInput
    upsert?: WorkOrderUpsertWithoutQuoteInput
    disconnect?: WorkOrderWhereInput | boolean
    delete?: WorkOrderWhereInput | boolean
    connect?: WorkOrderWhereUniqueInput
    update?: XOR<XOR<WorkOrderUpdateToOneWithWhereWithoutQuoteInput, WorkOrderUpdateWithoutQuoteInput>, WorkOrderUncheckedUpdateWithoutQuoteInput>
  }

  export type AiQuoteAnalysisUncheckedUpdateManyWithoutQuoteNestedInput = {
    create?: XOR<AiQuoteAnalysisCreateWithoutQuoteInput, AiQuoteAnalysisUncheckedCreateWithoutQuoteInput> | AiQuoteAnalysisCreateWithoutQuoteInput[] | AiQuoteAnalysisUncheckedCreateWithoutQuoteInput[]
    connectOrCreate?: AiQuoteAnalysisCreateOrConnectWithoutQuoteInput | AiQuoteAnalysisCreateOrConnectWithoutQuoteInput[]
    upsert?: AiQuoteAnalysisUpsertWithWhereUniqueWithoutQuoteInput | AiQuoteAnalysisUpsertWithWhereUniqueWithoutQuoteInput[]
    createMany?: AiQuoteAnalysisCreateManyQuoteInputEnvelope
    set?: AiQuoteAnalysisWhereUniqueInput | AiQuoteAnalysisWhereUniqueInput[]
    disconnect?: AiQuoteAnalysisWhereUniqueInput | AiQuoteAnalysisWhereUniqueInput[]
    delete?: AiQuoteAnalysisWhereUniqueInput | AiQuoteAnalysisWhereUniqueInput[]
    connect?: AiQuoteAnalysisWhereUniqueInput | AiQuoteAnalysisWhereUniqueInput[]
    update?: AiQuoteAnalysisUpdateWithWhereUniqueWithoutQuoteInput | AiQuoteAnalysisUpdateWithWhereUniqueWithoutQuoteInput[]
    updateMany?: AiQuoteAnalysisUpdateManyWithWhereWithoutQuoteInput | AiQuoteAnalysisUpdateManyWithWhereWithoutQuoteInput[]
    deleteMany?: AiQuoteAnalysisScalarWhereInput | AiQuoteAnalysisScalarWhereInput[]
  }

  export type QuoteCreateNestedOneWithoutPartsInput = {
    create?: XOR<QuoteCreateWithoutPartsInput, QuoteUncheckedCreateWithoutPartsInput>
    connectOrCreate?: QuoteCreateOrConnectWithoutPartsInput
    connect?: QuoteWhereUniqueInput
  }

  export type EnumPartTypeFieldUpdateOperationsInput = {
    set?: $Enums.PartType
  }

  export type NullableEnumPartTypeFieldUpdateOperationsInput = {
    set?: $Enums.PartType | null
  }

  export type QuoteUpdateOneRequiredWithoutPartsNestedInput = {
    create?: XOR<QuoteCreateWithoutPartsInput, QuoteUncheckedCreateWithoutPartsInput>
    connectOrCreate?: QuoteCreateOrConnectWithoutPartsInput
    upsert?: QuoteUpsertWithoutPartsInput
    connect?: QuoteWhereUniqueInput
    update?: XOR<XOR<QuoteUpdateToOneWithWhereWithoutPartsInput, QuoteUpdateWithoutPartsInput>, QuoteUncheckedUpdateWithoutPartsInput>
  }

  export type ServiceRequestCreateNestedOneWithoutWorkOrderInput = {
    create?: XOR<ServiceRequestCreateWithoutWorkOrderInput, ServiceRequestUncheckedCreateWithoutWorkOrderInput>
    connectOrCreate?: ServiceRequestCreateOrConnectWithoutWorkOrderInput
    connect?: ServiceRequestWhereUniqueInput
  }

  export type QuoteCreateNestedOneWithoutWorkOrderInput = {
    create?: XOR<QuoteCreateWithoutWorkOrderInput, QuoteUncheckedCreateWithoutWorkOrderInput>
    connectOrCreate?: QuoteCreateOrConnectWithoutWorkOrderInput
    connect?: QuoteWhereUniqueInput
  }

  export type WorkshopCreateNestedOneWithoutWorkOrdersInput = {
    create?: XOR<WorkshopCreateWithoutWorkOrdersInput, WorkshopUncheckedCreateWithoutWorkOrdersInput>
    connectOrCreate?: WorkshopCreateOrConnectWithoutWorkOrdersInput
    connect?: WorkshopWhereUniqueInput
  }

  export type ChangeRequestCreateNestedManyWithoutWorkOrderInput = {
    create?: XOR<ChangeRequestCreateWithoutWorkOrderInput, ChangeRequestUncheckedCreateWithoutWorkOrderInput> | ChangeRequestCreateWithoutWorkOrderInput[] | ChangeRequestUncheckedCreateWithoutWorkOrderInput[]
    connectOrCreate?: ChangeRequestCreateOrConnectWithoutWorkOrderInput | ChangeRequestCreateOrConnectWithoutWorkOrderInput[]
    createMany?: ChangeRequestCreateManyWorkOrderInputEnvelope
    connect?: ChangeRequestWhereUniqueInput | ChangeRequestWhereUniqueInput[]
  }

  export type EvidenceCreateNestedManyWithoutWorkOrderInput = {
    create?: XOR<EvidenceCreateWithoutWorkOrderInput, EvidenceUncheckedCreateWithoutWorkOrderInput> | EvidenceCreateWithoutWorkOrderInput[] | EvidenceUncheckedCreateWithoutWorkOrderInput[]
    connectOrCreate?: EvidenceCreateOrConnectWithoutWorkOrderInput | EvidenceCreateOrConnectWithoutWorkOrderInput[]
    createMany?: EvidenceCreateManyWorkOrderInputEnvelope
    connect?: EvidenceWhereUniqueInput | EvidenceWhereUniqueInput[]
  }

  export type ReviewCreateNestedOneWithoutWorkOrderInput = {
    create?: XOR<ReviewCreateWithoutWorkOrderInput, ReviewUncheckedCreateWithoutWorkOrderInput>
    connectOrCreate?: ReviewCreateOrConnectWithoutWorkOrderInput
    connect?: ReviewWhereUniqueInput
  }

  export type ReceiptCreateNestedOneWithoutWorkOrderInput = {
    create?: XOR<ReceiptCreateWithoutWorkOrderInput, ReceiptUncheckedCreateWithoutWorkOrderInput>
    connectOrCreate?: ReceiptCreateOrConnectWithoutWorkOrderInput
    connect?: ReceiptWhereUniqueInput
  }

  export type ChangeRequestUncheckedCreateNestedManyWithoutWorkOrderInput = {
    create?: XOR<ChangeRequestCreateWithoutWorkOrderInput, ChangeRequestUncheckedCreateWithoutWorkOrderInput> | ChangeRequestCreateWithoutWorkOrderInput[] | ChangeRequestUncheckedCreateWithoutWorkOrderInput[]
    connectOrCreate?: ChangeRequestCreateOrConnectWithoutWorkOrderInput | ChangeRequestCreateOrConnectWithoutWorkOrderInput[]
    createMany?: ChangeRequestCreateManyWorkOrderInputEnvelope
    connect?: ChangeRequestWhereUniqueInput | ChangeRequestWhereUniqueInput[]
  }

  export type EvidenceUncheckedCreateNestedManyWithoutWorkOrderInput = {
    create?: XOR<EvidenceCreateWithoutWorkOrderInput, EvidenceUncheckedCreateWithoutWorkOrderInput> | EvidenceCreateWithoutWorkOrderInput[] | EvidenceUncheckedCreateWithoutWorkOrderInput[]
    connectOrCreate?: EvidenceCreateOrConnectWithoutWorkOrderInput | EvidenceCreateOrConnectWithoutWorkOrderInput[]
    createMany?: EvidenceCreateManyWorkOrderInputEnvelope
    connect?: EvidenceWhereUniqueInput | EvidenceWhereUniqueInput[]
  }

  export type ReviewUncheckedCreateNestedOneWithoutWorkOrderInput = {
    create?: XOR<ReviewCreateWithoutWorkOrderInput, ReviewUncheckedCreateWithoutWorkOrderInput>
    connectOrCreate?: ReviewCreateOrConnectWithoutWorkOrderInput
    connect?: ReviewWhereUniqueInput
  }

  export type ReceiptUncheckedCreateNestedOneWithoutWorkOrderInput = {
    create?: XOR<ReceiptCreateWithoutWorkOrderInput, ReceiptUncheckedCreateWithoutWorkOrderInput>
    connectOrCreate?: ReceiptCreateOrConnectWithoutWorkOrderInput
    connect?: ReceiptWhereUniqueInput
  }

  export type EnumWorkOrderStatusFieldUpdateOperationsInput = {
    set?: $Enums.WorkOrderStatus
  }

  export type ServiceRequestUpdateOneRequiredWithoutWorkOrderNestedInput = {
    create?: XOR<ServiceRequestCreateWithoutWorkOrderInput, ServiceRequestUncheckedCreateWithoutWorkOrderInput>
    connectOrCreate?: ServiceRequestCreateOrConnectWithoutWorkOrderInput
    upsert?: ServiceRequestUpsertWithoutWorkOrderInput
    connect?: ServiceRequestWhereUniqueInput
    update?: XOR<XOR<ServiceRequestUpdateToOneWithWhereWithoutWorkOrderInput, ServiceRequestUpdateWithoutWorkOrderInput>, ServiceRequestUncheckedUpdateWithoutWorkOrderInput>
  }

  export type QuoteUpdateOneRequiredWithoutWorkOrderNestedInput = {
    create?: XOR<QuoteCreateWithoutWorkOrderInput, QuoteUncheckedCreateWithoutWorkOrderInput>
    connectOrCreate?: QuoteCreateOrConnectWithoutWorkOrderInput
    upsert?: QuoteUpsertWithoutWorkOrderInput
    connect?: QuoteWhereUniqueInput
    update?: XOR<XOR<QuoteUpdateToOneWithWhereWithoutWorkOrderInput, QuoteUpdateWithoutWorkOrderInput>, QuoteUncheckedUpdateWithoutWorkOrderInput>
  }

  export type WorkshopUpdateOneRequiredWithoutWorkOrdersNestedInput = {
    create?: XOR<WorkshopCreateWithoutWorkOrdersInput, WorkshopUncheckedCreateWithoutWorkOrdersInput>
    connectOrCreate?: WorkshopCreateOrConnectWithoutWorkOrdersInput
    upsert?: WorkshopUpsertWithoutWorkOrdersInput
    connect?: WorkshopWhereUniqueInput
    update?: XOR<XOR<WorkshopUpdateToOneWithWhereWithoutWorkOrdersInput, WorkshopUpdateWithoutWorkOrdersInput>, WorkshopUncheckedUpdateWithoutWorkOrdersInput>
  }

  export type ChangeRequestUpdateManyWithoutWorkOrderNestedInput = {
    create?: XOR<ChangeRequestCreateWithoutWorkOrderInput, ChangeRequestUncheckedCreateWithoutWorkOrderInput> | ChangeRequestCreateWithoutWorkOrderInput[] | ChangeRequestUncheckedCreateWithoutWorkOrderInput[]
    connectOrCreate?: ChangeRequestCreateOrConnectWithoutWorkOrderInput | ChangeRequestCreateOrConnectWithoutWorkOrderInput[]
    upsert?: ChangeRequestUpsertWithWhereUniqueWithoutWorkOrderInput | ChangeRequestUpsertWithWhereUniqueWithoutWorkOrderInput[]
    createMany?: ChangeRequestCreateManyWorkOrderInputEnvelope
    set?: ChangeRequestWhereUniqueInput | ChangeRequestWhereUniqueInput[]
    disconnect?: ChangeRequestWhereUniqueInput | ChangeRequestWhereUniqueInput[]
    delete?: ChangeRequestWhereUniqueInput | ChangeRequestWhereUniqueInput[]
    connect?: ChangeRequestWhereUniqueInput | ChangeRequestWhereUniqueInput[]
    update?: ChangeRequestUpdateWithWhereUniqueWithoutWorkOrderInput | ChangeRequestUpdateWithWhereUniqueWithoutWorkOrderInput[]
    updateMany?: ChangeRequestUpdateManyWithWhereWithoutWorkOrderInput | ChangeRequestUpdateManyWithWhereWithoutWorkOrderInput[]
    deleteMany?: ChangeRequestScalarWhereInput | ChangeRequestScalarWhereInput[]
  }

  export type EvidenceUpdateManyWithoutWorkOrderNestedInput = {
    create?: XOR<EvidenceCreateWithoutWorkOrderInput, EvidenceUncheckedCreateWithoutWorkOrderInput> | EvidenceCreateWithoutWorkOrderInput[] | EvidenceUncheckedCreateWithoutWorkOrderInput[]
    connectOrCreate?: EvidenceCreateOrConnectWithoutWorkOrderInput | EvidenceCreateOrConnectWithoutWorkOrderInput[]
    upsert?: EvidenceUpsertWithWhereUniqueWithoutWorkOrderInput | EvidenceUpsertWithWhereUniqueWithoutWorkOrderInput[]
    createMany?: EvidenceCreateManyWorkOrderInputEnvelope
    set?: EvidenceWhereUniqueInput | EvidenceWhereUniqueInput[]
    disconnect?: EvidenceWhereUniqueInput | EvidenceWhereUniqueInput[]
    delete?: EvidenceWhereUniqueInput | EvidenceWhereUniqueInput[]
    connect?: EvidenceWhereUniqueInput | EvidenceWhereUniqueInput[]
    update?: EvidenceUpdateWithWhereUniqueWithoutWorkOrderInput | EvidenceUpdateWithWhereUniqueWithoutWorkOrderInput[]
    updateMany?: EvidenceUpdateManyWithWhereWithoutWorkOrderInput | EvidenceUpdateManyWithWhereWithoutWorkOrderInput[]
    deleteMany?: EvidenceScalarWhereInput | EvidenceScalarWhereInput[]
  }

  export type ReviewUpdateOneWithoutWorkOrderNestedInput = {
    create?: XOR<ReviewCreateWithoutWorkOrderInput, ReviewUncheckedCreateWithoutWorkOrderInput>
    connectOrCreate?: ReviewCreateOrConnectWithoutWorkOrderInput
    upsert?: ReviewUpsertWithoutWorkOrderInput
    disconnect?: ReviewWhereInput | boolean
    delete?: ReviewWhereInput | boolean
    connect?: ReviewWhereUniqueInput
    update?: XOR<XOR<ReviewUpdateToOneWithWhereWithoutWorkOrderInput, ReviewUpdateWithoutWorkOrderInput>, ReviewUncheckedUpdateWithoutWorkOrderInput>
  }

  export type ReceiptUpdateOneWithoutWorkOrderNestedInput = {
    create?: XOR<ReceiptCreateWithoutWorkOrderInput, ReceiptUncheckedCreateWithoutWorkOrderInput>
    connectOrCreate?: ReceiptCreateOrConnectWithoutWorkOrderInput
    upsert?: ReceiptUpsertWithoutWorkOrderInput
    disconnect?: ReceiptWhereInput | boolean
    delete?: ReceiptWhereInput | boolean
    connect?: ReceiptWhereUniqueInput
    update?: XOR<XOR<ReceiptUpdateToOneWithWhereWithoutWorkOrderInput, ReceiptUpdateWithoutWorkOrderInput>, ReceiptUncheckedUpdateWithoutWorkOrderInput>
  }

  export type ChangeRequestUncheckedUpdateManyWithoutWorkOrderNestedInput = {
    create?: XOR<ChangeRequestCreateWithoutWorkOrderInput, ChangeRequestUncheckedCreateWithoutWorkOrderInput> | ChangeRequestCreateWithoutWorkOrderInput[] | ChangeRequestUncheckedCreateWithoutWorkOrderInput[]
    connectOrCreate?: ChangeRequestCreateOrConnectWithoutWorkOrderInput | ChangeRequestCreateOrConnectWithoutWorkOrderInput[]
    upsert?: ChangeRequestUpsertWithWhereUniqueWithoutWorkOrderInput | ChangeRequestUpsertWithWhereUniqueWithoutWorkOrderInput[]
    createMany?: ChangeRequestCreateManyWorkOrderInputEnvelope
    set?: ChangeRequestWhereUniqueInput | ChangeRequestWhereUniqueInput[]
    disconnect?: ChangeRequestWhereUniqueInput | ChangeRequestWhereUniqueInput[]
    delete?: ChangeRequestWhereUniqueInput | ChangeRequestWhereUniqueInput[]
    connect?: ChangeRequestWhereUniqueInput | ChangeRequestWhereUniqueInput[]
    update?: ChangeRequestUpdateWithWhereUniqueWithoutWorkOrderInput | ChangeRequestUpdateWithWhereUniqueWithoutWorkOrderInput[]
    updateMany?: ChangeRequestUpdateManyWithWhereWithoutWorkOrderInput | ChangeRequestUpdateManyWithWhereWithoutWorkOrderInput[]
    deleteMany?: ChangeRequestScalarWhereInput | ChangeRequestScalarWhereInput[]
  }

  export type EvidenceUncheckedUpdateManyWithoutWorkOrderNestedInput = {
    create?: XOR<EvidenceCreateWithoutWorkOrderInput, EvidenceUncheckedCreateWithoutWorkOrderInput> | EvidenceCreateWithoutWorkOrderInput[] | EvidenceUncheckedCreateWithoutWorkOrderInput[]
    connectOrCreate?: EvidenceCreateOrConnectWithoutWorkOrderInput | EvidenceCreateOrConnectWithoutWorkOrderInput[]
    upsert?: EvidenceUpsertWithWhereUniqueWithoutWorkOrderInput | EvidenceUpsertWithWhereUniqueWithoutWorkOrderInput[]
    createMany?: EvidenceCreateManyWorkOrderInputEnvelope
    set?: EvidenceWhereUniqueInput | EvidenceWhereUniqueInput[]
    disconnect?: EvidenceWhereUniqueInput | EvidenceWhereUniqueInput[]
    delete?: EvidenceWhereUniqueInput | EvidenceWhereUniqueInput[]
    connect?: EvidenceWhereUniqueInput | EvidenceWhereUniqueInput[]
    update?: EvidenceUpdateWithWhereUniqueWithoutWorkOrderInput | EvidenceUpdateWithWhereUniqueWithoutWorkOrderInput[]
    updateMany?: EvidenceUpdateManyWithWhereWithoutWorkOrderInput | EvidenceUpdateManyWithWhereWithoutWorkOrderInput[]
    deleteMany?: EvidenceScalarWhereInput | EvidenceScalarWhereInput[]
  }

  export type ReviewUncheckedUpdateOneWithoutWorkOrderNestedInput = {
    create?: XOR<ReviewCreateWithoutWorkOrderInput, ReviewUncheckedCreateWithoutWorkOrderInput>
    connectOrCreate?: ReviewCreateOrConnectWithoutWorkOrderInput
    upsert?: ReviewUpsertWithoutWorkOrderInput
    disconnect?: ReviewWhereInput | boolean
    delete?: ReviewWhereInput | boolean
    connect?: ReviewWhereUniqueInput
    update?: XOR<XOR<ReviewUpdateToOneWithWhereWithoutWorkOrderInput, ReviewUpdateWithoutWorkOrderInput>, ReviewUncheckedUpdateWithoutWorkOrderInput>
  }

  export type ReceiptUncheckedUpdateOneWithoutWorkOrderNestedInput = {
    create?: XOR<ReceiptCreateWithoutWorkOrderInput, ReceiptUncheckedCreateWithoutWorkOrderInput>
    connectOrCreate?: ReceiptCreateOrConnectWithoutWorkOrderInput
    upsert?: ReceiptUpsertWithoutWorkOrderInput
    disconnect?: ReceiptWhereInput | boolean
    delete?: ReceiptWhereInput | boolean
    connect?: ReceiptWhereUniqueInput
    update?: XOR<XOR<ReceiptUpdateToOneWithWhereWithoutWorkOrderInput, ReceiptUpdateWithoutWorkOrderInput>, ReceiptUncheckedUpdateWithoutWorkOrderInput>
  }

  export type WorkOrderCreateNestedOneWithoutChangeRequestsInput = {
    create?: XOR<WorkOrderCreateWithoutChangeRequestsInput, WorkOrderUncheckedCreateWithoutChangeRequestsInput>
    connectOrCreate?: WorkOrderCreateOrConnectWithoutChangeRequestsInput
    connect?: WorkOrderWhereUniqueInput
  }

  export type EnumChangeRequestStatusFieldUpdateOperationsInput = {
    set?: $Enums.ChangeRequestStatus
  }

  export type WorkOrderUpdateOneRequiredWithoutChangeRequestsNestedInput = {
    create?: XOR<WorkOrderCreateWithoutChangeRequestsInput, WorkOrderUncheckedCreateWithoutChangeRequestsInput>
    connectOrCreate?: WorkOrderCreateOrConnectWithoutChangeRequestsInput
    upsert?: WorkOrderUpsertWithoutChangeRequestsInput
    connect?: WorkOrderWhereUniqueInput
    update?: XOR<XOR<WorkOrderUpdateToOneWithWhereWithoutChangeRequestsInput, WorkOrderUpdateWithoutChangeRequestsInput>, WorkOrderUncheckedUpdateWithoutChangeRequestsInput>
  }

  export type WorkOrderCreateNestedOneWithoutEvidencesInput = {
    create?: XOR<WorkOrderCreateWithoutEvidencesInput, WorkOrderUncheckedCreateWithoutEvidencesInput>
    connectOrCreate?: WorkOrderCreateOrConnectWithoutEvidencesInput
    connect?: WorkOrderWhereUniqueInput
  }

  export type EnumEvidenceStageFieldUpdateOperationsInput = {
    set?: $Enums.EvidenceStage
  }

  export type WorkOrderUpdateOneRequiredWithoutEvidencesNestedInput = {
    create?: XOR<WorkOrderCreateWithoutEvidencesInput, WorkOrderUncheckedCreateWithoutEvidencesInput>
    connectOrCreate?: WorkOrderCreateOrConnectWithoutEvidencesInput
    upsert?: WorkOrderUpsertWithoutEvidencesInput
    connect?: WorkOrderWhereUniqueInput
    update?: XOR<XOR<WorkOrderUpdateToOneWithWhereWithoutEvidencesInput, WorkOrderUpdateWithoutEvidencesInput>, WorkOrderUncheckedUpdateWithoutEvidencesInput>
  }

  export type WorkOrderCreateNestedOneWithoutReviewInput = {
    create?: XOR<WorkOrderCreateWithoutReviewInput, WorkOrderUncheckedCreateWithoutReviewInput>
    connectOrCreate?: WorkOrderCreateOrConnectWithoutReviewInput
    connect?: WorkOrderWhereUniqueInput
  }

  export type WorkshopCreateNestedOneWithoutReviewsInput = {
    create?: XOR<WorkshopCreateWithoutReviewsInput, WorkshopUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: WorkshopCreateOrConnectWithoutReviewsInput
    connect?: WorkshopWhereUniqueInput
  }

  export type UserProfileCreateNestedOneWithoutReviewsInput = {
    create?: XOR<UserProfileCreateWithoutReviewsInput, UserProfileUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: UserProfileCreateOrConnectWithoutReviewsInput
    connect?: UserProfileWhereUniqueInput
  }

  export type WorkOrderUpdateOneRequiredWithoutReviewNestedInput = {
    create?: XOR<WorkOrderCreateWithoutReviewInput, WorkOrderUncheckedCreateWithoutReviewInput>
    connectOrCreate?: WorkOrderCreateOrConnectWithoutReviewInput
    upsert?: WorkOrderUpsertWithoutReviewInput
    connect?: WorkOrderWhereUniqueInput
    update?: XOR<XOR<WorkOrderUpdateToOneWithWhereWithoutReviewInput, WorkOrderUpdateWithoutReviewInput>, WorkOrderUncheckedUpdateWithoutReviewInput>
  }

  export type WorkshopUpdateOneRequiredWithoutReviewsNestedInput = {
    create?: XOR<WorkshopCreateWithoutReviewsInput, WorkshopUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: WorkshopCreateOrConnectWithoutReviewsInput
    upsert?: WorkshopUpsertWithoutReviewsInput
    connect?: WorkshopWhereUniqueInput
    update?: XOR<XOR<WorkshopUpdateToOneWithWhereWithoutReviewsInput, WorkshopUpdateWithoutReviewsInput>, WorkshopUncheckedUpdateWithoutReviewsInput>
  }

  export type UserProfileUpdateOneRequiredWithoutReviewsNestedInput = {
    create?: XOR<UserProfileCreateWithoutReviewsInput, UserProfileUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: UserProfileCreateOrConnectWithoutReviewsInput
    upsert?: UserProfileUpsertWithoutReviewsInput
    connect?: UserProfileWhereUniqueInput
    update?: XOR<XOR<UserProfileUpdateToOneWithWhereWithoutReviewsInput, UserProfileUpdateWithoutReviewsInput>, UserProfileUncheckedUpdateWithoutReviewsInput>
  }

  export type WorkOrderCreateNestedOneWithoutReceiptInput = {
    create?: XOR<WorkOrderCreateWithoutReceiptInput, WorkOrderUncheckedCreateWithoutReceiptInput>
    connectOrCreate?: WorkOrderCreateOrConnectWithoutReceiptInput
    connect?: WorkOrderWhereUniqueInput
  }

  export type WorkOrderUpdateOneRequiredWithoutReceiptNestedInput = {
    create?: XOR<WorkOrderCreateWithoutReceiptInput, WorkOrderUncheckedCreateWithoutReceiptInput>
    connectOrCreate?: WorkOrderCreateOrConnectWithoutReceiptInput
    upsert?: WorkOrderUpsertWithoutReceiptInput
    connect?: WorkOrderWhereUniqueInput
    update?: XOR<XOR<WorkOrderUpdateToOneWithWhereWithoutReceiptInput, WorkOrderUpdateWithoutReceiptInput>, WorkOrderUncheckedUpdateWithoutReceiptInput>
  }

  export type UserProfileCreateNestedOneWithoutIncidentReportsInput = {
    create?: XOR<UserProfileCreateWithoutIncidentReportsInput, UserProfileUncheckedCreateWithoutIncidentReportsInput>
    connectOrCreate?: UserProfileCreateOrConnectWithoutIncidentReportsInput
    connect?: UserProfileWhereUniqueInput
  }

  export type WorkshopCreateNestedOneWithoutIncidentReportsInput = {
    create?: XOR<WorkshopCreateWithoutIncidentReportsInput, WorkshopUncheckedCreateWithoutIncidentReportsInput>
    connectOrCreate?: WorkshopCreateOrConnectWithoutIncidentReportsInput
    connect?: WorkshopWhereUniqueInput
  }

  export type EnumIncidentTypeFieldUpdateOperationsInput = {
    set?: $Enums.IncidentType
  }

  export type EnumIncidentStatusFieldUpdateOperationsInput = {
    set?: $Enums.IncidentStatus
  }

  export type UserProfileUpdateOneRequiredWithoutIncidentReportsNestedInput = {
    create?: XOR<UserProfileCreateWithoutIncidentReportsInput, UserProfileUncheckedCreateWithoutIncidentReportsInput>
    connectOrCreate?: UserProfileCreateOrConnectWithoutIncidentReportsInput
    upsert?: UserProfileUpsertWithoutIncidentReportsInput
    connect?: UserProfileWhereUniqueInput
    update?: XOR<XOR<UserProfileUpdateToOneWithWhereWithoutIncidentReportsInput, UserProfileUpdateWithoutIncidentReportsInput>, UserProfileUncheckedUpdateWithoutIncidentReportsInput>
  }

  export type WorkshopUpdateOneRequiredWithoutIncidentReportsNestedInput = {
    create?: XOR<WorkshopCreateWithoutIncidentReportsInput, WorkshopUncheckedCreateWithoutIncidentReportsInput>
    connectOrCreate?: WorkshopCreateOrConnectWithoutIncidentReportsInput
    upsert?: WorkshopUpsertWithoutIncidentReportsInput
    connect?: WorkshopWhereUniqueInput
    update?: XOR<XOR<WorkshopUpdateToOneWithWhereWithoutIncidentReportsInput, WorkshopUpdateWithoutIncidentReportsInput>, WorkshopUncheckedUpdateWithoutIncidentReportsInput>
  }

  export type ServiceRequestCreateNestedOneWithoutChatMessagesInput = {
    create?: XOR<ServiceRequestCreateWithoutChatMessagesInput, ServiceRequestUncheckedCreateWithoutChatMessagesInput>
    connectOrCreate?: ServiceRequestCreateOrConnectWithoutChatMessagesInput
    connect?: ServiceRequestWhereUniqueInput
  }

  export type UserProfileCreateNestedOneWithoutChatMessagesInput = {
    create?: XOR<UserProfileCreateWithoutChatMessagesInput, UserProfileUncheckedCreateWithoutChatMessagesInput>
    connectOrCreate?: UserProfileCreateOrConnectWithoutChatMessagesInput
    connect?: UserProfileWhereUniqueInput
  }

  export type ServiceRequestUpdateOneRequiredWithoutChatMessagesNestedInput = {
    create?: XOR<ServiceRequestCreateWithoutChatMessagesInput, ServiceRequestUncheckedCreateWithoutChatMessagesInput>
    connectOrCreate?: ServiceRequestCreateOrConnectWithoutChatMessagesInput
    upsert?: ServiceRequestUpsertWithoutChatMessagesInput
    connect?: ServiceRequestWhereUniqueInput
    update?: XOR<XOR<ServiceRequestUpdateToOneWithWhereWithoutChatMessagesInput, ServiceRequestUpdateWithoutChatMessagesInput>, ServiceRequestUncheckedUpdateWithoutChatMessagesInput>
  }

  export type UserProfileUpdateOneRequiredWithoutChatMessagesNestedInput = {
    create?: XOR<UserProfileCreateWithoutChatMessagesInput, UserProfileUncheckedCreateWithoutChatMessagesInput>
    connectOrCreate?: UserProfileCreateOrConnectWithoutChatMessagesInput
    upsert?: UserProfileUpsertWithoutChatMessagesInput
    connect?: UserProfileWhereUniqueInput
    update?: XOR<XOR<UserProfileUpdateToOneWithWhereWithoutChatMessagesInput, UserProfileUpdateWithoutChatMessagesInput>, UserProfileUncheckedUpdateWithoutChatMessagesInput>
  }

  export type UserProfileCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<UserProfileCreateWithoutNotificationsInput, UserProfileUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserProfileCreateOrConnectWithoutNotificationsInput
    connect?: UserProfileWhereUniqueInput
  }

  export type ServiceRequestCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<ServiceRequestCreateWithoutNotificationsInput, ServiceRequestUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: ServiceRequestCreateOrConnectWithoutNotificationsInput
    connect?: ServiceRequestWhereUniqueInput
  }

  export type UserProfileUpdateOneRequiredWithoutNotificationsNestedInput = {
    create?: XOR<UserProfileCreateWithoutNotificationsInput, UserProfileUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserProfileCreateOrConnectWithoutNotificationsInput
    upsert?: UserProfileUpsertWithoutNotificationsInput
    connect?: UserProfileWhereUniqueInput
    update?: XOR<XOR<UserProfileUpdateToOneWithWhereWithoutNotificationsInput, UserProfileUpdateWithoutNotificationsInput>, UserProfileUncheckedUpdateWithoutNotificationsInput>
  }

  export type ServiceRequestUpdateOneWithoutNotificationsNestedInput = {
    create?: XOR<ServiceRequestCreateWithoutNotificationsInput, ServiceRequestUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: ServiceRequestCreateOrConnectWithoutNotificationsInput
    upsert?: ServiceRequestUpsertWithoutNotificationsInput
    disconnect?: ServiceRequestWhereInput | boolean
    delete?: ServiceRequestWhereInput | boolean
    connect?: ServiceRequestWhereUniqueInput
    update?: XOR<XOR<ServiceRequestUpdateToOneWithWhereWithoutNotificationsInput, ServiceRequestUpdateWithoutNotificationsInput>, ServiceRequestUncheckedUpdateWithoutNotificationsInput>
  }

  export type EnumAdminActionTypeFieldUpdateOperationsInput = {
    set?: $Enums.AdminActionType
  }

  export type ServiceRequestCreateNestedOneWithoutAiSuggestionsInput = {
    create?: XOR<ServiceRequestCreateWithoutAiSuggestionsInput, ServiceRequestUncheckedCreateWithoutAiSuggestionsInput>
    connectOrCreate?: ServiceRequestCreateOrConnectWithoutAiSuggestionsInput
    connect?: ServiceRequestWhereUniqueInput
  }

  export type ServiceRequestUpdateOneRequiredWithoutAiSuggestionsNestedInput = {
    create?: XOR<ServiceRequestCreateWithoutAiSuggestionsInput, ServiceRequestUncheckedCreateWithoutAiSuggestionsInput>
    connectOrCreate?: ServiceRequestCreateOrConnectWithoutAiSuggestionsInput
    upsert?: ServiceRequestUpsertWithoutAiSuggestionsInput
    connect?: ServiceRequestWhereUniqueInput
    update?: XOR<XOR<ServiceRequestUpdateToOneWithWhereWithoutAiSuggestionsInput, ServiceRequestUpdateWithoutAiSuggestionsInput>, ServiceRequestUncheckedUpdateWithoutAiSuggestionsInput>
  }

  export type QuoteCreateNestedOneWithoutAiAnalysisInput = {
    create?: XOR<QuoteCreateWithoutAiAnalysisInput, QuoteUncheckedCreateWithoutAiAnalysisInput>
    connectOrCreate?: QuoteCreateOrConnectWithoutAiAnalysisInput
    connect?: QuoteWhereUniqueInput
  }

  export type QuoteUpdateOneRequiredWithoutAiAnalysisNestedInput = {
    create?: XOR<QuoteCreateWithoutAiAnalysisInput, QuoteUncheckedCreateWithoutAiAnalysisInput>
    connectOrCreate?: QuoteCreateOrConnectWithoutAiAnalysisInput
    upsert?: QuoteUpsertWithoutAiAnalysisInput
    connect?: QuoteWhereUniqueInput
    update?: XOR<XOR<QuoteUpdateToOneWithWhereWithoutAiAnalysisInput, QuoteUpdateWithoutAiAnalysisInput>, QuoteUncheckedUpdateWithoutAiAnalysisInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedEnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedEnumNotificationChannelFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationChannel | EnumNotificationChannelFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationChannel[] | ListEnumNotificationChannelFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationChannel[] | ListEnumNotificationChannelFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationChannelFilter<$PrismaModel> | $Enums.NotificationChannel
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedEnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumNotificationChannelWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationChannel | EnumNotificationChannelFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationChannel[] | ListEnumNotificationChannelFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationChannel[] | ListEnumNotificationChannelFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationChannelWithAggregatesFilter<$PrismaModel> | $Enums.NotificationChannel
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationChannelFilter<$PrismaModel>
    _max?: NestedEnumNotificationChannelFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumMotorcycleUseNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.MotorcycleUse | EnumMotorcycleUseFieldRefInput<$PrismaModel> | null
    in?: $Enums.MotorcycleUse[] | ListEnumMotorcycleUseFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.MotorcycleUse[] | ListEnumMotorcycleUseFieldRefInput<$PrismaModel> | null
    not?: NestedEnumMotorcycleUseNullableFilter<$PrismaModel> | $Enums.MotorcycleUse | null
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumMotorcycleUseNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MotorcycleUse | EnumMotorcycleUseFieldRefInput<$PrismaModel> | null
    in?: $Enums.MotorcycleUse[] | ListEnumMotorcycleUseFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.MotorcycleUse[] | ListEnumMotorcycleUseFieldRefInput<$PrismaModel> | null
    not?: NestedEnumMotorcycleUseNullableWithAggregatesFilter<$PrismaModel> | $Enums.MotorcycleUse | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumMotorcycleUseNullableFilter<$PrismaModel>
    _max?: NestedEnumMotorcycleUseNullableFilter<$PrismaModel>
  }

  export type NestedEnumUrgencyLevelFilter<$PrismaModel = never> = {
    equals?: $Enums.UrgencyLevel | EnumUrgencyLevelFieldRefInput<$PrismaModel>
    in?: $Enums.UrgencyLevel[] | ListEnumUrgencyLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.UrgencyLevel[] | ListEnumUrgencyLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumUrgencyLevelFilter<$PrismaModel> | $Enums.UrgencyLevel
  }

  export type NestedEnumServiceRequestStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ServiceRequestStatus | EnumServiceRequestStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ServiceRequestStatus[] | ListEnumServiceRequestStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ServiceRequestStatus[] | ListEnumServiceRequestStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumServiceRequestStatusFilter<$PrismaModel> | $Enums.ServiceRequestStatus
  }

  export type NestedEnumUrgencyLevelWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UrgencyLevel | EnumUrgencyLevelFieldRefInput<$PrismaModel>
    in?: $Enums.UrgencyLevel[] | ListEnumUrgencyLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.UrgencyLevel[] | ListEnumUrgencyLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumUrgencyLevelWithAggregatesFilter<$PrismaModel> | $Enums.UrgencyLevel
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUrgencyLevelFilter<$PrismaModel>
    _max?: NestedEnumUrgencyLevelFilter<$PrismaModel>
  }

  export type NestedEnumServiceRequestStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ServiceRequestStatus | EnumServiceRequestStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ServiceRequestStatus[] | ListEnumServiceRequestStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ServiceRequestStatus[] | ListEnumServiceRequestStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumServiceRequestStatusWithAggregatesFilter<$PrismaModel> | $Enums.ServiceRequestStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumServiceRequestStatusFilter<$PrismaModel>
    _max?: NestedEnumServiceRequestStatusFilter<$PrismaModel>
  }

  export type NestedEnumMediaTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.MediaType | EnumMediaTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MediaType[] | ListEnumMediaTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MediaType[] | ListEnumMediaTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMediaTypeFilter<$PrismaModel> | $Enums.MediaType
  }

  export type NestedEnumMediaTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MediaType | EnumMediaTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MediaType[] | ListEnumMediaTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MediaType[] | ListEnumMediaTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMediaTypeWithAggregatesFilter<$PrismaModel> | $Enums.MediaType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMediaTypeFilter<$PrismaModel>
    _max?: NestedEnumMediaTypeFilter<$PrismaModel>
  }

  export type NestedEnumServiceRequestStatusNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.ServiceRequestStatus | EnumServiceRequestStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.ServiceRequestStatus[] | ListEnumServiceRequestStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ServiceRequestStatus[] | ListEnumServiceRequestStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumServiceRequestStatusNullableFilter<$PrismaModel> | $Enums.ServiceRequestStatus | null
  }

  export type NestedEnumServiceRequestStatusNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ServiceRequestStatus | EnumServiceRequestStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.ServiceRequestStatus[] | ListEnumServiceRequestStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ServiceRequestStatus[] | ListEnumServiceRequestStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumServiceRequestStatusNullableWithAggregatesFilter<$PrismaModel> | $Enums.ServiceRequestStatus | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumServiceRequestStatusNullableFilter<$PrismaModel>
    _max?: NestedEnumServiceRequestStatusNullableFilter<$PrismaModel>
  }

  export type NestedEnumWorkshopStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.WorkshopStatus | EnumWorkshopStatusFieldRefInput<$PrismaModel>
    in?: $Enums.WorkshopStatus[] | ListEnumWorkshopStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.WorkshopStatus[] | ListEnumWorkshopStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumWorkshopStatusFilter<$PrismaModel> | $Enums.WorkshopStatus
  }

  export type NestedEnumWorkshopStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.WorkshopStatus | EnumWorkshopStatusFieldRefInput<$PrismaModel>
    in?: $Enums.WorkshopStatus[] | ListEnumWorkshopStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.WorkshopStatus[] | ListEnumWorkshopStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumWorkshopStatusWithAggregatesFilter<$PrismaModel> | $Enums.WorkshopStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumWorkshopStatusFilter<$PrismaModel>
    _max?: NestedEnumWorkshopStatusFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedEnumQuoteStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.QuoteStatus | EnumQuoteStatusFieldRefInput<$PrismaModel>
    in?: $Enums.QuoteStatus[] | ListEnumQuoteStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.QuoteStatus[] | ListEnumQuoteStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumQuoteStatusFilter<$PrismaModel> | $Enums.QuoteStatus
  }

  export type NestedEnumQuoteStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.QuoteStatus | EnumQuoteStatusFieldRefInput<$PrismaModel>
    in?: $Enums.QuoteStatus[] | ListEnumQuoteStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.QuoteStatus[] | ListEnumQuoteStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumQuoteStatusWithAggregatesFilter<$PrismaModel> | $Enums.QuoteStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumQuoteStatusFilter<$PrismaModel>
    _max?: NestedEnumQuoteStatusFilter<$PrismaModel>
  }

  export type NestedEnumPartTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.PartType | EnumPartTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PartType[] | ListEnumPartTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PartType[] | ListEnumPartTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPartTypeFilter<$PrismaModel> | $Enums.PartType
  }

  export type NestedEnumPartTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.PartType | EnumPartTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.PartType[] | ListEnumPartTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.PartType[] | ListEnumPartTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPartTypeNullableFilter<$PrismaModel> | $Enums.PartType | null
  }

  export type NestedEnumPartTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PartType | EnumPartTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PartType[] | ListEnumPartTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PartType[] | ListEnumPartTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPartTypeWithAggregatesFilter<$PrismaModel> | $Enums.PartType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPartTypeFilter<$PrismaModel>
    _max?: NestedEnumPartTypeFilter<$PrismaModel>
  }

  export type NestedEnumPartTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PartType | EnumPartTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.PartType[] | ListEnumPartTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.PartType[] | ListEnumPartTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPartTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.PartType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumPartTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumPartTypeNullableFilter<$PrismaModel>
  }

  export type NestedEnumWorkOrderStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.WorkOrderStatus | EnumWorkOrderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.WorkOrderStatus[] | ListEnumWorkOrderStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.WorkOrderStatus[] | ListEnumWorkOrderStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumWorkOrderStatusFilter<$PrismaModel> | $Enums.WorkOrderStatus
  }

  export type NestedEnumWorkOrderStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.WorkOrderStatus | EnumWorkOrderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.WorkOrderStatus[] | ListEnumWorkOrderStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.WorkOrderStatus[] | ListEnumWorkOrderStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumWorkOrderStatusWithAggregatesFilter<$PrismaModel> | $Enums.WorkOrderStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumWorkOrderStatusFilter<$PrismaModel>
    _max?: NestedEnumWorkOrderStatusFilter<$PrismaModel>
  }

  export type NestedEnumChangeRequestStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ChangeRequestStatus | EnumChangeRequestStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ChangeRequestStatus[] | ListEnumChangeRequestStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ChangeRequestStatus[] | ListEnumChangeRequestStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumChangeRequestStatusFilter<$PrismaModel> | $Enums.ChangeRequestStatus
  }

  export type NestedEnumChangeRequestStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ChangeRequestStatus | EnumChangeRequestStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ChangeRequestStatus[] | ListEnumChangeRequestStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ChangeRequestStatus[] | ListEnumChangeRequestStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumChangeRequestStatusWithAggregatesFilter<$PrismaModel> | $Enums.ChangeRequestStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumChangeRequestStatusFilter<$PrismaModel>
    _max?: NestedEnumChangeRequestStatusFilter<$PrismaModel>
  }

  export type NestedEnumEvidenceStageFilter<$PrismaModel = never> = {
    equals?: $Enums.EvidenceStage | EnumEvidenceStageFieldRefInput<$PrismaModel>
    in?: $Enums.EvidenceStage[] | ListEnumEvidenceStageFieldRefInput<$PrismaModel>
    notIn?: $Enums.EvidenceStage[] | ListEnumEvidenceStageFieldRefInput<$PrismaModel>
    not?: NestedEnumEvidenceStageFilter<$PrismaModel> | $Enums.EvidenceStage
  }

  export type NestedEnumEvidenceStageWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EvidenceStage | EnumEvidenceStageFieldRefInput<$PrismaModel>
    in?: $Enums.EvidenceStage[] | ListEnumEvidenceStageFieldRefInput<$PrismaModel>
    notIn?: $Enums.EvidenceStage[] | ListEnumEvidenceStageFieldRefInput<$PrismaModel>
    not?: NestedEnumEvidenceStageWithAggregatesFilter<$PrismaModel> | $Enums.EvidenceStage
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEvidenceStageFilter<$PrismaModel>
    _max?: NestedEnumEvidenceStageFilter<$PrismaModel>
  }

  export type NestedEnumIncidentTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.IncidentType | EnumIncidentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.IncidentType[] | ListEnumIncidentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.IncidentType[] | ListEnumIncidentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumIncidentTypeFilter<$PrismaModel> | $Enums.IncidentType
  }

  export type NestedEnumIncidentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.IncidentStatus | EnumIncidentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.IncidentStatus[] | ListEnumIncidentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.IncidentStatus[] | ListEnumIncidentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumIncidentStatusFilter<$PrismaModel> | $Enums.IncidentStatus
  }

  export type NestedEnumIncidentTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.IncidentType | EnumIncidentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.IncidentType[] | ListEnumIncidentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.IncidentType[] | ListEnumIncidentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumIncidentTypeWithAggregatesFilter<$PrismaModel> | $Enums.IncidentType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumIncidentTypeFilter<$PrismaModel>
    _max?: NestedEnumIncidentTypeFilter<$PrismaModel>
  }

  export type NestedEnumIncidentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.IncidentStatus | EnumIncidentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.IncidentStatus[] | ListEnumIncidentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.IncidentStatus[] | ListEnumIncidentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumIncidentStatusWithAggregatesFilter<$PrismaModel> | $Enums.IncidentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumIncidentStatusFilter<$PrismaModel>
    _max?: NestedEnumIncidentStatusFilter<$PrismaModel>
  }

  export type NestedEnumAdminActionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AdminActionType | EnumAdminActionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AdminActionType[] | ListEnumAdminActionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AdminActionType[] | ListEnumAdminActionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAdminActionTypeFilter<$PrismaModel> | $Enums.AdminActionType
  }

  export type NestedEnumAdminActionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AdminActionType | EnumAdminActionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AdminActionType[] | ListEnumAdminActionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AdminActionType[] | ListEnumAdminActionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAdminActionTypeWithAggregatesFilter<$PrismaModel> | $Enums.AdminActionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAdminActionTypeFilter<$PrismaModel>
    _max?: NestedEnumAdminActionTypeFilter<$PrismaModel>
  }

  export type MotorcycleCreateWithoutUserInput = {
    id?: string
    brand: string
    model: string
    year: number
    displacement?: number | null
    use?: $Enums.MotorcycleUse | null
    kmApprox?: number | null
    placa?: string | null
    alias?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    serviceRequests?: ServiceRequestCreateNestedManyWithoutMotorcycleInput
  }

  export type MotorcycleUncheckedCreateWithoutUserInput = {
    id?: string
    brand: string
    model: string
    year: number
    displacement?: number | null
    use?: $Enums.MotorcycleUse | null
    kmApprox?: number | null
    placa?: string | null
    alias?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    serviceRequests?: ServiceRequestUncheckedCreateNestedManyWithoutMotorcycleInput
  }

  export type MotorcycleCreateOrConnectWithoutUserInput = {
    where: MotorcycleWhereUniqueInput
    create: XOR<MotorcycleCreateWithoutUserInput, MotorcycleUncheckedCreateWithoutUserInput>
  }

  export type MotorcycleCreateManyUserInputEnvelope = {
    data: MotorcycleCreateManyUserInput | MotorcycleCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ServiceRequestCreateWithoutUserInput = {
    id?: string
    description: string
    district: string
    urgency?: $Enums.UrgencyLevel
    status?: $Enums.ServiceRequestStatus
    completionScore?: number
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    motorcycle: MotorcycleCreateNestedOneWithoutServiceRequestsInput
    category: CategoryCreateNestedOneWithoutServiceRequestsInput
    media?: RequestMediaCreateNestedManyWithoutRequestInput
    guideAnswers?: GuideAnswerCreateNestedManyWithoutRequestInput
    quotes?: QuoteCreateNestedManyWithoutRequestInput
    statusHistory?: RequestStatusHistoryCreateNestedManyWithoutRequestInput
    notifications?: NotificationCreateNestedManyWithoutRequestInput
    workOrder?: WorkOrderCreateNestedOneWithoutRequestInput
    chatMessages?: ChatMessageCreateNestedManyWithoutRequestInput
    aiSuggestions?: AiSuggestionCreateNestedManyWithoutRequestInput
  }

  export type ServiceRequestUncheckedCreateWithoutUserInput = {
    id?: string
    motorcycleId: string
    categoryId: string
    description: string
    district: string
    urgency?: $Enums.UrgencyLevel
    status?: $Enums.ServiceRequestStatus
    completionScore?: number
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    media?: RequestMediaUncheckedCreateNestedManyWithoutRequestInput
    guideAnswers?: GuideAnswerUncheckedCreateNestedManyWithoutRequestInput
    quotes?: QuoteUncheckedCreateNestedManyWithoutRequestInput
    statusHistory?: RequestStatusHistoryUncheckedCreateNestedManyWithoutRequestInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutRequestInput
    workOrder?: WorkOrderUncheckedCreateNestedOneWithoutRequestInput
    chatMessages?: ChatMessageUncheckedCreateNestedManyWithoutRequestInput
    aiSuggestions?: AiSuggestionUncheckedCreateNestedManyWithoutRequestInput
  }

  export type ServiceRequestCreateOrConnectWithoutUserInput = {
    where: ServiceRequestWhereUniqueInput
    create: XOR<ServiceRequestCreateWithoutUserInput, ServiceRequestUncheckedCreateWithoutUserInput>
  }

  export type ServiceRequestCreateManyUserInputEnvelope = {
    data: ServiceRequestCreateManyUserInput | ServiceRequestCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ReviewCreateWithoutUserInput = {
    id?: string
    rating: number
    comment?: string | null
    editableUntil: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    workOrder: WorkOrderCreateNestedOneWithoutReviewInput
    workshop: WorkshopCreateNestedOneWithoutReviewsInput
  }

  export type ReviewUncheckedCreateWithoutUserInput = {
    id?: string
    workOrderId: string
    workshopId: string
    rating: number
    comment?: string | null
    editableUntil: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReviewCreateOrConnectWithoutUserInput = {
    where: ReviewWhereUniqueInput
    create: XOR<ReviewCreateWithoutUserInput, ReviewUncheckedCreateWithoutUserInput>
  }

  export type ReviewCreateManyUserInputEnvelope = {
    data: ReviewCreateManyUserInput | ReviewCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type IncidentReportCreateWithoutReporterInput = {
    id?: string
    type: $Enums.IncidentType
    description: string
    evidenceUrl?: string | null
    status?: $Enums.IncidentStatus
    resolution?: string | null
    resolvedAt?: Date | string | null
    resolvedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    workshop: WorkshopCreateNestedOneWithoutIncidentReportsInput
  }

  export type IncidentReportUncheckedCreateWithoutReporterInput = {
    id?: string
    workshopId: string
    type: $Enums.IncidentType
    description: string
    evidenceUrl?: string | null
    status?: $Enums.IncidentStatus
    resolution?: string | null
    resolvedAt?: Date | string | null
    resolvedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IncidentReportCreateOrConnectWithoutReporterInput = {
    where: IncidentReportWhereUniqueInput
    create: XOR<IncidentReportCreateWithoutReporterInput, IncidentReportUncheckedCreateWithoutReporterInput>
  }

  export type IncidentReportCreateManyReporterInputEnvelope = {
    data: IncidentReportCreateManyReporterInput | IncidentReportCreateManyReporterInput[]
    skipDuplicates?: boolean
  }

  export type NotificationCreateWithoutUserInput = {
    id?: string
    title: string
    body: string
    channel?: $Enums.NotificationChannel
    isRead?: boolean
    link?: string | null
    createdAt?: Date | string
    request?: ServiceRequestCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateWithoutUserInput = {
    id?: string
    requestId?: string | null
    title: string
    body: string
    channel?: $Enums.NotificationChannel
    isRead?: boolean
    link?: string | null
    createdAt?: Date | string
  }

  export type NotificationCreateOrConnectWithoutUserInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationCreateManyUserInputEnvelope = {
    data: NotificationCreateManyUserInput | NotificationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ChatMessageCreateWithoutSenderInput = {
    id?: string
    content: string
    imageUrl?: string | null
    isRead?: boolean
    createdAt?: Date | string
    request: ServiceRequestCreateNestedOneWithoutChatMessagesInput
  }

  export type ChatMessageUncheckedCreateWithoutSenderInput = {
    id?: string
    requestId: string
    content: string
    imageUrl?: string | null
    isRead?: boolean
    createdAt?: Date | string
  }

  export type ChatMessageCreateOrConnectWithoutSenderInput = {
    where: ChatMessageWhereUniqueInput
    create: XOR<ChatMessageCreateWithoutSenderInput, ChatMessageUncheckedCreateWithoutSenderInput>
  }

  export type ChatMessageCreateManySenderInputEnvelope = {
    data: ChatMessageCreateManySenderInput | ChatMessageCreateManySenderInput[]
    skipDuplicates?: boolean
  }

  export type WorkshopCreateWithoutUserInput = {
    id?: string
    name: string
    address: string
    district: string
    phone: string
    ruc?: string | null
    description?: string | null
    photoUrl?: string | null
    status?: $Enums.WorkshopStatus
    transparencyAccepted?: boolean
    guaranteePolicy?: string | null
    latitude?: number | null
    longitude?: number | null
    rating?: number
    totalServices?: number
    evidenceRate?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    categories?: WorkshopCategoryCreateNestedManyWithoutWorkshopInput
    quotes?: QuoteCreateNestedManyWithoutWorkshopInput
    workOrders?: WorkOrderCreateNestedManyWithoutWorkshopInput
    reviews?: ReviewCreateNestedManyWithoutWorkshopInput
    incidentReports?: IncidentReportCreateNestedManyWithoutWorkshopInput
    verifications?: WorkshopVerificationCreateNestedManyWithoutWorkshopInput
  }

  export type WorkshopUncheckedCreateWithoutUserInput = {
    id?: string
    name: string
    address: string
    district: string
    phone: string
    ruc?: string | null
    description?: string | null
    photoUrl?: string | null
    status?: $Enums.WorkshopStatus
    transparencyAccepted?: boolean
    guaranteePolicy?: string | null
    latitude?: number | null
    longitude?: number | null
    rating?: number
    totalServices?: number
    evidenceRate?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    categories?: WorkshopCategoryUncheckedCreateNestedManyWithoutWorkshopInput
    quotes?: QuoteUncheckedCreateNestedManyWithoutWorkshopInput
    workOrders?: WorkOrderUncheckedCreateNestedManyWithoutWorkshopInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutWorkshopInput
    incidentReports?: IncidentReportUncheckedCreateNestedManyWithoutWorkshopInput
    verifications?: WorkshopVerificationUncheckedCreateNestedManyWithoutWorkshopInput
  }

  export type WorkshopCreateOrConnectWithoutUserInput = {
    where: WorkshopWhereUniqueInput
    create: XOR<WorkshopCreateWithoutUserInput, WorkshopUncheckedCreateWithoutUserInput>
  }

  export type MotorcycleUpsertWithWhereUniqueWithoutUserInput = {
    where: MotorcycleWhereUniqueInput
    update: XOR<MotorcycleUpdateWithoutUserInput, MotorcycleUncheckedUpdateWithoutUserInput>
    create: XOR<MotorcycleCreateWithoutUserInput, MotorcycleUncheckedCreateWithoutUserInput>
  }

  export type MotorcycleUpdateWithWhereUniqueWithoutUserInput = {
    where: MotorcycleWhereUniqueInput
    data: XOR<MotorcycleUpdateWithoutUserInput, MotorcycleUncheckedUpdateWithoutUserInput>
  }

  export type MotorcycleUpdateManyWithWhereWithoutUserInput = {
    where: MotorcycleScalarWhereInput
    data: XOR<MotorcycleUpdateManyMutationInput, MotorcycleUncheckedUpdateManyWithoutUserInput>
  }

  export type MotorcycleScalarWhereInput = {
    AND?: MotorcycleScalarWhereInput | MotorcycleScalarWhereInput[]
    OR?: MotorcycleScalarWhereInput[]
    NOT?: MotorcycleScalarWhereInput | MotorcycleScalarWhereInput[]
    id?: StringFilter<"Motorcycle"> | string
    userId?: StringFilter<"Motorcycle"> | string
    brand?: StringFilter<"Motorcycle"> | string
    model?: StringFilter<"Motorcycle"> | string
    year?: IntFilter<"Motorcycle"> | number
    displacement?: IntNullableFilter<"Motorcycle"> | number | null
    use?: EnumMotorcycleUseNullableFilter<"Motorcycle"> | $Enums.MotorcycleUse | null
    kmApprox?: IntNullableFilter<"Motorcycle"> | number | null
    placa?: StringNullableFilter<"Motorcycle"> | string | null
    alias?: StringNullableFilter<"Motorcycle"> | string | null
    createdAt?: DateTimeFilter<"Motorcycle"> | Date | string
    updatedAt?: DateTimeFilter<"Motorcycle"> | Date | string
  }

  export type ServiceRequestUpsertWithWhereUniqueWithoutUserInput = {
    where: ServiceRequestWhereUniqueInput
    update: XOR<ServiceRequestUpdateWithoutUserInput, ServiceRequestUncheckedUpdateWithoutUserInput>
    create: XOR<ServiceRequestCreateWithoutUserInput, ServiceRequestUncheckedCreateWithoutUserInput>
  }

  export type ServiceRequestUpdateWithWhereUniqueWithoutUserInput = {
    where: ServiceRequestWhereUniqueInput
    data: XOR<ServiceRequestUpdateWithoutUserInput, ServiceRequestUncheckedUpdateWithoutUserInput>
  }

  export type ServiceRequestUpdateManyWithWhereWithoutUserInput = {
    where: ServiceRequestScalarWhereInput
    data: XOR<ServiceRequestUpdateManyMutationInput, ServiceRequestUncheckedUpdateManyWithoutUserInput>
  }

  export type ServiceRequestScalarWhereInput = {
    AND?: ServiceRequestScalarWhereInput | ServiceRequestScalarWhereInput[]
    OR?: ServiceRequestScalarWhereInput[]
    NOT?: ServiceRequestScalarWhereInput | ServiceRequestScalarWhereInput[]
    id?: StringFilter<"ServiceRequest"> | string
    userId?: StringFilter<"ServiceRequest"> | string
    motorcycleId?: StringFilter<"ServiceRequest"> | string
    categoryId?: StringFilter<"ServiceRequest"> | string
    description?: StringFilter<"ServiceRequest"> | string
    district?: StringFilter<"ServiceRequest"> | string
    urgency?: EnumUrgencyLevelFilter<"ServiceRequest"> | $Enums.UrgencyLevel
    status?: EnumServiceRequestStatusFilter<"ServiceRequest"> | $Enums.ServiceRequestStatus
    completionScore?: IntFilter<"ServiceRequest"> | number
    expiresAt?: DateTimeNullableFilter<"ServiceRequest"> | Date | string | null
    createdAt?: DateTimeFilter<"ServiceRequest"> | Date | string
    updatedAt?: DateTimeFilter<"ServiceRequest"> | Date | string
  }

  export type ReviewUpsertWithWhereUniqueWithoutUserInput = {
    where: ReviewWhereUniqueInput
    update: XOR<ReviewUpdateWithoutUserInput, ReviewUncheckedUpdateWithoutUserInput>
    create: XOR<ReviewCreateWithoutUserInput, ReviewUncheckedCreateWithoutUserInput>
  }

  export type ReviewUpdateWithWhereUniqueWithoutUserInput = {
    where: ReviewWhereUniqueInput
    data: XOR<ReviewUpdateWithoutUserInput, ReviewUncheckedUpdateWithoutUserInput>
  }

  export type ReviewUpdateManyWithWhereWithoutUserInput = {
    where: ReviewScalarWhereInput
    data: XOR<ReviewUpdateManyMutationInput, ReviewUncheckedUpdateManyWithoutUserInput>
  }

  export type ReviewScalarWhereInput = {
    AND?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
    OR?: ReviewScalarWhereInput[]
    NOT?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
    id?: StringFilter<"Review"> | string
    workOrderId?: StringFilter<"Review"> | string
    workshopId?: StringFilter<"Review"> | string
    userId?: StringFilter<"Review"> | string
    rating?: IntFilter<"Review"> | number
    comment?: StringNullableFilter<"Review"> | string | null
    editableUntil?: DateTimeFilter<"Review"> | Date | string
    createdAt?: DateTimeFilter<"Review"> | Date | string
    updatedAt?: DateTimeFilter<"Review"> | Date | string
  }

  export type IncidentReportUpsertWithWhereUniqueWithoutReporterInput = {
    where: IncidentReportWhereUniqueInput
    update: XOR<IncidentReportUpdateWithoutReporterInput, IncidentReportUncheckedUpdateWithoutReporterInput>
    create: XOR<IncidentReportCreateWithoutReporterInput, IncidentReportUncheckedCreateWithoutReporterInput>
  }

  export type IncidentReportUpdateWithWhereUniqueWithoutReporterInput = {
    where: IncidentReportWhereUniqueInput
    data: XOR<IncidentReportUpdateWithoutReporterInput, IncidentReportUncheckedUpdateWithoutReporterInput>
  }

  export type IncidentReportUpdateManyWithWhereWithoutReporterInput = {
    where: IncidentReportScalarWhereInput
    data: XOR<IncidentReportUpdateManyMutationInput, IncidentReportUncheckedUpdateManyWithoutReporterInput>
  }

  export type IncidentReportScalarWhereInput = {
    AND?: IncidentReportScalarWhereInput | IncidentReportScalarWhereInput[]
    OR?: IncidentReportScalarWhereInput[]
    NOT?: IncidentReportScalarWhereInput | IncidentReportScalarWhereInput[]
    id?: StringFilter<"IncidentReport"> | string
    reporterId?: StringFilter<"IncidentReport"> | string
    workshopId?: StringFilter<"IncidentReport"> | string
    type?: EnumIncidentTypeFilter<"IncidentReport"> | $Enums.IncidentType
    description?: StringFilter<"IncidentReport"> | string
    evidenceUrl?: StringNullableFilter<"IncidentReport"> | string | null
    status?: EnumIncidentStatusFilter<"IncidentReport"> | $Enums.IncidentStatus
    resolution?: StringNullableFilter<"IncidentReport"> | string | null
    resolvedAt?: DateTimeNullableFilter<"IncidentReport"> | Date | string | null
    resolvedBy?: StringNullableFilter<"IncidentReport"> | string | null
    createdAt?: DateTimeFilter<"IncidentReport"> | Date | string
    updatedAt?: DateTimeFilter<"IncidentReport"> | Date | string
  }

  export type NotificationUpsertWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
  }

  export type NotificationUpdateManyWithWhereWithoutUserInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutUserInput>
  }

  export type NotificationScalarWhereInput = {
    AND?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    OR?: NotificationScalarWhereInput[]
    NOT?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    id?: StringFilter<"Notification"> | string
    userId?: StringFilter<"Notification"> | string
    requestId?: StringNullableFilter<"Notification"> | string | null
    title?: StringFilter<"Notification"> | string
    body?: StringFilter<"Notification"> | string
    channel?: EnumNotificationChannelFilter<"Notification"> | $Enums.NotificationChannel
    isRead?: BoolFilter<"Notification"> | boolean
    link?: StringNullableFilter<"Notification"> | string | null
    createdAt?: DateTimeFilter<"Notification"> | Date | string
  }

  export type ChatMessageUpsertWithWhereUniqueWithoutSenderInput = {
    where: ChatMessageWhereUniqueInput
    update: XOR<ChatMessageUpdateWithoutSenderInput, ChatMessageUncheckedUpdateWithoutSenderInput>
    create: XOR<ChatMessageCreateWithoutSenderInput, ChatMessageUncheckedCreateWithoutSenderInput>
  }

  export type ChatMessageUpdateWithWhereUniqueWithoutSenderInput = {
    where: ChatMessageWhereUniqueInput
    data: XOR<ChatMessageUpdateWithoutSenderInput, ChatMessageUncheckedUpdateWithoutSenderInput>
  }

  export type ChatMessageUpdateManyWithWhereWithoutSenderInput = {
    where: ChatMessageScalarWhereInput
    data: XOR<ChatMessageUpdateManyMutationInput, ChatMessageUncheckedUpdateManyWithoutSenderInput>
  }

  export type ChatMessageScalarWhereInput = {
    AND?: ChatMessageScalarWhereInput | ChatMessageScalarWhereInput[]
    OR?: ChatMessageScalarWhereInput[]
    NOT?: ChatMessageScalarWhereInput | ChatMessageScalarWhereInput[]
    id?: StringFilter<"ChatMessage"> | string
    requestId?: StringFilter<"ChatMessage"> | string
    senderId?: StringFilter<"ChatMessage"> | string
    content?: StringFilter<"ChatMessage"> | string
    imageUrl?: StringNullableFilter<"ChatMessage"> | string | null
    isRead?: BoolFilter<"ChatMessage"> | boolean
    createdAt?: DateTimeFilter<"ChatMessage"> | Date | string
  }

  export type WorkshopUpsertWithoutUserInput = {
    update: XOR<WorkshopUpdateWithoutUserInput, WorkshopUncheckedUpdateWithoutUserInput>
    create: XOR<WorkshopCreateWithoutUserInput, WorkshopUncheckedCreateWithoutUserInput>
    where?: WorkshopWhereInput
  }

  export type WorkshopUpdateToOneWithWhereWithoutUserInput = {
    where?: WorkshopWhereInput
    data: XOR<WorkshopUpdateWithoutUserInput, WorkshopUncheckedUpdateWithoutUserInput>
  }

  export type WorkshopUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    district?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    ruc?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumWorkshopStatusFieldUpdateOperationsInput | $Enums.WorkshopStatus
    transparencyAccepted?: BoolFieldUpdateOperationsInput | boolean
    guaranteePolicy?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    rating?: FloatFieldUpdateOperationsInput | number
    totalServices?: IntFieldUpdateOperationsInput | number
    evidenceRate?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    categories?: WorkshopCategoryUpdateManyWithoutWorkshopNestedInput
    quotes?: QuoteUpdateManyWithoutWorkshopNestedInput
    workOrders?: WorkOrderUpdateManyWithoutWorkshopNestedInput
    reviews?: ReviewUpdateManyWithoutWorkshopNestedInput
    incidentReports?: IncidentReportUpdateManyWithoutWorkshopNestedInput
    verifications?: WorkshopVerificationUpdateManyWithoutWorkshopNestedInput
  }

  export type WorkshopUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    district?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    ruc?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumWorkshopStatusFieldUpdateOperationsInput | $Enums.WorkshopStatus
    transparencyAccepted?: BoolFieldUpdateOperationsInput | boolean
    guaranteePolicy?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    rating?: FloatFieldUpdateOperationsInput | number
    totalServices?: IntFieldUpdateOperationsInput | number
    evidenceRate?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    categories?: WorkshopCategoryUncheckedUpdateManyWithoutWorkshopNestedInput
    quotes?: QuoteUncheckedUpdateManyWithoutWorkshopNestedInput
    workOrders?: WorkOrderUncheckedUpdateManyWithoutWorkshopNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutWorkshopNestedInput
    incidentReports?: IncidentReportUncheckedUpdateManyWithoutWorkshopNestedInput
    verifications?: WorkshopVerificationUncheckedUpdateManyWithoutWorkshopNestedInput
  }

  export type UserProfileCreateWithoutMotorcyclesInput = {
    id?: string
    clerkUserId: string
    role?: $Enums.UserRole
    email?: string | null
    phone?: string | null
    name?: string | null
    district?: string | null
    avatarUrl?: string | null
    notifChannel?: $Enums.NotificationChannel
    phoneVisible?: boolean
    termsAccepted?: boolean
    termsVersion?: string | null
    termsAcceptedAt?: Date | string | null
    privacyAccepted?: boolean
    privacyVersion?: string | null
    privacyAcceptedAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    serviceRequests?: ServiceRequestCreateNestedManyWithoutUserInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
    incidentReports?: IncidentReportCreateNestedManyWithoutReporterInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    chatMessages?: ChatMessageCreateNestedManyWithoutSenderInput
    workshop?: WorkshopCreateNestedOneWithoutUserInput
  }

  export type UserProfileUncheckedCreateWithoutMotorcyclesInput = {
    id?: string
    clerkUserId: string
    role?: $Enums.UserRole
    email?: string | null
    phone?: string | null
    name?: string | null
    district?: string | null
    avatarUrl?: string | null
    notifChannel?: $Enums.NotificationChannel
    phoneVisible?: boolean
    termsAccepted?: boolean
    termsVersion?: string | null
    termsAcceptedAt?: Date | string | null
    privacyAccepted?: boolean
    privacyVersion?: string | null
    privacyAcceptedAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    serviceRequests?: ServiceRequestUncheckedCreateNestedManyWithoutUserInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
    incidentReports?: IncidentReportUncheckedCreateNestedManyWithoutReporterInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    chatMessages?: ChatMessageUncheckedCreateNestedManyWithoutSenderInput
    workshop?: WorkshopUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserProfileCreateOrConnectWithoutMotorcyclesInput = {
    where: UserProfileWhereUniqueInput
    create: XOR<UserProfileCreateWithoutMotorcyclesInput, UserProfileUncheckedCreateWithoutMotorcyclesInput>
  }

  export type ServiceRequestCreateWithoutMotorcycleInput = {
    id?: string
    description: string
    district: string
    urgency?: $Enums.UrgencyLevel
    status?: $Enums.ServiceRequestStatus
    completionScore?: number
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserProfileCreateNestedOneWithoutServiceRequestsInput
    category: CategoryCreateNestedOneWithoutServiceRequestsInput
    media?: RequestMediaCreateNestedManyWithoutRequestInput
    guideAnswers?: GuideAnswerCreateNestedManyWithoutRequestInput
    quotes?: QuoteCreateNestedManyWithoutRequestInput
    statusHistory?: RequestStatusHistoryCreateNestedManyWithoutRequestInput
    notifications?: NotificationCreateNestedManyWithoutRequestInput
    workOrder?: WorkOrderCreateNestedOneWithoutRequestInput
    chatMessages?: ChatMessageCreateNestedManyWithoutRequestInput
    aiSuggestions?: AiSuggestionCreateNestedManyWithoutRequestInput
  }

  export type ServiceRequestUncheckedCreateWithoutMotorcycleInput = {
    id?: string
    userId: string
    categoryId: string
    description: string
    district: string
    urgency?: $Enums.UrgencyLevel
    status?: $Enums.ServiceRequestStatus
    completionScore?: number
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    media?: RequestMediaUncheckedCreateNestedManyWithoutRequestInput
    guideAnswers?: GuideAnswerUncheckedCreateNestedManyWithoutRequestInput
    quotes?: QuoteUncheckedCreateNestedManyWithoutRequestInput
    statusHistory?: RequestStatusHistoryUncheckedCreateNestedManyWithoutRequestInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutRequestInput
    workOrder?: WorkOrderUncheckedCreateNestedOneWithoutRequestInput
    chatMessages?: ChatMessageUncheckedCreateNestedManyWithoutRequestInput
    aiSuggestions?: AiSuggestionUncheckedCreateNestedManyWithoutRequestInput
  }

  export type ServiceRequestCreateOrConnectWithoutMotorcycleInput = {
    where: ServiceRequestWhereUniqueInput
    create: XOR<ServiceRequestCreateWithoutMotorcycleInput, ServiceRequestUncheckedCreateWithoutMotorcycleInput>
  }

  export type ServiceRequestCreateManyMotorcycleInputEnvelope = {
    data: ServiceRequestCreateManyMotorcycleInput | ServiceRequestCreateManyMotorcycleInput[]
    skipDuplicates?: boolean
  }

  export type UserProfileUpsertWithoutMotorcyclesInput = {
    update: XOR<UserProfileUpdateWithoutMotorcyclesInput, UserProfileUncheckedUpdateWithoutMotorcyclesInput>
    create: XOR<UserProfileCreateWithoutMotorcyclesInput, UserProfileUncheckedCreateWithoutMotorcyclesInput>
    where?: UserProfileWhereInput
  }

  export type UserProfileUpdateToOneWithWhereWithoutMotorcyclesInput = {
    where?: UserProfileWhereInput
    data: XOR<UserProfileUpdateWithoutMotorcyclesInput, UserProfileUncheckedUpdateWithoutMotorcyclesInput>
  }

  export type UserProfileUpdateWithoutMotorcyclesInput = {
    id?: StringFieldUpdateOperationsInput | string
    clerkUserId?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    notifChannel?: EnumNotificationChannelFieldUpdateOperationsInput | $Enums.NotificationChannel
    phoneVisible?: BoolFieldUpdateOperationsInput | boolean
    termsAccepted?: BoolFieldUpdateOperationsInput | boolean
    termsVersion?: NullableStringFieldUpdateOperationsInput | string | null
    termsAcceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    privacyAccepted?: BoolFieldUpdateOperationsInput | boolean
    privacyVersion?: NullableStringFieldUpdateOperationsInput | string | null
    privacyAcceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    serviceRequests?: ServiceRequestUpdateManyWithoutUserNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
    incidentReports?: IncidentReportUpdateManyWithoutReporterNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    chatMessages?: ChatMessageUpdateManyWithoutSenderNestedInput
    workshop?: WorkshopUpdateOneWithoutUserNestedInput
  }

  export type UserProfileUncheckedUpdateWithoutMotorcyclesInput = {
    id?: StringFieldUpdateOperationsInput | string
    clerkUserId?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    notifChannel?: EnumNotificationChannelFieldUpdateOperationsInput | $Enums.NotificationChannel
    phoneVisible?: BoolFieldUpdateOperationsInput | boolean
    termsAccepted?: BoolFieldUpdateOperationsInput | boolean
    termsVersion?: NullableStringFieldUpdateOperationsInput | string | null
    termsAcceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    privacyAccepted?: BoolFieldUpdateOperationsInput | boolean
    privacyVersion?: NullableStringFieldUpdateOperationsInput | string | null
    privacyAcceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    serviceRequests?: ServiceRequestUncheckedUpdateManyWithoutUserNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
    incidentReports?: IncidentReportUncheckedUpdateManyWithoutReporterNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    chatMessages?: ChatMessageUncheckedUpdateManyWithoutSenderNestedInput
    workshop?: WorkshopUncheckedUpdateOneWithoutUserNestedInput
  }

  export type ServiceRequestUpsertWithWhereUniqueWithoutMotorcycleInput = {
    where: ServiceRequestWhereUniqueInput
    update: XOR<ServiceRequestUpdateWithoutMotorcycleInput, ServiceRequestUncheckedUpdateWithoutMotorcycleInput>
    create: XOR<ServiceRequestCreateWithoutMotorcycleInput, ServiceRequestUncheckedCreateWithoutMotorcycleInput>
  }

  export type ServiceRequestUpdateWithWhereUniqueWithoutMotorcycleInput = {
    where: ServiceRequestWhereUniqueInput
    data: XOR<ServiceRequestUpdateWithoutMotorcycleInput, ServiceRequestUncheckedUpdateWithoutMotorcycleInput>
  }

  export type ServiceRequestUpdateManyWithWhereWithoutMotorcycleInput = {
    where: ServiceRequestScalarWhereInput
    data: XOR<ServiceRequestUpdateManyMutationInput, ServiceRequestUncheckedUpdateManyWithoutMotorcycleInput>
  }

  export type CategoryCreateWithoutChildrenInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    version?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    parent?: CategoryCreateNestedOneWithoutChildrenInput
    guideQuestions?: GuideQuestionCreateNestedManyWithoutCategoryInput
    serviceRequests?: ServiceRequestCreateNestedManyWithoutCategoryInput
    workshopCategories?: WorkshopCategoryCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUncheckedCreateWithoutChildrenInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    parentId?: string | null
    version?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    guideQuestions?: GuideQuestionUncheckedCreateNestedManyWithoutCategoryInput
    serviceRequests?: ServiceRequestUncheckedCreateNestedManyWithoutCategoryInput
    workshopCategories?: WorkshopCategoryUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type CategoryCreateOrConnectWithoutChildrenInput = {
    where: CategoryWhereUniqueInput
    create: XOR<CategoryCreateWithoutChildrenInput, CategoryUncheckedCreateWithoutChildrenInput>
  }

  export type CategoryCreateWithoutParentInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    version?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    children?: CategoryCreateNestedManyWithoutParentInput
    guideQuestions?: GuideQuestionCreateNestedManyWithoutCategoryInput
    serviceRequests?: ServiceRequestCreateNestedManyWithoutCategoryInput
    workshopCategories?: WorkshopCategoryCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUncheckedCreateWithoutParentInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    version?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    children?: CategoryUncheckedCreateNestedManyWithoutParentInput
    guideQuestions?: GuideQuestionUncheckedCreateNestedManyWithoutCategoryInput
    serviceRequests?: ServiceRequestUncheckedCreateNestedManyWithoutCategoryInput
    workshopCategories?: WorkshopCategoryUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type CategoryCreateOrConnectWithoutParentInput = {
    where: CategoryWhereUniqueInput
    create: XOR<CategoryCreateWithoutParentInput, CategoryUncheckedCreateWithoutParentInput>
  }

  export type CategoryCreateManyParentInputEnvelope = {
    data: CategoryCreateManyParentInput | CategoryCreateManyParentInput[]
    skipDuplicates?: boolean
  }

  export type GuideQuestionCreateWithoutCategoryInput = {
    id?: string
    question: string
    inputType?: string
    options?: string | null
    order?: number
    isActive?: boolean
    createdAt?: Date | string
    answers?: GuideAnswerCreateNestedManyWithoutQuestionInput
  }

  export type GuideQuestionUncheckedCreateWithoutCategoryInput = {
    id?: string
    question: string
    inputType?: string
    options?: string | null
    order?: number
    isActive?: boolean
    createdAt?: Date | string
    answers?: GuideAnswerUncheckedCreateNestedManyWithoutQuestionInput
  }

  export type GuideQuestionCreateOrConnectWithoutCategoryInput = {
    where: GuideQuestionWhereUniqueInput
    create: XOR<GuideQuestionCreateWithoutCategoryInput, GuideQuestionUncheckedCreateWithoutCategoryInput>
  }

  export type GuideQuestionCreateManyCategoryInputEnvelope = {
    data: GuideQuestionCreateManyCategoryInput | GuideQuestionCreateManyCategoryInput[]
    skipDuplicates?: boolean
  }

  export type ServiceRequestCreateWithoutCategoryInput = {
    id?: string
    description: string
    district: string
    urgency?: $Enums.UrgencyLevel
    status?: $Enums.ServiceRequestStatus
    completionScore?: number
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserProfileCreateNestedOneWithoutServiceRequestsInput
    motorcycle: MotorcycleCreateNestedOneWithoutServiceRequestsInput
    media?: RequestMediaCreateNestedManyWithoutRequestInput
    guideAnswers?: GuideAnswerCreateNestedManyWithoutRequestInput
    quotes?: QuoteCreateNestedManyWithoutRequestInput
    statusHistory?: RequestStatusHistoryCreateNestedManyWithoutRequestInput
    notifications?: NotificationCreateNestedManyWithoutRequestInput
    workOrder?: WorkOrderCreateNestedOneWithoutRequestInput
    chatMessages?: ChatMessageCreateNestedManyWithoutRequestInput
    aiSuggestions?: AiSuggestionCreateNestedManyWithoutRequestInput
  }

  export type ServiceRequestUncheckedCreateWithoutCategoryInput = {
    id?: string
    userId: string
    motorcycleId: string
    description: string
    district: string
    urgency?: $Enums.UrgencyLevel
    status?: $Enums.ServiceRequestStatus
    completionScore?: number
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    media?: RequestMediaUncheckedCreateNestedManyWithoutRequestInput
    guideAnswers?: GuideAnswerUncheckedCreateNestedManyWithoutRequestInput
    quotes?: QuoteUncheckedCreateNestedManyWithoutRequestInput
    statusHistory?: RequestStatusHistoryUncheckedCreateNestedManyWithoutRequestInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutRequestInput
    workOrder?: WorkOrderUncheckedCreateNestedOneWithoutRequestInput
    chatMessages?: ChatMessageUncheckedCreateNestedManyWithoutRequestInput
    aiSuggestions?: AiSuggestionUncheckedCreateNestedManyWithoutRequestInput
  }

  export type ServiceRequestCreateOrConnectWithoutCategoryInput = {
    where: ServiceRequestWhereUniqueInput
    create: XOR<ServiceRequestCreateWithoutCategoryInput, ServiceRequestUncheckedCreateWithoutCategoryInput>
  }

  export type ServiceRequestCreateManyCategoryInputEnvelope = {
    data: ServiceRequestCreateManyCategoryInput | ServiceRequestCreateManyCategoryInput[]
    skipDuplicates?: boolean
  }

  export type WorkshopCategoryCreateWithoutCategoryInput = {
    id?: string
    workshop: WorkshopCreateNestedOneWithoutCategoriesInput
  }

  export type WorkshopCategoryUncheckedCreateWithoutCategoryInput = {
    id?: string
    workshopId: string
  }

  export type WorkshopCategoryCreateOrConnectWithoutCategoryInput = {
    where: WorkshopCategoryWhereUniqueInput
    create: XOR<WorkshopCategoryCreateWithoutCategoryInput, WorkshopCategoryUncheckedCreateWithoutCategoryInput>
  }

  export type WorkshopCategoryCreateManyCategoryInputEnvelope = {
    data: WorkshopCategoryCreateManyCategoryInput | WorkshopCategoryCreateManyCategoryInput[]
    skipDuplicates?: boolean
  }

  export type CategoryUpsertWithoutChildrenInput = {
    update: XOR<CategoryUpdateWithoutChildrenInput, CategoryUncheckedUpdateWithoutChildrenInput>
    create: XOR<CategoryCreateWithoutChildrenInput, CategoryUncheckedCreateWithoutChildrenInput>
    where?: CategoryWhereInput
  }

  export type CategoryUpdateToOneWithWhereWithoutChildrenInput = {
    where?: CategoryWhereInput
    data: XOR<CategoryUpdateWithoutChildrenInput, CategoryUncheckedUpdateWithoutChildrenInput>
  }

  export type CategoryUpdateWithoutChildrenInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parent?: CategoryUpdateOneWithoutChildrenNestedInput
    guideQuestions?: GuideQuestionUpdateManyWithoutCategoryNestedInput
    serviceRequests?: ServiceRequestUpdateManyWithoutCategoryNestedInput
    workshopCategories?: WorkshopCategoryUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryUncheckedUpdateWithoutChildrenInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    guideQuestions?: GuideQuestionUncheckedUpdateManyWithoutCategoryNestedInput
    serviceRequests?: ServiceRequestUncheckedUpdateManyWithoutCategoryNestedInput
    workshopCategories?: WorkshopCategoryUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryUpsertWithWhereUniqueWithoutParentInput = {
    where: CategoryWhereUniqueInput
    update: XOR<CategoryUpdateWithoutParentInput, CategoryUncheckedUpdateWithoutParentInput>
    create: XOR<CategoryCreateWithoutParentInput, CategoryUncheckedCreateWithoutParentInput>
  }

  export type CategoryUpdateWithWhereUniqueWithoutParentInput = {
    where: CategoryWhereUniqueInput
    data: XOR<CategoryUpdateWithoutParentInput, CategoryUncheckedUpdateWithoutParentInput>
  }

  export type CategoryUpdateManyWithWhereWithoutParentInput = {
    where: CategoryScalarWhereInput
    data: XOR<CategoryUpdateManyMutationInput, CategoryUncheckedUpdateManyWithoutParentInput>
  }

  export type CategoryScalarWhereInput = {
    AND?: CategoryScalarWhereInput | CategoryScalarWhereInput[]
    OR?: CategoryScalarWhereInput[]
    NOT?: CategoryScalarWhereInput | CategoryScalarWhereInput[]
    id?: StringFilter<"Category"> | string
    name?: StringFilter<"Category"> | string
    slug?: StringFilter<"Category"> | string
    description?: StringNullableFilter<"Category"> | string | null
    parentId?: StringNullableFilter<"Category"> | string | null
    version?: IntFilter<"Category"> | number
    isActive?: BoolFilter<"Category"> | boolean
    createdAt?: DateTimeFilter<"Category"> | Date | string
    updatedAt?: DateTimeFilter<"Category"> | Date | string
  }

  export type GuideQuestionUpsertWithWhereUniqueWithoutCategoryInput = {
    where: GuideQuestionWhereUniqueInput
    update: XOR<GuideQuestionUpdateWithoutCategoryInput, GuideQuestionUncheckedUpdateWithoutCategoryInput>
    create: XOR<GuideQuestionCreateWithoutCategoryInput, GuideQuestionUncheckedCreateWithoutCategoryInput>
  }

  export type GuideQuestionUpdateWithWhereUniqueWithoutCategoryInput = {
    where: GuideQuestionWhereUniqueInput
    data: XOR<GuideQuestionUpdateWithoutCategoryInput, GuideQuestionUncheckedUpdateWithoutCategoryInput>
  }

  export type GuideQuestionUpdateManyWithWhereWithoutCategoryInput = {
    where: GuideQuestionScalarWhereInput
    data: XOR<GuideQuestionUpdateManyMutationInput, GuideQuestionUncheckedUpdateManyWithoutCategoryInput>
  }

  export type GuideQuestionScalarWhereInput = {
    AND?: GuideQuestionScalarWhereInput | GuideQuestionScalarWhereInput[]
    OR?: GuideQuestionScalarWhereInput[]
    NOT?: GuideQuestionScalarWhereInput | GuideQuestionScalarWhereInput[]
    id?: StringFilter<"GuideQuestion"> | string
    categoryId?: StringFilter<"GuideQuestion"> | string
    question?: StringFilter<"GuideQuestion"> | string
    inputType?: StringFilter<"GuideQuestion"> | string
    options?: StringNullableFilter<"GuideQuestion"> | string | null
    order?: IntFilter<"GuideQuestion"> | number
    isActive?: BoolFilter<"GuideQuestion"> | boolean
    createdAt?: DateTimeFilter<"GuideQuestion"> | Date | string
  }

  export type ServiceRequestUpsertWithWhereUniqueWithoutCategoryInput = {
    where: ServiceRequestWhereUniqueInput
    update: XOR<ServiceRequestUpdateWithoutCategoryInput, ServiceRequestUncheckedUpdateWithoutCategoryInput>
    create: XOR<ServiceRequestCreateWithoutCategoryInput, ServiceRequestUncheckedCreateWithoutCategoryInput>
  }

  export type ServiceRequestUpdateWithWhereUniqueWithoutCategoryInput = {
    where: ServiceRequestWhereUniqueInput
    data: XOR<ServiceRequestUpdateWithoutCategoryInput, ServiceRequestUncheckedUpdateWithoutCategoryInput>
  }

  export type ServiceRequestUpdateManyWithWhereWithoutCategoryInput = {
    where: ServiceRequestScalarWhereInput
    data: XOR<ServiceRequestUpdateManyMutationInput, ServiceRequestUncheckedUpdateManyWithoutCategoryInput>
  }

  export type WorkshopCategoryUpsertWithWhereUniqueWithoutCategoryInput = {
    where: WorkshopCategoryWhereUniqueInput
    update: XOR<WorkshopCategoryUpdateWithoutCategoryInput, WorkshopCategoryUncheckedUpdateWithoutCategoryInput>
    create: XOR<WorkshopCategoryCreateWithoutCategoryInput, WorkshopCategoryUncheckedCreateWithoutCategoryInput>
  }

  export type WorkshopCategoryUpdateWithWhereUniqueWithoutCategoryInput = {
    where: WorkshopCategoryWhereUniqueInput
    data: XOR<WorkshopCategoryUpdateWithoutCategoryInput, WorkshopCategoryUncheckedUpdateWithoutCategoryInput>
  }

  export type WorkshopCategoryUpdateManyWithWhereWithoutCategoryInput = {
    where: WorkshopCategoryScalarWhereInput
    data: XOR<WorkshopCategoryUpdateManyMutationInput, WorkshopCategoryUncheckedUpdateManyWithoutCategoryInput>
  }

  export type WorkshopCategoryScalarWhereInput = {
    AND?: WorkshopCategoryScalarWhereInput | WorkshopCategoryScalarWhereInput[]
    OR?: WorkshopCategoryScalarWhereInput[]
    NOT?: WorkshopCategoryScalarWhereInput | WorkshopCategoryScalarWhereInput[]
    id?: StringFilter<"WorkshopCategory"> | string
    workshopId?: StringFilter<"WorkshopCategory"> | string
    categoryId?: StringFilter<"WorkshopCategory"> | string
  }

  export type CategoryCreateWithoutGuideQuestionsInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    version?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    parent?: CategoryCreateNestedOneWithoutChildrenInput
    children?: CategoryCreateNestedManyWithoutParentInput
    serviceRequests?: ServiceRequestCreateNestedManyWithoutCategoryInput
    workshopCategories?: WorkshopCategoryCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUncheckedCreateWithoutGuideQuestionsInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    parentId?: string | null
    version?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    children?: CategoryUncheckedCreateNestedManyWithoutParentInput
    serviceRequests?: ServiceRequestUncheckedCreateNestedManyWithoutCategoryInput
    workshopCategories?: WorkshopCategoryUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type CategoryCreateOrConnectWithoutGuideQuestionsInput = {
    where: CategoryWhereUniqueInput
    create: XOR<CategoryCreateWithoutGuideQuestionsInput, CategoryUncheckedCreateWithoutGuideQuestionsInput>
  }

  export type GuideAnswerCreateWithoutQuestionInput = {
    id?: string
    answer: string
    createdAt?: Date | string
    request: ServiceRequestCreateNestedOneWithoutGuideAnswersInput
  }

  export type GuideAnswerUncheckedCreateWithoutQuestionInput = {
    id?: string
    requestId: string
    answer: string
    createdAt?: Date | string
  }

  export type GuideAnswerCreateOrConnectWithoutQuestionInput = {
    where: GuideAnswerWhereUniqueInput
    create: XOR<GuideAnswerCreateWithoutQuestionInput, GuideAnswerUncheckedCreateWithoutQuestionInput>
  }

  export type GuideAnswerCreateManyQuestionInputEnvelope = {
    data: GuideAnswerCreateManyQuestionInput | GuideAnswerCreateManyQuestionInput[]
    skipDuplicates?: boolean
  }

  export type CategoryUpsertWithoutGuideQuestionsInput = {
    update: XOR<CategoryUpdateWithoutGuideQuestionsInput, CategoryUncheckedUpdateWithoutGuideQuestionsInput>
    create: XOR<CategoryCreateWithoutGuideQuestionsInput, CategoryUncheckedCreateWithoutGuideQuestionsInput>
    where?: CategoryWhereInput
  }

  export type CategoryUpdateToOneWithWhereWithoutGuideQuestionsInput = {
    where?: CategoryWhereInput
    data: XOR<CategoryUpdateWithoutGuideQuestionsInput, CategoryUncheckedUpdateWithoutGuideQuestionsInput>
  }

  export type CategoryUpdateWithoutGuideQuestionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parent?: CategoryUpdateOneWithoutChildrenNestedInput
    children?: CategoryUpdateManyWithoutParentNestedInput
    serviceRequests?: ServiceRequestUpdateManyWithoutCategoryNestedInput
    workshopCategories?: WorkshopCategoryUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryUncheckedUpdateWithoutGuideQuestionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: CategoryUncheckedUpdateManyWithoutParentNestedInput
    serviceRequests?: ServiceRequestUncheckedUpdateManyWithoutCategoryNestedInput
    workshopCategories?: WorkshopCategoryUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type GuideAnswerUpsertWithWhereUniqueWithoutQuestionInput = {
    where: GuideAnswerWhereUniqueInput
    update: XOR<GuideAnswerUpdateWithoutQuestionInput, GuideAnswerUncheckedUpdateWithoutQuestionInput>
    create: XOR<GuideAnswerCreateWithoutQuestionInput, GuideAnswerUncheckedCreateWithoutQuestionInput>
  }

  export type GuideAnswerUpdateWithWhereUniqueWithoutQuestionInput = {
    where: GuideAnswerWhereUniqueInput
    data: XOR<GuideAnswerUpdateWithoutQuestionInput, GuideAnswerUncheckedUpdateWithoutQuestionInput>
  }

  export type GuideAnswerUpdateManyWithWhereWithoutQuestionInput = {
    where: GuideAnswerScalarWhereInput
    data: XOR<GuideAnswerUpdateManyMutationInput, GuideAnswerUncheckedUpdateManyWithoutQuestionInput>
  }

  export type GuideAnswerScalarWhereInput = {
    AND?: GuideAnswerScalarWhereInput | GuideAnswerScalarWhereInput[]
    OR?: GuideAnswerScalarWhereInput[]
    NOT?: GuideAnswerScalarWhereInput | GuideAnswerScalarWhereInput[]
    id?: StringFilter<"GuideAnswer"> | string
    questionId?: StringFilter<"GuideAnswer"> | string
    requestId?: StringFilter<"GuideAnswer"> | string
    answer?: StringFilter<"GuideAnswer"> | string
    createdAt?: DateTimeFilter<"GuideAnswer"> | Date | string
  }

  export type GuideQuestionCreateWithoutAnswersInput = {
    id?: string
    question: string
    inputType?: string
    options?: string | null
    order?: number
    isActive?: boolean
    createdAt?: Date | string
    category: CategoryCreateNestedOneWithoutGuideQuestionsInput
  }

  export type GuideQuestionUncheckedCreateWithoutAnswersInput = {
    id?: string
    categoryId: string
    question: string
    inputType?: string
    options?: string | null
    order?: number
    isActive?: boolean
    createdAt?: Date | string
  }

  export type GuideQuestionCreateOrConnectWithoutAnswersInput = {
    where: GuideQuestionWhereUniqueInput
    create: XOR<GuideQuestionCreateWithoutAnswersInput, GuideQuestionUncheckedCreateWithoutAnswersInput>
  }

  export type ServiceRequestCreateWithoutGuideAnswersInput = {
    id?: string
    description: string
    district: string
    urgency?: $Enums.UrgencyLevel
    status?: $Enums.ServiceRequestStatus
    completionScore?: number
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserProfileCreateNestedOneWithoutServiceRequestsInput
    motorcycle: MotorcycleCreateNestedOneWithoutServiceRequestsInput
    category: CategoryCreateNestedOneWithoutServiceRequestsInput
    media?: RequestMediaCreateNestedManyWithoutRequestInput
    quotes?: QuoteCreateNestedManyWithoutRequestInput
    statusHistory?: RequestStatusHistoryCreateNestedManyWithoutRequestInput
    notifications?: NotificationCreateNestedManyWithoutRequestInput
    workOrder?: WorkOrderCreateNestedOneWithoutRequestInput
    chatMessages?: ChatMessageCreateNestedManyWithoutRequestInput
    aiSuggestions?: AiSuggestionCreateNestedManyWithoutRequestInput
  }

  export type ServiceRequestUncheckedCreateWithoutGuideAnswersInput = {
    id?: string
    userId: string
    motorcycleId: string
    categoryId: string
    description: string
    district: string
    urgency?: $Enums.UrgencyLevel
    status?: $Enums.ServiceRequestStatus
    completionScore?: number
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    media?: RequestMediaUncheckedCreateNestedManyWithoutRequestInput
    quotes?: QuoteUncheckedCreateNestedManyWithoutRequestInput
    statusHistory?: RequestStatusHistoryUncheckedCreateNestedManyWithoutRequestInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutRequestInput
    workOrder?: WorkOrderUncheckedCreateNestedOneWithoutRequestInput
    chatMessages?: ChatMessageUncheckedCreateNestedManyWithoutRequestInput
    aiSuggestions?: AiSuggestionUncheckedCreateNestedManyWithoutRequestInput
  }

  export type ServiceRequestCreateOrConnectWithoutGuideAnswersInput = {
    where: ServiceRequestWhereUniqueInput
    create: XOR<ServiceRequestCreateWithoutGuideAnswersInput, ServiceRequestUncheckedCreateWithoutGuideAnswersInput>
  }

  export type GuideQuestionUpsertWithoutAnswersInput = {
    update: XOR<GuideQuestionUpdateWithoutAnswersInput, GuideQuestionUncheckedUpdateWithoutAnswersInput>
    create: XOR<GuideQuestionCreateWithoutAnswersInput, GuideQuestionUncheckedCreateWithoutAnswersInput>
    where?: GuideQuestionWhereInput
  }

  export type GuideQuestionUpdateToOneWithWhereWithoutAnswersInput = {
    where?: GuideQuestionWhereInput
    data: XOR<GuideQuestionUpdateWithoutAnswersInput, GuideQuestionUncheckedUpdateWithoutAnswersInput>
  }

  export type GuideQuestionUpdateWithoutAnswersInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    inputType?: StringFieldUpdateOperationsInput | string
    options?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: CategoryUpdateOneRequiredWithoutGuideQuestionsNestedInput
  }

  export type GuideQuestionUncheckedUpdateWithoutAnswersInput = {
    id?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    inputType?: StringFieldUpdateOperationsInput | string
    options?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceRequestUpsertWithoutGuideAnswersInput = {
    update: XOR<ServiceRequestUpdateWithoutGuideAnswersInput, ServiceRequestUncheckedUpdateWithoutGuideAnswersInput>
    create: XOR<ServiceRequestCreateWithoutGuideAnswersInput, ServiceRequestUncheckedCreateWithoutGuideAnswersInput>
    where?: ServiceRequestWhereInput
  }

  export type ServiceRequestUpdateToOneWithWhereWithoutGuideAnswersInput = {
    where?: ServiceRequestWhereInput
    data: XOR<ServiceRequestUpdateWithoutGuideAnswersInput, ServiceRequestUncheckedUpdateWithoutGuideAnswersInput>
  }

  export type ServiceRequestUpdateWithoutGuideAnswersInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    district?: StringFieldUpdateOperationsInput | string
    urgency?: EnumUrgencyLevelFieldUpdateOperationsInput | $Enums.UrgencyLevel
    status?: EnumServiceRequestStatusFieldUpdateOperationsInput | $Enums.ServiceRequestStatus
    completionScore?: IntFieldUpdateOperationsInput | number
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserProfileUpdateOneRequiredWithoutServiceRequestsNestedInput
    motorcycle?: MotorcycleUpdateOneRequiredWithoutServiceRequestsNestedInput
    category?: CategoryUpdateOneRequiredWithoutServiceRequestsNestedInput
    media?: RequestMediaUpdateManyWithoutRequestNestedInput
    quotes?: QuoteUpdateManyWithoutRequestNestedInput
    statusHistory?: RequestStatusHistoryUpdateManyWithoutRequestNestedInput
    notifications?: NotificationUpdateManyWithoutRequestNestedInput
    workOrder?: WorkOrderUpdateOneWithoutRequestNestedInput
    chatMessages?: ChatMessageUpdateManyWithoutRequestNestedInput
    aiSuggestions?: AiSuggestionUpdateManyWithoutRequestNestedInput
  }

  export type ServiceRequestUncheckedUpdateWithoutGuideAnswersInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    motorcycleId?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    district?: StringFieldUpdateOperationsInput | string
    urgency?: EnumUrgencyLevelFieldUpdateOperationsInput | $Enums.UrgencyLevel
    status?: EnumServiceRequestStatusFieldUpdateOperationsInput | $Enums.ServiceRequestStatus
    completionScore?: IntFieldUpdateOperationsInput | number
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    media?: RequestMediaUncheckedUpdateManyWithoutRequestNestedInput
    quotes?: QuoteUncheckedUpdateManyWithoutRequestNestedInput
    statusHistory?: RequestStatusHistoryUncheckedUpdateManyWithoutRequestNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutRequestNestedInput
    workOrder?: WorkOrderUncheckedUpdateOneWithoutRequestNestedInput
    chatMessages?: ChatMessageUncheckedUpdateManyWithoutRequestNestedInput
    aiSuggestions?: AiSuggestionUncheckedUpdateManyWithoutRequestNestedInput
  }

  export type UserProfileCreateWithoutServiceRequestsInput = {
    id?: string
    clerkUserId: string
    role?: $Enums.UserRole
    email?: string | null
    phone?: string | null
    name?: string | null
    district?: string | null
    avatarUrl?: string | null
    notifChannel?: $Enums.NotificationChannel
    phoneVisible?: boolean
    termsAccepted?: boolean
    termsVersion?: string | null
    termsAcceptedAt?: Date | string | null
    privacyAccepted?: boolean
    privacyVersion?: string | null
    privacyAcceptedAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    motorcycles?: MotorcycleCreateNestedManyWithoutUserInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
    incidentReports?: IncidentReportCreateNestedManyWithoutReporterInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    chatMessages?: ChatMessageCreateNestedManyWithoutSenderInput
    workshop?: WorkshopCreateNestedOneWithoutUserInput
  }

  export type UserProfileUncheckedCreateWithoutServiceRequestsInput = {
    id?: string
    clerkUserId: string
    role?: $Enums.UserRole
    email?: string | null
    phone?: string | null
    name?: string | null
    district?: string | null
    avatarUrl?: string | null
    notifChannel?: $Enums.NotificationChannel
    phoneVisible?: boolean
    termsAccepted?: boolean
    termsVersion?: string | null
    termsAcceptedAt?: Date | string | null
    privacyAccepted?: boolean
    privacyVersion?: string | null
    privacyAcceptedAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    motorcycles?: MotorcycleUncheckedCreateNestedManyWithoutUserInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
    incidentReports?: IncidentReportUncheckedCreateNestedManyWithoutReporterInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    chatMessages?: ChatMessageUncheckedCreateNestedManyWithoutSenderInput
    workshop?: WorkshopUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserProfileCreateOrConnectWithoutServiceRequestsInput = {
    where: UserProfileWhereUniqueInput
    create: XOR<UserProfileCreateWithoutServiceRequestsInput, UserProfileUncheckedCreateWithoutServiceRequestsInput>
  }

  export type MotorcycleCreateWithoutServiceRequestsInput = {
    id?: string
    brand: string
    model: string
    year: number
    displacement?: number | null
    use?: $Enums.MotorcycleUse | null
    kmApprox?: number | null
    placa?: string | null
    alias?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserProfileCreateNestedOneWithoutMotorcyclesInput
  }

  export type MotorcycleUncheckedCreateWithoutServiceRequestsInput = {
    id?: string
    userId: string
    brand: string
    model: string
    year: number
    displacement?: number | null
    use?: $Enums.MotorcycleUse | null
    kmApprox?: number | null
    placa?: string | null
    alias?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MotorcycleCreateOrConnectWithoutServiceRequestsInput = {
    where: MotorcycleWhereUniqueInput
    create: XOR<MotorcycleCreateWithoutServiceRequestsInput, MotorcycleUncheckedCreateWithoutServiceRequestsInput>
  }

  export type CategoryCreateWithoutServiceRequestsInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    version?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    parent?: CategoryCreateNestedOneWithoutChildrenInput
    children?: CategoryCreateNestedManyWithoutParentInput
    guideQuestions?: GuideQuestionCreateNestedManyWithoutCategoryInput
    workshopCategories?: WorkshopCategoryCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUncheckedCreateWithoutServiceRequestsInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    parentId?: string | null
    version?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    children?: CategoryUncheckedCreateNestedManyWithoutParentInput
    guideQuestions?: GuideQuestionUncheckedCreateNestedManyWithoutCategoryInput
    workshopCategories?: WorkshopCategoryUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type CategoryCreateOrConnectWithoutServiceRequestsInput = {
    where: CategoryWhereUniqueInput
    create: XOR<CategoryCreateWithoutServiceRequestsInput, CategoryUncheckedCreateWithoutServiceRequestsInput>
  }

  export type RequestMediaCreateWithoutRequestInput = {
    id?: string
    url: string
    mediaType: $Enums.MediaType
    fileName?: string | null
    fileSize?: number | null
    createdAt?: Date | string
  }

  export type RequestMediaUncheckedCreateWithoutRequestInput = {
    id?: string
    url: string
    mediaType: $Enums.MediaType
    fileName?: string | null
    fileSize?: number | null
    createdAt?: Date | string
  }

  export type RequestMediaCreateOrConnectWithoutRequestInput = {
    where: RequestMediaWhereUniqueInput
    create: XOR<RequestMediaCreateWithoutRequestInput, RequestMediaUncheckedCreateWithoutRequestInput>
  }

  export type RequestMediaCreateManyRequestInputEnvelope = {
    data: RequestMediaCreateManyRequestInput | RequestMediaCreateManyRequestInput[]
    skipDuplicates?: boolean
  }

  export type GuideAnswerCreateWithoutRequestInput = {
    id?: string
    answer: string
    createdAt?: Date | string
    question: GuideQuestionCreateNestedOneWithoutAnswersInput
  }

  export type GuideAnswerUncheckedCreateWithoutRequestInput = {
    id?: string
    questionId: string
    answer: string
    createdAt?: Date | string
  }

  export type GuideAnswerCreateOrConnectWithoutRequestInput = {
    where: GuideAnswerWhereUniqueInput
    create: XOR<GuideAnswerCreateWithoutRequestInput, GuideAnswerUncheckedCreateWithoutRequestInput>
  }

  export type GuideAnswerCreateManyRequestInputEnvelope = {
    data: GuideAnswerCreateManyRequestInput | GuideAnswerCreateManyRequestInput[]
    skipDuplicates?: boolean
  }

  export type QuoteCreateWithoutRequestInput = {
    id?: string
    version?: number
    diagnosis: string
    laborCost: number
    totalParts?: number
    totalCost: number
    estimatedTime: string
    validUntil: Date | string
    notes?: string | null
    status?: $Enums.QuoteStatus
    rejectionReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    workshop: WorkshopCreateNestedOneWithoutQuotesInput
    parts?: QuotePartItemCreateNestedManyWithoutQuoteInput
    workOrder?: WorkOrderCreateNestedOneWithoutQuoteInput
    aiAnalysis?: AiQuoteAnalysisCreateNestedManyWithoutQuoteInput
  }

  export type QuoteUncheckedCreateWithoutRequestInput = {
    id?: string
    workshopId: string
    version?: number
    diagnosis: string
    laborCost: number
    totalParts?: number
    totalCost: number
    estimatedTime: string
    validUntil: Date | string
    notes?: string | null
    status?: $Enums.QuoteStatus
    rejectionReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    parts?: QuotePartItemUncheckedCreateNestedManyWithoutQuoteInput
    workOrder?: WorkOrderUncheckedCreateNestedOneWithoutQuoteInput
    aiAnalysis?: AiQuoteAnalysisUncheckedCreateNestedManyWithoutQuoteInput
  }

  export type QuoteCreateOrConnectWithoutRequestInput = {
    where: QuoteWhereUniqueInput
    create: XOR<QuoteCreateWithoutRequestInput, QuoteUncheckedCreateWithoutRequestInput>
  }

  export type QuoteCreateManyRequestInputEnvelope = {
    data: QuoteCreateManyRequestInput | QuoteCreateManyRequestInput[]
    skipDuplicates?: boolean
  }

  export type RequestStatusHistoryCreateWithoutRequestInput = {
    id?: string
    fromStatus?: $Enums.ServiceRequestStatus | null
    toStatus: $Enums.ServiceRequestStatus
    actorId?: string | null
    reason?: string | null
    createdAt?: Date | string
  }

  export type RequestStatusHistoryUncheckedCreateWithoutRequestInput = {
    id?: string
    fromStatus?: $Enums.ServiceRequestStatus | null
    toStatus: $Enums.ServiceRequestStatus
    actorId?: string | null
    reason?: string | null
    createdAt?: Date | string
  }

  export type RequestStatusHistoryCreateOrConnectWithoutRequestInput = {
    where: RequestStatusHistoryWhereUniqueInput
    create: XOR<RequestStatusHistoryCreateWithoutRequestInput, RequestStatusHistoryUncheckedCreateWithoutRequestInput>
  }

  export type RequestStatusHistoryCreateManyRequestInputEnvelope = {
    data: RequestStatusHistoryCreateManyRequestInput | RequestStatusHistoryCreateManyRequestInput[]
    skipDuplicates?: boolean
  }

  export type NotificationCreateWithoutRequestInput = {
    id?: string
    title: string
    body: string
    channel?: $Enums.NotificationChannel
    isRead?: boolean
    link?: string | null
    createdAt?: Date | string
    user: UserProfileCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateWithoutRequestInput = {
    id?: string
    userId: string
    title: string
    body: string
    channel?: $Enums.NotificationChannel
    isRead?: boolean
    link?: string | null
    createdAt?: Date | string
  }

  export type NotificationCreateOrConnectWithoutRequestInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutRequestInput, NotificationUncheckedCreateWithoutRequestInput>
  }

  export type NotificationCreateManyRequestInputEnvelope = {
    data: NotificationCreateManyRequestInput | NotificationCreateManyRequestInput[]
    skipDuplicates?: boolean
  }

  export type WorkOrderCreateWithoutRequestInput = {
    id?: string
    orderNumber: string
    diagnosis: string
    totalAgreed: number
    totalFinal?: number | null
    status?: $Enums.WorkOrderStatus
    userAcceptedAt?: Date | string | null
    workshopAcceptedAt?: Date | string | null
    startedAt?: Date | string | null
    startNote?: string | null
    completedAt?: Date | string | null
    closedAt?: Date | string | null
    closureChecklist?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    quote: QuoteCreateNestedOneWithoutWorkOrderInput
    workshop: WorkshopCreateNestedOneWithoutWorkOrdersInput
    changeRequests?: ChangeRequestCreateNestedManyWithoutWorkOrderInput
    evidences?: EvidenceCreateNestedManyWithoutWorkOrderInput
    review?: ReviewCreateNestedOneWithoutWorkOrderInput
    receipt?: ReceiptCreateNestedOneWithoutWorkOrderInput
  }

  export type WorkOrderUncheckedCreateWithoutRequestInput = {
    id?: string
    orderNumber: string
    quoteId: string
    workshopId: string
    diagnosis: string
    totalAgreed: number
    totalFinal?: number | null
    status?: $Enums.WorkOrderStatus
    userAcceptedAt?: Date | string | null
    workshopAcceptedAt?: Date | string | null
    startedAt?: Date | string | null
    startNote?: string | null
    completedAt?: Date | string | null
    closedAt?: Date | string | null
    closureChecklist?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    changeRequests?: ChangeRequestUncheckedCreateNestedManyWithoutWorkOrderInput
    evidences?: EvidenceUncheckedCreateNestedManyWithoutWorkOrderInput
    review?: ReviewUncheckedCreateNestedOneWithoutWorkOrderInput
    receipt?: ReceiptUncheckedCreateNestedOneWithoutWorkOrderInput
  }

  export type WorkOrderCreateOrConnectWithoutRequestInput = {
    where: WorkOrderWhereUniqueInput
    create: XOR<WorkOrderCreateWithoutRequestInput, WorkOrderUncheckedCreateWithoutRequestInput>
  }

  export type ChatMessageCreateWithoutRequestInput = {
    id?: string
    content: string
    imageUrl?: string | null
    isRead?: boolean
    createdAt?: Date | string
    sender: UserProfileCreateNestedOneWithoutChatMessagesInput
  }

  export type ChatMessageUncheckedCreateWithoutRequestInput = {
    id?: string
    senderId: string
    content: string
    imageUrl?: string | null
    isRead?: boolean
    createdAt?: Date | string
  }

  export type ChatMessageCreateOrConnectWithoutRequestInput = {
    where: ChatMessageWhereUniqueInput
    create: XOR<ChatMessageCreateWithoutRequestInput, ChatMessageUncheckedCreateWithoutRequestInput>
  }

  export type ChatMessageCreateManyRequestInputEnvelope = {
    data: ChatMessageCreateManyRequestInput | ChatMessageCreateManyRequestInput[]
    skipDuplicates?: boolean
  }

  export type AiSuggestionCreateWithoutRequestInput = {
    id?: string
    type: string
    input?: string | null
    output?: string | null
    confidence?: number | null
    modelVersion?: string | null
    isConclusive?: boolean
    disclaimer?: string | null
    createdAt?: Date | string
  }

  export type AiSuggestionUncheckedCreateWithoutRequestInput = {
    id?: string
    type: string
    input?: string | null
    output?: string | null
    confidence?: number | null
    modelVersion?: string | null
    isConclusive?: boolean
    disclaimer?: string | null
    createdAt?: Date | string
  }

  export type AiSuggestionCreateOrConnectWithoutRequestInput = {
    where: AiSuggestionWhereUniqueInput
    create: XOR<AiSuggestionCreateWithoutRequestInput, AiSuggestionUncheckedCreateWithoutRequestInput>
  }

  export type AiSuggestionCreateManyRequestInputEnvelope = {
    data: AiSuggestionCreateManyRequestInput | AiSuggestionCreateManyRequestInput[]
    skipDuplicates?: boolean
  }

  export type UserProfileUpsertWithoutServiceRequestsInput = {
    update: XOR<UserProfileUpdateWithoutServiceRequestsInput, UserProfileUncheckedUpdateWithoutServiceRequestsInput>
    create: XOR<UserProfileCreateWithoutServiceRequestsInput, UserProfileUncheckedCreateWithoutServiceRequestsInput>
    where?: UserProfileWhereInput
  }

  export type UserProfileUpdateToOneWithWhereWithoutServiceRequestsInput = {
    where?: UserProfileWhereInput
    data: XOR<UserProfileUpdateWithoutServiceRequestsInput, UserProfileUncheckedUpdateWithoutServiceRequestsInput>
  }

  export type UserProfileUpdateWithoutServiceRequestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    clerkUserId?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    notifChannel?: EnumNotificationChannelFieldUpdateOperationsInput | $Enums.NotificationChannel
    phoneVisible?: BoolFieldUpdateOperationsInput | boolean
    termsAccepted?: BoolFieldUpdateOperationsInput | boolean
    termsVersion?: NullableStringFieldUpdateOperationsInput | string | null
    termsAcceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    privacyAccepted?: BoolFieldUpdateOperationsInput | boolean
    privacyVersion?: NullableStringFieldUpdateOperationsInput | string | null
    privacyAcceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    motorcycles?: MotorcycleUpdateManyWithoutUserNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
    incidentReports?: IncidentReportUpdateManyWithoutReporterNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    chatMessages?: ChatMessageUpdateManyWithoutSenderNestedInput
    workshop?: WorkshopUpdateOneWithoutUserNestedInput
  }

  export type UserProfileUncheckedUpdateWithoutServiceRequestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    clerkUserId?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    notifChannel?: EnumNotificationChannelFieldUpdateOperationsInput | $Enums.NotificationChannel
    phoneVisible?: BoolFieldUpdateOperationsInput | boolean
    termsAccepted?: BoolFieldUpdateOperationsInput | boolean
    termsVersion?: NullableStringFieldUpdateOperationsInput | string | null
    termsAcceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    privacyAccepted?: BoolFieldUpdateOperationsInput | boolean
    privacyVersion?: NullableStringFieldUpdateOperationsInput | string | null
    privacyAcceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    motorcycles?: MotorcycleUncheckedUpdateManyWithoutUserNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
    incidentReports?: IncidentReportUncheckedUpdateManyWithoutReporterNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    chatMessages?: ChatMessageUncheckedUpdateManyWithoutSenderNestedInput
    workshop?: WorkshopUncheckedUpdateOneWithoutUserNestedInput
  }

  export type MotorcycleUpsertWithoutServiceRequestsInput = {
    update: XOR<MotorcycleUpdateWithoutServiceRequestsInput, MotorcycleUncheckedUpdateWithoutServiceRequestsInput>
    create: XOR<MotorcycleCreateWithoutServiceRequestsInput, MotorcycleUncheckedCreateWithoutServiceRequestsInput>
    where?: MotorcycleWhereInput
  }

  export type MotorcycleUpdateToOneWithWhereWithoutServiceRequestsInput = {
    where?: MotorcycleWhereInput
    data: XOR<MotorcycleUpdateWithoutServiceRequestsInput, MotorcycleUncheckedUpdateWithoutServiceRequestsInput>
  }

  export type MotorcycleUpdateWithoutServiceRequestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    brand?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    displacement?: NullableIntFieldUpdateOperationsInput | number | null
    use?: NullableEnumMotorcycleUseFieldUpdateOperationsInput | $Enums.MotorcycleUse | null
    kmApprox?: NullableIntFieldUpdateOperationsInput | number | null
    placa?: NullableStringFieldUpdateOperationsInput | string | null
    alias?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserProfileUpdateOneRequiredWithoutMotorcyclesNestedInput
  }

  export type MotorcycleUncheckedUpdateWithoutServiceRequestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    brand?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    displacement?: NullableIntFieldUpdateOperationsInput | number | null
    use?: NullableEnumMotorcycleUseFieldUpdateOperationsInput | $Enums.MotorcycleUse | null
    kmApprox?: NullableIntFieldUpdateOperationsInput | number | null
    placa?: NullableStringFieldUpdateOperationsInput | string | null
    alias?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CategoryUpsertWithoutServiceRequestsInput = {
    update: XOR<CategoryUpdateWithoutServiceRequestsInput, CategoryUncheckedUpdateWithoutServiceRequestsInput>
    create: XOR<CategoryCreateWithoutServiceRequestsInput, CategoryUncheckedCreateWithoutServiceRequestsInput>
    where?: CategoryWhereInput
  }

  export type CategoryUpdateToOneWithWhereWithoutServiceRequestsInput = {
    where?: CategoryWhereInput
    data: XOR<CategoryUpdateWithoutServiceRequestsInput, CategoryUncheckedUpdateWithoutServiceRequestsInput>
  }

  export type CategoryUpdateWithoutServiceRequestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parent?: CategoryUpdateOneWithoutChildrenNestedInput
    children?: CategoryUpdateManyWithoutParentNestedInput
    guideQuestions?: GuideQuestionUpdateManyWithoutCategoryNestedInput
    workshopCategories?: WorkshopCategoryUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryUncheckedUpdateWithoutServiceRequestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: CategoryUncheckedUpdateManyWithoutParentNestedInput
    guideQuestions?: GuideQuestionUncheckedUpdateManyWithoutCategoryNestedInput
    workshopCategories?: WorkshopCategoryUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type RequestMediaUpsertWithWhereUniqueWithoutRequestInput = {
    where: RequestMediaWhereUniqueInput
    update: XOR<RequestMediaUpdateWithoutRequestInput, RequestMediaUncheckedUpdateWithoutRequestInput>
    create: XOR<RequestMediaCreateWithoutRequestInput, RequestMediaUncheckedCreateWithoutRequestInput>
  }

  export type RequestMediaUpdateWithWhereUniqueWithoutRequestInput = {
    where: RequestMediaWhereUniqueInput
    data: XOR<RequestMediaUpdateWithoutRequestInput, RequestMediaUncheckedUpdateWithoutRequestInput>
  }

  export type RequestMediaUpdateManyWithWhereWithoutRequestInput = {
    where: RequestMediaScalarWhereInput
    data: XOR<RequestMediaUpdateManyMutationInput, RequestMediaUncheckedUpdateManyWithoutRequestInput>
  }

  export type RequestMediaScalarWhereInput = {
    AND?: RequestMediaScalarWhereInput | RequestMediaScalarWhereInput[]
    OR?: RequestMediaScalarWhereInput[]
    NOT?: RequestMediaScalarWhereInput | RequestMediaScalarWhereInput[]
    id?: StringFilter<"RequestMedia"> | string
    requestId?: StringFilter<"RequestMedia"> | string
    url?: StringFilter<"RequestMedia"> | string
    mediaType?: EnumMediaTypeFilter<"RequestMedia"> | $Enums.MediaType
    fileName?: StringNullableFilter<"RequestMedia"> | string | null
    fileSize?: IntNullableFilter<"RequestMedia"> | number | null
    createdAt?: DateTimeFilter<"RequestMedia"> | Date | string
  }

  export type GuideAnswerUpsertWithWhereUniqueWithoutRequestInput = {
    where: GuideAnswerWhereUniqueInput
    update: XOR<GuideAnswerUpdateWithoutRequestInput, GuideAnswerUncheckedUpdateWithoutRequestInput>
    create: XOR<GuideAnswerCreateWithoutRequestInput, GuideAnswerUncheckedCreateWithoutRequestInput>
  }

  export type GuideAnswerUpdateWithWhereUniqueWithoutRequestInput = {
    where: GuideAnswerWhereUniqueInput
    data: XOR<GuideAnswerUpdateWithoutRequestInput, GuideAnswerUncheckedUpdateWithoutRequestInput>
  }

  export type GuideAnswerUpdateManyWithWhereWithoutRequestInput = {
    where: GuideAnswerScalarWhereInput
    data: XOR<GuideAnswerUpdateManyMutationInput, GuideAnswerUncheckedUpdateManyWithoutRequestInput>
  }

  export type QuoteUpsertWithWhereUniqueWithoutRequestInput = {
    where: QuoteWhereUniqueInput
    update: XOR<QuoteUpdateWithoutRequestInput, QuoteUncheckedUpdateWithoutRequestInput>
    create: XOR<QuoteCreateWithoutRequestInput, QuoteUncheckedCreateWithoutRequestInput>
  }

  export type QuoteUpdateWithWhereUniqueWithoutRequestInput = {
    where: QuoteWhereUniqueInput
    data: XOR<QuoteUpdateWithoutRequestInput, QuoteUncheckedUpdateWithoutRequestInput>
  }

  export type QuoteUpdateManyWithWhereWithoutRequestInput = {
    where: QuoteScalarWhereInput
    data: XOR<QuoteUpdateManyMutationInput, QuoteUncheckedUpdateManyWithoutRequestInput>
  }

  export type QuoteScalarWhereInput = {
    AND?: QuoteScalarWhereInput | QuoteScalarWhereInput[]
    OR?: QuoteScalarWhereInput[]
    NOT?: QuoteScalarWhereInput | QuoteScalarWhereInput[]
    id?: StringFilter<"Quote"> | string
    requestId?: StringFilter<"Quote"> | string
    workshopId?: StringFilter<"Quote"> | string
    version?: IntFilter<"Quote"> | number
    diagnosis?: StringFilter<"Quote"> | string
    laborCost?: FloatFilter<"Quote"> | number
    totalParts?: FloatFilter<"Quote"> | number
    totalCost?: FloatFilter<"Quote"> | number
    estimatedTime?: StringFilter<"Quote"> | string
    validUntil?: DateTimeFilter<"Quote"> | Date | string
    notes?: StringNullableFilter<"Quote"> | string | null
    status?: EnumQuoteStatusFilter<"Quote"> | $Enums.QuoteStatus
    rejectionReason?: StringNullableFilter<"Quote"> | string | null
    createdAt?: DateTimeFilter<"Quote"> | Date | string
    updatedAt?: DateTimeFilter<"Quote"> | Date | string
  }

  export type RequestStatusHistoryUpsertWithWhereUniqueWithoutRequestInput = {
    where: RequestStatusHistoryWhereUniqueInput
    update: XOR<RequestStatusHistoryUpdateWithoutRequestInput, RequestStatusHistoryUncheckedUpdateWithoutRequestInput>
    create: XOR<RequestStatusHistoryCreateWithoutRequestInput, RequestStatusHistoryUncheckedCreateWithoutRequestInput>
  }

  export type RequestStatusHistoryUpdateWithWhereUniqueWithoutRequestInput = {
    where: RequestStatusHistoryWhereUniqueInput
    data: XOR<RequestStatusHistoryUpdateWithoutRequestInput, RequestStatusHistoryUncheckedUpdateWithoutRequestInput>
  }

  export type RequestStatusHistoryUpdateManyWithWhereWithoutRequestInput = {
    where: RequestStatusHistoryScalarWhereInput
    data: XOR<RequestStatusHistoryUpdateManyMutationInput, RequestStatusHistoryUncheckedUpdateManyWithoutRequestInput>
  }

  export type RequestStatusHistoryScalarWhereInput = {
    AND?: RequestStatusHistoryScalarWhereInput | RequestStatusHistoryScalarWhereInput[]
    OR?: RequestStatusHistoryScalarWhereInput[]
    NOT?: RequestStatusHistoryScalarWhereInput | RequestStatusHistoryScalarWhereInput[]
    id?: StringFilter<"RequestStatusHistory"> | string
    requestId?: StringFilter<"RequestStatusHistory"> | string
    fromStatus?: EnumServiceRequestStatusNullableFilter<"RequestStatusHistory"> | $Enums.ServiceRequestStatus | null
    toStatus?: EnumServiceRequestStatusFilter<"RequestStatusHistory"> | $Enums.ServiceRequestStatus
    actorId?: StringNullableFilter<"RequestStatusHistory"> | string | null
    reason?: StringNullableFilter<"RequestStatusHistory"> | string | null
    createdAt?: DateTimeFilter<"RequestStatusHistory"> | Date | string
  }

  export type NotificationUpsertWithWhereUniqueWithoutRequestInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutRequestInput, NotificationUncheckedUpdateWithoutRequestInput>
    create: XOR<NotificationCreateWithoutRequestInput, NotificationUncheckedCreateWithoutRequestInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutRequestInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutRequestInput, NotificationUncheckedUpdateWithoutRequestInput>
  }

  export type NotificationUpdateManyWithWhereWithoutRequestInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutRequestInput>
  }

  export type WorkOrderUpsertWithoutRequestInput = {
    update: XOR<WorkOrderUpdateWithoutRequestInput, WorkOrderUncheckedUpdateWithoutRequestInput>
    create: XOR<WorkOrderCreateWithoutRequestInput, WorkOrderUncheckedCreateWithoutRequestInput>
    where?: WorkOrderWhereInput
  }

  export type WorkOrderUpdateToOneWithWhereWithoutRequestInput = {
    where?: WorkOrderWhereInput
    data: XOR<WorkOrderUpdateWithoutRequestInput, WorkOrderUncheckedUpdateWithoutRequestInput>
  }

  export type WorkOrderUpdateWithoutRequestInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    diagnosis?: StringFieldUpdateOperationsInput | string
    totalAgreed?: FloatFieldUpdateOperationsInput | number
    totalFinal?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumWorkOrderStatusFieldUpdateOperationsInput | $Enums.WorkOrderStatus
    userAcceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    workshopAcceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startNote?: NullableStringFieldUpdateOperationsInput | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closureChecklist?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quote?: QuoteUpdateOneRequiredWithoutWorkOrderNestedInput
    workshop?: WorkshopUpdateOneRequiredWithoutWorkOrdersNestedInput
    changeRequests?: ChangeRequestUpdateManyWithoutWorkOrderNestedInput
    evidences?: EvidenceUpdateManyWithoutWorkOrderNestedInput
    review?: ReviewUpdateOneWithoutWorkOrderNestedInput
    receipt?: ReceiptUpdateOneWithoutWorkOrderNestedInput
  }

  export type WorkOrderUncheckedUpdateWithoutRequestInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    quoteId?: StringFieldUpdateOperationsInput | string
    workshopId?: StringFieldUpdateOperationsInput | string
    diagnosis?: StringFieldUpdateOperationsInput | string
    totalAgreed?: FloatFieldUpdateOperationsInput | number
    totalFinal?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumWorkOrderStatusFieldUpdateOperationsInput | $Enums.WorkOrderStatus
    userAcceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    workshopAcceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startNote?: NullableStringFieldUpdateOperationsInput | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closureChecklist?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    changeRequests?: ChangeRequestUncheckedUpdateManyWithoutWorkOrderNestedInput
    evidences?: EvidenceUncheckedUpdateManyWithoutWorkOrderNestedInput
    review?: ReviewUncheckedUpdateOneWithoutWorkOrderNestedInput
    receipt?: ReceiptUncheckedUpdateOneWithoutWorkOrderNestedInput
  }

  export type ChatMessageUpsertWithWhereUniqueWithoutRequestInput = {
    where: ChatMessageWhereUniqueInput
    update: XOR<ChatMessageUpdateWithoutRequestInput, ChatMessageUncheckedUpdateWithoutRequestInput>
    create: XOR<ChatMessageCreateWithoutRequestInput, ChatMessageUncheckedCreateWithoutRequestInput>
  }

  export type ChatMessageUpdateWithWhereUniqueWithoutRequestInput = {
    where: ChatMessageWhereUniqueInput
    data: XOR<ChatMessageUpdateWithoutRequestInput, ChatMessageUncheckedUpdateWithoutRequestInput>
  }

  export type ChatMessageUpdateManyWithWhereWithoutRequestInput = {
    where: ChatMessageScalarWhereInput
    data: XOR<ChatMessageUpdateManyMutationInput, ChatMessageUncheckedUpdateManyWithoutRequestInput>
  }

  export type AiSuggestionUpsertWithWhereUniqueWithoutRequestInput = {
    where: AiSuggestionWhereUniqueInput
    update: XOR<AiSuggestionUpdateWithoutRequestInput, AiSuggestionUncheckedUpdateWithoutRequestInput>
    create: XOR<AiSuggestionCreateWithoutRequestInput, AiSuggestionUncheckedCreateWithoutRequestInput>
  }

  export type AiSuggestionUpdateWithWhereUniqueWithoutRequestInput = {
    where: AiSuggestionWhereUniqueInput
    data: XOR<AiSuggestionUpdateWithoutRequestInput, AiSuggestionUncheckedUpdateWithoutRequestInput>
  }

  export type AiSuggestionUpdateManyWithWhereWithoutRequestInput = {
    where: AiSuggestionScalarWhereInput
    data: XOR<AiSuggestionUpdateManyMutationInput, AiSuggestionUncheckedUpdateManyWithoutRequestInput>
  }

  export type AiSuggestionScalarWhereInput = {
    AND?: AiSuggestionScalarWhereInput | AiSuggestionScalarWhereInput[]
    OR?: AiSuggestionScalarWhereInput[]
    NOT?: AiSuggestionScalarWhereInput | AiSuggestionScalarWhereInput[]
    id?: StringFilter<"AiSuggestion"> | string
    requestId?: StringFilter<"AiSuggestion"> | string
    type?: StringFilter<"AiSuggestion"> | string
    input?: StringNullableFilter<"AiSuggestion"> | string | null
    output?: StringNullableFilter<"AiSuggestion"> | string | null
    confidence?: FloatNullableFilter<"AiSuggestion"> | number | null
    modelVersion?: StringNullableFilter<"AiSuggestion"> | string | null
    isConclusive?: BoolFilter<"AiSuggestion"> | boolean
    disclaimer?: StringNullableFilter<"AiSuggestion"> | string | null
    createdAt?: DateTimeFilter<"AiSuggestion"> | Date | string
  }

  export type ServiceRequestCreateWithoutMediaInput = {
    id?: string
    description: string
    district: string
    urgency?: $Enums.UrgencyLevel
    status?: $Enums.ServiceRequestStatus
    completionScore?: number
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserProfileCreateNestedOneWithoutServiceRequestsInput
    motorcycle: MotorcycleCreateNestedOneWithoutServiceRequestsInput
    category: CategoryCreateNestedOneWithoutServiceRequestsInput
    guideAnswers?: GuideAnswerCreateNestedManyWithoutRequestInput
    quotes?: QuoteCreateNestedManyWithoutRequestInput
    statusHistory?: RequestStatusHistoryCreateNestedManyWithoutRequestInput
    notifications?: NotificationCreateNestedManyWithoutRequestInput
    workOrder?: WorkOrderCreateNestedOneWithoutRequestInput
    chatMessages?: ChatMessageCreateNestedManyWithoutRequestInput
    aiSuggestions?: AiSuggestionCreateNestedManyWithoutRequestInput
  }

  export type ServiceRequestUncheckedCreateWithoutMediaInput = {
    id?: string
    userId: string
    motorcycleId: string
    categoryId: string
    description: string
    district: string
    urgency?: $Enums.UrgencyLevel
    status?: $Enums.ServiceRequestStatus
    completionScore?: number
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    guideAnswers?: GuideAnswerUncheckedCreateNestedManyWithoutRequestInput
    quotes?: QuoteUncheckedCreateNestedManyWithoutRequestInput
    statusHistory?: RequestStatusHistoryUncheckedCreateNestedManyWithoutRequestInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutRequestInput
    workOrder?: WorkOrderUncheckedCreateNestedOneWithoutRequestInput
    chatMessages?: ChatMessageUncheckedCreateNestedManyWithoutRequestInput
    aiSuggestions?: AiSuggestionUncheckedCreateNestedManyWithoutRequestInput
  }

  export type ServiceRequestCreateOrConnectWithoutMediaInput = {
    where: ServiceRequestWhereUniqueInput
    create: XOR<ServiceRequestCreateWithoutMediaInput, ServiceRequestUncheckedCreateWithoutMediaInput>
  }

  export type ServiceRequestUpsertWithoutMediaInput = {
    update: XOR<ServiceRequestUpdateWithoutMediaInput, ServiceRequestUncheckedUpdateWithoutMediaInput>
    create: XOR<ServiceRequestCreateWithoutMediaInput, ServiceRequestUncheckedCreateWithoutMediaInput>
    where?: ServiceRequestWhereInput
  }

  export type ServiceRequestUpdateToOneWithWhereWithoutMediaInput = {
    where?: ServiceRequestWhereInput
    data: XOR<ServiceRequestUpdateWithoutMediaInput, ServiceRequestUncheckedUpdateWithoutMediaInput>
  }

  export type ServiceRequestUpdateWithoutMediaInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    district?: StringFieldUpdateOperationsInput | string
    urgency?: EnumUrgencyLevelFieldUpdateOperationsInput | $Enums.UrgencyLevel
    status?: EnumServiceRequestStatusFieldUpdateOperationsInput | $Enums.ServiceRequestStatus
    completionScore?: IntFieldUpdateOperationsInput | number
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserProfileUpdateOneRequiredWithoutServiceRequestsNestedInput
    motorcycle?: MotorcycleUpdateOneRequiredWithoutServiceRequestsNestedInput
    category?: CategoryUpdateOneRequiredWithoutServiceRequestsNestedInput
    guideAnswers?: GuideAnswerUpdateManyWithoutRequestNestedInput
    quotes?: QuoteUpdateManyWithoutRequestNestedInput
    statusHistory?: RequestStatusHistoryUpdateManyWithoutRequestNestedInput
    notifications?: NotificationUpdateManyWithoutRequestNestedInput
    workOrder?: WorkOrderUpdateOneWithoutRequestNestedInput
    chatMessages?: ChatMessageUpdateManyWithoutRequestNestedInput
    aiSuggestions?: AiSuggestionUpdateManyWithoutRequestNestedInput
  }

  export type ServiceRequestUncheckedUpdateWithoutMediaInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    motorcycleId?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    district?: StringFieldUpdateOperationsInput | string
    urgency?: EnumUrgencyLevelFieldUpdateOperationsInput | $Enums.UrgencyLevel
    status?: EnumServiceRequestStatusFieldUpdateOperationsInput | $Enums.ServiceRequestStatus
    completionScore?: IntFieldUpdateOperationsInput | number
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    guideAnswers?: GuideAnswerUncheckedUpdateManyWithoutRequestNestedInput
    quotes?: QuoteUncheckedUpdateManyWithoutRequestNestedInput
    statusHistory?: RequestStatusHistoryUncheckedUpdateManyWithoutRequestNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutRequestNestedInput
    workOrder?: WorkOrderUncheckedUpdateOneWithoutRequestNestedInput
    chatMessages?: ChatMessageUncheckedUpdateManyWithoutRequestNestedInput
    aiSuggestions?: AiSuggestionUncheckedUpdateManyWithoutRequestNestedInput
  }

  export type ServiceRequestCreateWithoutStatusHistoryInput = {
    id?: string
    description: string
    district: string
    urgency?: $Enums.UrgencyLevel
    status?: $Enums.ServiceRequestStatus
    completionScore?: number
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserProfileCreateNestedOneWithoutServiceRequestsInput
    motorcycle: MotorcycleCreateNestedOneWithoutServiceRequestsInput
    category: CategoryCreateNestedOneWithoutServiceRequestsInput
    media?: RequestMediaCreateNestedManyWithoutRequestInput
    guideAnswers?: GuideAnswerCreateNestedManyWithoutRequestInput
    quotes?: QuoteCreateNestedManyWithoutRequestInput
    notifications?: NotificationCreateNestedManyWithoutRequestInput
    workOrder?: WorkOrderCreateNestedOneWithoutRequestInput
    chatMessages?: ChatMessageCreateNestedManyWithoutRequestInput
    aiSuggestions?: AiSuggestionCreateNestedManyWithoutRequestInput
  }

  export type ServiceRequestUncheckedCreateWithoutStatusHistoryInput = {
    id?: string
    userId: string
    motorcycleId: string
    categoryId: string
    description: string
    district: string
    urgency?: $Enums.UrgencyLevel
    status?: $Enums.ServiceRequestStatus
    completionScore?: number
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    media?: RequestMediaUncheckedCreateNestedManyWithoutRequestInput
    guideAnswers?: GuideAnswerUncheckedCreateNestedManyWithoutRequestInput
    quotes?: QuoteUncheckedCreateNestedManyWithoutRequestInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutRequestInput
    workOrder?: WorkOrderUncheckedCreateNestedOneWithoutRequestInput
    chatMessages?: ChatMessageUncheckedCreateNestedManyWithoutRequestInput
    aiSuggestions?: AiSuggestionUncheckedCreateNestedManyWithoutRequestInput
  }

  export type ServiceRequestCreateOrConnectWithoutStatusHistoryInput = {
    where: ServiceRequestWhereUniqueInput
    create: XOR<ServiceRequestCreateWithoutStatusHistoryInput, ServiceRequestUncheckedCreateWithoutStatusHistoryInput>
  }

  export type ServiceRequestUpsertWithoutStatusHistoryInput = {
    update: XOR<ServiceRequestUpdateWithoutStatusHistoryInput, ServiceRequestUncheckedUpdateWithoutStatusHistoryInput>
    create: XOR<ServiceRequestCreateWithoutStatusHistoryInput, ServiceRequestUncheckedCreateWithoutStatusHistoryInput>
    where?: ServiceRequestWhereInput
  }

  export type ServiceRequestUpdateToOneWithWhereWithoutStatusHistoryInput = {
    where?: ServiceRequestWhereInput
    data: XOR<ServiceRequestUpdateWithoutStatusHistoryInput, ServiceRequestUncheckedUpdateWithoutStatusHistoryInput>
  }

  export type ServiceRequestUpdateWithoutStatusHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    district?: StringFieldUpdateOperationsInput | string
    urgency?: EnumUrgencyLevelFieldUpdateOperationsInput | $Enums.UrgencyLevel
    status?: EnumServiceRequestStatusFieldUpdateOperationsInput | $Enums.ServiceRequestStatus
    completionScore?: IntFieldUpdateOperationsInput | number
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserProfileUpdateOneRequiredWithoutServiceRequestsNestedInput
    motorcycle?: MotorcycleUpdateOneRequiredWithoutServiceRequestsNestedInput
    category?: CategoryUpdateOneRequiredWithoutServiceRequestsNestedInput
    media?: RequestMediaUpdateManyWithoutRequestNestedInput
    guideAnswers?: GuideAnswerUpdateManyWithoutRequestNestedInput
    quotes?: QuoteUpdateManyWithoutRequestNestedInput
    notifications?: NotificationUpdateManyWithoutRequestNestedInput
    workOrder?: WorkOrderUpdateOneWithoutRequestNestedInput
    chatMessages?: ChatMessageUpdateManyWithoutRequestNestedInput
    aiSuggestions?: AiSuggestionUpdateManyWithoutRequestNestedInput
  }

  export type ServiceRequestUncheckedUpdateWithoutStatusHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    motorcycleId?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    district?: StringFieldUpdateOperationsInput | string
    urgency?: EnumUrgencyLevelFieldUpdateOperationsInput | $Enums.UrgencyLevel
    status?: EnumServiceRequestStatusFieldUpdateOperationsInput | $Enums.ServiceRequestStatus
    completionScore?: IntFieldUpdateOperationsInput | number
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    media?: RequestMediaUncheckedUpdateManyWithoutRequestNestedInput
    guideAnswers?: GuideAnswerUncheckedUpdateManyWithoutRequestNestedInput
    quotes?: QuoteUncheckedUpdateManyWithoutRequestNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutRequestNestedInput
    workOrder?: WorkOrderUncheckedUpdateOneWithoutRequestNestedInput
    chatMessages?: ChatMessageUncheckedUpdateManyWithoutRequestNestedInput
    aiSuggestions?: AiSuggestionUncheckedUpdateManyWithoutRequestNestedInput
  }

  export type UserProfileCreateWithoutWorkshopInput = {
    id?: string
    clerkUserId: string
    role?: $Enums.UserRole
    email?: string | null
    phone?: string | null
    name?: string | null
    district?: string | null
    avatarUrl?: string | null
    notifChannel?: $Enums.NotificationChannel
    phoneVisible?: boolean
    termsAccepted?: boolean
    termsVersion?: string | null
    termsAcceptedAt?: Date | string | null
    privacyAccepted?: boolean
    privacyVersion?: string | null
    privacyAcceptedAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    motorcycles?: MotorcycleCreateNestedManyWithoutUserInput
    serviceRequests?: ServiceRequestCreateNestedManyWithoutUserInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
    incidentReports?: IncidentReportCreateNestedManyWithoutReporterInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    chatMessages?: ChatMessageCreateNestedManyWithoutSenderInput
  }

  export type UserProfileUncheckedCreateWithoutWorkshopInput = {
    id?: string
    clerkUserId: string
    role?: $Enums.UserRole
    email?: string | null
    phone?: string | null
    name?: string | null
    district?: string | null
    avatarUrl?: string | null
    notifChannel?: $Enums.NotificationChannel
    phoneVisible?: boolean
    termsAccepted?: boolean
    termsVersion?: string | null
    termsAcceptedAt?: Date | string | null
    privacyAccepted?: boolean
    privacyVersion?: string | null
    privacyAcceptedAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    motorcycles?: MotorcycleUncheckedCreateNestedManyWithoutUserInput
    serviceRequests?: ServiceRequestUncheckedCreateNestedManyWithoutUserInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
    incidentReports?: IncidentReportUncheckedCreateNestedManyWithoutReporterInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    chatMessages?: ChatMessageUncheckedCreateNestedManyWithoutSenderInput
  }

  export type UserProfileCreateOrConnectWithoutWorkshopInput = {
    where: UserProfileWhereUniqueInput
    create: XOR<UserProfileCreateWithoutWorkshopInput, UserProfileUncheckedCreateWithoutWorkshopInput>
  }

  export type WorkshopCategoryCreateWithoutWorkshopInput = {
    id?: string
    category: CategoryCreateNestedOneWithoutWorkshopCategoriesInput
  }

  export type WorkshopCategoryUncheckedCreateWithoutWorkshopInput = {
    id?: string
    categoryId: string
  }

  export type WorkshopCategoryCreateOrConnectWithoutWorkshopInput = {
    where: WorkshopCategoryWhereUniqueInput
    create: XOR<WorkshopCategoryCreateWithoutWorkshopInput, WorkshopCategoryUncheckedCreateWithoutWorkshopInput>
  }

  export type WorkshopCategoryCreateManyWorkshopInputEnvelope = {
    data: WorkshopCategoryCreateManyWorkshopInput | WorkshopCategoryCreateManyWorkshopInput[]
    skipDuplicates?: boolean
  }

  export type QuoteCreateWithoutWorkshopInput = {
    id?: string
    version?: number
    diagnosis: string
    laborCost: number
    totalParts?: number
    totalCost: number
    estimatedTime: string
    validUntil: Date | string
    notes?: string | null
    status?: $Enums.QuoteStatus
    rejectionReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    request: ServiceRequestCreateNestedOneWithoutQuotesInput
    parts?: QuotePartItemCreateNestedManyWithoutQuoteInput
    workOrder?: WorkOrderCreateNestedOneWithoutQuoteInput
    aiAnalysis?: AiQuoteAnalysisCreateNestedManyWithoutQuoteInput
  }

  export type QuoteUncheckedCreateWithoutWorkshopInput = {
    id?: string
    requestId: string
    version?: number
    diagnosis: string
    laborCost: number
    totalParts?: number
    totalCost: number
    estimatedTime: string
    validUntil: Date | string
    notes?: string | null
    status?: $Enums.QuoteStatus
    rejectionReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    parts?: QuotePartItemUncheckedCreateNestedManyWithoutQuoteInput
    workOrder?: WorkOrderUncheckedCreateNestedOneWithoutQuoteInput
    aiAnalysis?: AiQuoteAnalysisUncheckedCreateNestedManyWithoutQuoteInput
  }

  export type QuoteCreateOrConnectWithoutWorkshopInput = {
    where: QuoteWhereUniqueInput
    create: XOR<QuoteCreateWithoutWorkshopInput, QuoteUncheckedCreateWithoutWorkshopInput>
  }

  export type QuoteCreateManyWorkshopInputEnvelope = {
    data: QuoteCreateManyWorkshopInput | QuoteCreateManyWorkshopInput[]
    skipDuplicates?: boolean
  }

  export type WorkOrderCreateWithoutWorkshopInput = {
    id?: string
    orderNumber: string
    diagnosis: string
    totalAgreed: number
    totalFinal?: number | null
    status?: $Enums.WorkOrderStatus
    userAcceptedAt?: Date | string | null
    workshopAcceptedAt?: Date | string | null
    startedAt?: Date | string | null
    startNote?: string | null
    completedAt?: Date | string | null
    closedAt?: Date | string | null
    closureChecklist?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    request: ServiceRequestCreateNestedOneWithoutWorkOrderInput
    quote: QuoteCreateNestedOneWithoutWorkOrderInput
    changeRequests?: ChangeRequestCreateNestedManyWithoutWorkOrderInput
    evidences?: EvidenceCreateNestedManyWithoutWorkOrderInput
    review?: ReviewCreateNestedOneWithoutWorkOrderInput
    receipt?: ReceiptCreateNestedOneWithoutWorkOrderInput
  }

  export type WorkOrderUncheckedCreateWithoutWorkshopInput = {
    id?: string
    orderNumber: string
    requestId: string
    quoteId: string
    diagnosis: string
    totalAgreed: number
    totalFinal?: number | null
    status?: $Enums.WorkOrderStatus
    userAcceptedAt?: Date | string | null
    workshopAcceptedAt?: Date | string | null
    startedAt?: Date | string | null
    startNote?: string | null
    completedAt?: Date | string | null
    closedAt?: Date | string | null
    closureChecklist?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    changeRequests?: ChangeRequestUncheckedCreateNestedManyWithoutWorkOrderInput
    evidences?: EvidenceUncheckedCreateNestedManyWithoutWorkOrderInput
    review?: ReviewUncheckedCreateNestedOneWithoutWorkOrderInput
    receipt?: ReceiptUncheckedCreateNestedOneWithoutWorkOrderInput
  }

  export type WorkOrderCreateOrConnectWithoutWorkshopInput = {
    where: WorkOrderWhereUniqueInput
    create: XOR<WorkOrderCreateWithoutWorkshopInput, WorkOrderUncheckedCreateWithoutWorkshopInput>
  }

  export type WorkOrderCreateManyWorkshopInputEnvelope = {
    data: WorkOrderCreateManyWorkshopInput | WorkOrderCreateManyWorkshopInput[]
    skipDuplicates?: boolean
  }

  export type ReviewCreateWithoutWorkshopInput = {
    id?: string
    rating: number
    comment?: string | null
    editableUntil: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    workOrder: WorkOrderCreateNestedOneWithoutReviewInput
    user: UserProfileCreateNestedOneWithoutReviewsInput
  }

  export type ReviewUncheckedCreateWithoutWorkshopInput = {
    id?: string
    workOrderId: string
    userId: string
    rating: number
    comment?: string | null
    editableUntil: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReviewCreateOrConnectWithoutWorkshopInput = {
    where: ReviewWhereUniqueInput
    create: XOR<ReviewCreateWithoutWorkshopInput, ReviewUncheckedCreateWithoutWorkshopInput>
  }

  export type ReviewCreateManyWorkshopInputEnvelope = {
    data: ReviewCreateManyWorkshopInput | ReviewCreateManyWorkshopInput[]
    skipDuplicates?: boolean
  }

  export type IncidentReportCreateWithoutWorkshopInput = {
    id?: string
    type: $Enums.IncidentType
    description: string
    evidenceUrl?: string | null
    status?: $Enums.IncidentStatus
    resolution?: string | null
    resolvedAt?: Date | string | null
    resolvedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reporter: UserProfileCreateNestedOneWithoutIncidentReportsInput
  }

  export type IncidentReportUncheckedCreateWithoutWorkshopInput = {
    id?: string
    reporterId: string
    type: $Enums.IncidentType
    description: string
    evidenceUrl?: string | null
    status?: $Enums.IncidentStatus
    resolution?: string | null
    resolvedAt?: Date | string | null
    resolvedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IncidentReportCreateOrConnectWithoutWorkshopInput = {
    where: IncidentReportWhereUniqueInput
    create: XOR<IncidentReportCreateWithoutWorkshopInput, IncidentReportUncheckedCreateWithoutWorkshopInput>
  }

  export type IncidentReportCreateManyWorkshopInputEnvelope = {
    data: IncidentReportCreateManyWorkshopInput | IncidentReportCreateManyWorkshopInput[]
    skipDuplicates?: boolean
  }

  export type WorkshopVerificationCreateWithoutWorkshopInput = {
    id?: string
    adminId: string
    decision: $Enums.WorkshopStatus
    reason: string
    createdAt?: Date | string
  }

  export type WorkshopVerificationUncheckedCreateWithoutWorkshopInput = {
    id?: string
    adminId: string
    decision: $Enums.WorkshopStatus
    reason: string
    createdAt?: Date | string
  }

  export type WorkshopVerificationCreateOrConnectWithoutWorkshopInput = {
    where: WorkshopVerificationWhereUniqueInput
    create: XOR<WorkshopVerificationCreateWithoutWorkshopInput, WorkshopVerificationUncheckedCreateWithoutWorkshopInput>
  }

  export type WorkshopVerificationCreateManyWorkshopInputEnvelope = {
    data: WorkshopVerificationCreateManyWorkshopInput | WorkshopVerificationCreateManyWorkshopInput[]
    skipDuplicates?: boolean
  }

  export type UserProfileUpsertWithoutWorkshopInput = {
    update: XOR<UserProfileUpdateWithoutWorkshopInput, UserProfileUncheckedUpdateWithoutWorkshopInput>
    create: XOR<UserProfileCreateWithoutWorkshopInput, UserProfileUncheckedCreateWithoutWorkshopInput>
    where?: UserProfileWhereInput
  }

  export type UserProfileUpdateToOneWithWhereWithoutWorkshopInput = {
    where?: UserProfileWhereInput
    data: XOR<UserProfileUpdateWithoutWorkshopInput, UserProfileUncheckedUpdateWithoutWorkshopInput>
  }

  export type UserProfileUpdateWithoutWorkshopInput = {
    id?: StringFieldUpdateOperationsInput | string
    clerkUserId?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    notifChannel?: EnumNotificationChannelFieldUpdateOperationsInput | $Enums.NotificationChannel
    phoneVisible?: BoolFieldUpdateOperationsInput | boolean
    termsAccepted?: BoolFieldUpdateOperationsInput | boolean
    termsVersion?: NullableStringFieldUpdateOperationsInput | string | null
    termsAcceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    privacyAccepted?: BoolFieldUpdateOperationsInput | boolean
    privacyVersion?: NullableStringFieldUpdateOperationsInput | string | null
    privacyAcceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    motorcycles?: MotorcycleUpdateManyWithoutUserNestedInput
    serviceRequests?: ServiceRequestUpdateManyWithoutUserNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
    incidentReports?: IncidentReportUpdateManyWithoutReporterNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    chatMessages?: ChatMessageUpdateManyWithoutSenderNestedInput
  }

  export type UserProfileUncheckedUpdateWithoutWorkshopInput = {
    id?: StringFieldUpdateOperationsInput | string
    clerkUserId?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    notifChannel?: EnumNotificationChannelFieldUpdateOperationsInput | $Enums.NotificationChannel
    phoneVisible?: BoolFieldUpdateOperationsInput | boolean
    termsAccepted?: BoolFieldUpdateOperationsInput | boolean
    termsVersion?: NullableStringFieldUpdateOperationsInput | string | null
    termsAcceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    privacyAccepted?: BoolFieldUpdateOperationsInput | boolean
    privacyVersion?: NullableStringFieldUpdateOperationsInput | string | null
    privacyAcceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    motorcycles?: MotorcycleUncheckedUpdateManyWithoutUserNestedInput
    serviceRequests?: ServiceRequestUncheckedUpdateManyWithoutUserNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
    incidentReports?: IncidentReportUncheckedUpdateManyWithoutReporterNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    chatMessages?: ChatMessageUncheckedUpdateManyWithoutSenderNestedInput
  }

  export type WorkshopCategoryUpsertWithWhereUniqueWithoutWorkshopInput = {
    where: WorkshopCategoryWhereUniqueInput
    update: XOR<WorkshopCategoryUpdateWithoutWorkshopInput, WorkshopCategoryUncheckedUpdateWithoutWorkshopInput>
    create: XOR<WorkshopCategoryCreateWithoutWorkshopInput, WorkshopCategoryUncheckedCreateWithoutWorkshopInput>
  }

  export type WorkshopCategoryUpdateWithWhereUniqueWithoutWorkshopInput = {
    where: WorkshopCategoryWhereUniqueInput
    data: XOR<WorkshopCategoryUpdateWithoutWorkshopInput, WorkshopCategoryUncheckedUpdateWithoutWorkshopInput>
  }

  export type WorkshopCategoryUpdateManyWithWhereWithoutWorkshopInput = {
    where: WorkshopCategoryScalarWhereInput
    data: XOR<WorkshopCategoryUpdateManyMutationInput, WorkshopCategoryUncheckedUpdateManyWithoutWorkshopInput>
  }

  export type QuoteUpsertWithWhereUniqueWithoutWorkshopInput = {
    where: QuoteWhereUniqueInput
    update: XOR<QuoteUpdateWithoutWorkshopInput, QuoteUncheckedUpdateWithoutWorkshopInput>
    create: XOR<QuoteCreateWithoutWorkshopInput, QuoteUncheckedCreateWithoutWorkshopInput>
  }

  export type QuoteUpdateWithWhereUniqueWithoutWorkshopInput = {
    where: QuoteWhereUniqueInput
    data: XOR<QuoteUpdateWithoutWorkshopInput, QuoteUncheckedUpdateWithoutWorkshopInput>
  }

  export type QuoteUpdateManyWithWhereWithoutWorkshopInput = {
    where: QuoteScalarWhereInput
    data: XOR<QuoteUpdateManyMutationInput, QuoteUncheckedUpdateManyWithoutWorkshopInput>
  }

  export type WorkOrderUpsertWithWhereUniqueWithoutWorkshopInput = {
    where: WorkOrderWhereUniqueInput
    update: XOR<WorkOrderUpdateWithoutWorkshopInput, WorkOrderUncheckedUpdateWithoutWorkshopInput>
    create: XOR<WorkOrderCreateWithoutWorkshopInput, WorkOrderUncheckedCreateWithoutWorkshopInput>
  }

  export type WorkOrderUpdateWithWhereUniqueWithoutWorkshopInput = {
    where: WorkOrderWhereUniqueInput
    data: XOR<WorkOrderUpdateWithoutWorkshopInput, WorkOrderUncheckedUpdateWithoutWorkshopInput>
  }

  export type WorkOrderUpdateManyWithWhereWithoutWorkshopInput = {
    where: WorkOrderScalarWhereInput
    data: XOR<WorkOrderUpdateManyMutationInput, WorkOrderUncheckedUpdateManyWithoutWorkshopInput>
  }

  export type WorkOrderScalarWhereInput = {
    AND?: WorkOrderScalarWhereInput | WorkOrderScalarWhereInput[]
    OR?: WorkOrderScalarWhereInput[]
    NOT?: WorkOrderScalarWhereInput | WorkOrderScalarWhereInput[]
    id?: StringFilter<"WorkOrder"> | string
    orderNumber?: StringFilter<"WorkOrder"> | string
    requestId?: StringFilter<"WorkOrder"> | string
    quoteId?: StringFilter<"WorkOrder"> | string
    workshopId?: StringFilter<"WorkOrder"> | string
    diagnosis?: StringFilter<"WorkOrder"> | string
    totalAgreed?: FloatFilter<"WorkOrder"> | number
    totalFinal?: FloatNullableFilter<"WorkOrder"> | number | null
    status?: EnumWorkOrderStatusFilter<"WorkOrder"> | $Enums.WorkOrderStatus
    userAcceptedAt?: DateTimeNullableFilter<"WorkOrder"> | Date | string | null
    workshopAcceptedAt?: DateTimeNullableFilter<"WorkOrder"> | Date | string | null
    startedAt?: DateTimeNullableFilter<"WorkOrder"> | Date | string | null
    startNote?: StringNullableFilter<"WorkOrder"> | string | null
    completedAt?: DateTimeNullableFilter<"WorkOrder"> | Date | string | null
    closedAt?: DateTimeNullableFilter<"WorkOrder"> | Date | string | null
    closureChecklist?: StringNullableFilter<"WorkOrder"> | string | null
    createdAt?: DateTimeFilter<"WorkOrder"> | Date | string
    updatedAt?: DateTimeFilter<"WorkOrder"> | Date | string
  }

  export type ReviewUpsertWithWhereUniqueWithoutWorkshopInput = {
    where: ReviewWhereUniqueInput
    update: XOR<ReviewUpdateWithoutWorkshopInput, ReviewUncheckedUpdateWithoutWorkshopInput>
    create: XOR<ReviewCreateWithoutWorkshopInput, ReviewUncheckedCreateWithoutWorkshopInput>
  }

  export type ReviewUpdateWithWhereUniqueWithoutWorkshopInput = {
    where: ReviewWhereUniqueInput
    data: XOR<ReviewUpdateWithoutWorkshopInput, ReviewUncheckedUpdateWithoutWorkshopInput>
  }

  export type ReviewUpdateManyWithWhereWithoutWorkshopInput = {
    where: ReviewScalarWhereInput
    data: XOR<ReviewUpdateManyMutationInput, ReviewUncheckedUpdateManyWithoutWorkshopInput>
  }

  export type IncidentReportUpsertWithWhereUniqueWithoutWorkshopInput = {
    where: IncidentReportWhereUniqueInput
    update: XOR<IncidentReportUpdateWithoutWorkshopInput, IncidentReportUncheckedUpdateWithoutWorkshopInput>
    create: XOR<IncidentReportCreateWithoutWorkshopInput, IncidentReportUncheckedCreateWithoutWorkshopInput>
  }

  export type IncidentReportUpdateWithWhereUniqueWithoutWorkshopInput = {
    where: IncidentReportWhereUniqueInput
    data: XOR<IncidentReportUpdateWithoutWorkshopInput, IncidentReportUncheckedUpdateWithoutWorkshopInput>
  }

  export type IncidentReportUpdateManyWithWhereWithoutWorkshopInput = {
    where: IncidentReportScalarWhereInput
    data: XOR<IncidentReportUpdateManyMutationInput, IncidentReportUncheckedUpdateManyWithoutWorkshopInput>
  }

  export type WorkshopVerificationUpsertWithWhereUniqueWithoutWorkshopInput = {
    where: WorkshopVerificationWhereUniqueInput
    update: XOR<WorkshopVerificationUpdateWithoutWorkshopInput, WorkshopVerificationUncheckedUpdateWithoutWorkshopInput>
    create: XOR<WorkshopVerificationCreateWithoutWorkshopInput, WorkshopVerificationUncheckedCreateWithoutWorkshopInput>
  }

  export type WorkshopVerificationUpdateWithWhereUniqueWithoutWorkshopInput = {
    where: WorkshopVerificationWhereUniqueInput
    data: XOR<WorkshopVerificationUpdateWithoutWorkshopInput, WorkshopVerificationUncheckedUpdateWithoutWorkshopInput>
  }

  export type WorkshopVerificationUpdateManyWithWhereWithoutWorkshopInput = {
    where: WorkshopVerificationScalarWhereInput
    data: XOR<WorkshopVerificationUpdateManyMutationInput, WorkshopVerificationUncheckedUpdateManyWithoutWorkshopInput>
  }

  export type WorkshopVerificationScalarWhereInput = {
    AND?: WorkshopVerificationScalarWhereInput | WorkshopVerificationScalarWhereInput[]
    OR?: WorkshopVerificationScalarWhereInput[]
    NOT?: WorkshopVerificationScalarWhereInput | WorkshopVerificationScalarWhereInput[]
    id?: StringFilter<"WorkshopVerification"> | string
    workshopId?: StringFilter<"WorkshopVerification"> | string
    adminId?: StringFilter<"WorkshopVerification"> | string
    decision?: EnumWorkshopStatusFilter<"WorkshopVerification"> | $Enums.WorkshopStatus
    reason?: StringFilter<"WorkshopVerification"> | string
    createdAt?: DateTimeFilter<"WorkshopVerification"> | Date | string
  }

  export type WorkshopCreateWithoutCategoriesInput = {
    id?: string
    name: string
    address: string
    district: string
    phone: string
    ruc?: string | null
    description?: string | null
    photoUrl?: string | null
    status?: $Enums.WorkshopStatus
    transparencyAccepted?: boolean
    guaranteePolicy?: string | null
    latitude?: number | null
    longitude?: number | null
    rating?: number
    totalServices?: number
    evidenceRate?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserProfileCreateNestedOneWithoutWorkshopInput
    quotes?: QuoteCreateNestedManyWithoutWorkshopInput
    workOrders?: WorkOrderCreateNestedManyWithoutWorkshopInput
    reviews?: ReviewCreateNestedManyWithoutWorkshopInput
    incidentReports?: IncidentReportCreateNestedManyWithoutWorkshopInput
    verifications?: WorkshopVerificationCreateNestedManyWithoutWorkshopInput
  }

  export type WorkshopUncheckedCreateWithoutCategoriesInput = {
    id?: string
    userId: string
    name: string
    address: string
    district: string
    phone: string
    ruc?: string | null
    description?: string | null
    photoUrl?: string | null
    status?: $Enums.WorkshopStatus
    transparencyAccepted?: boolean
    guaranteePolicy?: string | null
    latitude?: number | null
    longitude?: number | null
    rating?: number
    totalServices?: number
    evidenceRate?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    quotes?: QuoteUncheckedCreateNestedManyWithoutWorkshopInput
    workOrders?: WorkOrderUncheckedCreateNestedManyWithoutWorkshopInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutWorkshopInput
    incidentReports?: IncidentReportUncheckedCreateNestedManyWithoutWorkshopInput
    verifications?: WorkshopVerificationUncheckedCreateNestedManyWithoutWorkshopInput
  }

  export type WorkshopCreateOrConnectWithoutCategoriesInput = {
    where: WorkshopWhereUniqueInput
    create: XOR<WorkshopCreateWithoutCategoriesInput, WorkshopUncheckedCreateWithoutCategoriesInput>
  }

  export type CategoryCreateWithoutWorkshopCategoriesInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    version?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    parent?: CategoryCreateNestedOneWithoutChildrenInput
    children?: CategoryCreateNestedManyWithoutParentInput
    guideQuestions?: GuideQuestionCreateNestedManyWithoutCategoryInput
    serviceRequests?: ServiceRequestCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUncheckedCreateWithoutWorkshopCategoriesInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    parentId?: string | null
    version?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    children?: CategoryUncheckedCreateNestedManyWithoutParentInput
    guideQuestions?: GuideQuestionUncheckedCreateNestedManyWithoutCategoryInput
    serviceRequests?: ServiceRequestUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type CategoryCreateOrConnectWithoutWorkshopCategoriesInput = {
    where: CategoryWhereUniqueInput
    create: XOR<CategoryCreateWithoutWorkshopCategoriesInput, CategoryUncheckedCreateWithoutWorkshopCategoriesInput>
  }

  export type WorkshopUpsertWithoutCategoriesInput = {
    update: XOR<WorkshopUpdateWithoutCategoriesInput, WorkshopUncheckedUpdateWithoutCategoriesInput>
    create: XOR<WorkshopCreateWithoutCategoriesInput, WorkshopUncheckedCreateWithoutCategoriesInput>
    where?: WorkshopWhereInput
  }

  export type WorkshopUpdateToOneWithWhereWithoutCategoriesInput = {
    where?: WorkshopWhereInput
    data: XOR<WorkshopUpdateWithoutCategoriesInput, WorkshopUncheckedUpdateWithoutCategoriesInput>
  }

  export type WorkshopUpdateWithoutCategoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    district?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    ruc?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumWorkshopStatusFieldUpdateOperationsInput | $Enums.WorkshopStatus
    transparencyAccepted?: BoolFieldUpdateOperationsInput | boolean
    guaranteePolicy?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    rating?: FloatFieldUpdateOperationsInput | number
    totalServices?: IntFieldUpdateOperationsInput | number
    evidenceRate?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserProfileUpdateOneRequiredWithoutWorkshopNestedInput
    quotes?: QuoteUpdateManyWithoutWorkshopNestedInput
    workOrders?: WorkOrderUpdateManyWithoutWorkshopNestedInput
    reviews?: ReviewUpdateManyWithoutWorkshopNestedInput
    incidentReports?: IncidentReportUpdateManyWithoutWorkshopNestedInput
    verifications?: WorkshopVerificationUpdateManyWithoutWorkshopNestedInput
  }

  export type WorkshopUncheckedUpdateWithoutCategoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    district?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    ruc?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumWorkshopStatusFieldUpdateOperationsInput | $Enums.WorkshopStatus
    transparencyAccepted?: BoolFieldUpdateOperationsInput | boolean
    guaranteePolicy?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    rating?: FloatFieldUpdateOperationsInput | number
    totalServices?: IntFieldUpdateOperationsInput | number
    evidenceRate?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quotes?: QuoteUncheckedUpdateManyWithoutWorkshopNestedInput
    workOrders?: WorkOrderUncheckedUpdateManyWithoutWorkshopNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutWorkshopNestedInput
    incidentReports?: IncidentReportUncheckedUpdateManyWithoutWorkshopNestedInput
    verifications?: WorkshopVerificationUncheckedUpdateManyWithoutWorkshopNestedInput
  }

  export type CategoryUpsertWithoutWorkshopCategoriesInput = {
    update: XOR<CategoryUpdateWithoutWorkshopCategoriesInput, CategoryUncheckedUpdateWithoutWorkshopCategoriesInput>
    create: XOR<CategoryCreateWithoutWorkshopCategoriesInput, CategoryUncheckedCreateWithoutWorkshopCategoriesInput>
    where?: CategoryWhereInput
  }

  export type CategoryUpdateToOneWithWhereWithoutWorkshopCategoriesInput = {
    where?: CategoryWhereInput
    data: XOR<CategoryUpdateWithoutWorkshopCategoriesInput, CategoryUncheckedUpdateWithoutWorkshopCategoriesInput>
  }

  export type CategoryUpdateWithoutWorkshopCategoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parent?: CategoryUpdateOneWithoutChildrenNestedInput
    children?: CategoryUpdateManyWithoutParentNestedInput
    guideQuestions?: GuideQuestionUpdateManyWithoutCategoryNestedInput
    serviceRequests?: ServiceRequestUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryUncheckedUpdateWithoutWorkshopCategoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: CategoryUncheckedUpdateManyWithoutParentNestedInput
    guideQuestions?: GuideQuestionUncheckedUpdateManyWithoutCategoryNestedInput
    serviceRequests?: ServiceRequestUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type WorkshopCreateWithoutVerificationsInput = {
    id?: string
    name: string
    address: string
    district: string
    phone: string
    ruc?: string | null
    description?: string | null
    photoUrl?: string | null
    status?: $Enums.WorkshopStatus
    transparencyAccepted?: boolean
    guaranteePolicy?: string | null
    latitude?: number | null
    longitude?: number | null
    rating?: number
    totalServices?: number
    evidenceRate?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserProfileCreateNestedOneWithoutWorkshopInput
    categories?: WorkshopCategoryCreateNestedManyWithoutWorkshopInput
    quotes?: QuoteCreateNestedManyWithoutWorkshopInput
    workOrders?: WorkOrderCreateNestedManyWithoutWorkshopInput
    reviews?: ReviewCreateNestedManyWithoutWorkshopInput
    incidentReports?: IncidentReportCreateNestedManyWithoutWorkshopInput
  }

  export type WorkshopUncheckedCreateWithoutVerificationsInput = {
    id?: string
    userId: string
    name: string
    address: string
    district: string
    phone: string
    ruc?: string | null
    description?: string | null
    photoUrl?: string | null
    status?: $Enums.WorkshopStatus
    transparencyAccepted?: boolean
    guaranteePolicy?: string | null
    latitude?: number | null
    longitude?: number | null
    rating?: number
    totalServices?: number
    evidenceRate?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    categories?: WorkshopCategoryUncheckedCreateNestedManyWithoutWorkshopInput
    quotes?: QuoteUncheckedCreateNestedManyWithoutWorkshopInput
    workOrders?: WorkOrderUncheckedCreateNestedManyWithoutWorkshopInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutWorkshopInput
    incidentReports?: IncidentReportUncheckedCreateNestedManyWithoutWorkshopInput
  }

  export type WorkshopCreateOrConnectWithoutVerificationsInput = {
    where: WorkshopWhereUniqueInput
    create: XOR<WorkshopCreateWithoutVerificationsInput, WorkshopUncheckedCreateWithoutVerificationsInput>
  }

  export type WorkshopUpsertWithoutVerificationsInput = {
    update: XOR<WorkshopUpdateWithoutVerificationsInput, WorkshopUncheckedUpdateWithoutVerificationsInput>
    create: XOR<WorkshopCreateWithoutVerificationsInput, WorkshopUncheckedCreateWithoutVerificationsInput>
    where?: WorkshopWhereInput
  }

  export type WorkshopUpdateToOneWithWhereWithoutVerificationsInput = {
    where?: WorkshopWhereInput
    data: XOR<WorkshopUpdateWithoutVerificationsInput, WorkshopUncheckedUpdateWithoutVerificationsInput>
  }

  export type WorkshopUpdateWithoutVerificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    district?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    ruc?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumWorkshopStatusFieldUpdateOperationsInput | $Enums.WorkshopStatus
    transparencyAccepted?: BoolFieldUpdateOperationsInput | boolean
    guaranteePolicy?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    rating?: FloatFieldUpdateOperationsInput | number
    totalServices?: IntFieldUpdateOperationsInput | number
    evidenceRate?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserProfileUpdateOneRequiredWithoutWorkshopNestedInput
    categories?: WorkshopCategoryUpdateManyWithoutWorkshopNestedInput
    quotes?: QuoteUpdateManyWithoutWorkshopNestedInput
    workOrders?: WorkOrderUpdateManyWithoutWorkshopNestedInput
    reviews?: ReviewUpdateManyWithoutWorkshopNestedInput
    incidentReports?: IncidentReportUpdateManyWithoutWorkshopNestedInput
  }

  export type WorkshopUncheckedUpdateWithoutVerificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    district?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    ruc?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumWorkshopStatusFieldUpdateOperationsInput | $Enums.WorkshopStatus
    transparencyAccepted?: BoolFieldUpdateOperationsInput | boolean
    guaranteePolicy?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    rating?: FloatFieldUpdateOperationsInput | number
    totalServices?: IntFieldUpdateOperationsInput | number
    evidenceRate?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    categories?: WorkshopCategoryUncheckedUpdateManyWithoutWorkshopNestedInput
    quotes?: QuoteUncheckedUpdateManyWithoutWorkshopNestedInput
    workOrders?: WorkOrderUncheckedUpdateManyWithoutWorkshopNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutWorkshopNestedInput
    incidentReports?: IncidentReportUncheckedUpdateManyWithoutWorkshopNestedInput
  }

  export type ServiceRequestCreateWithoutQuotesInput = {
    id?: string
    description: string
    district: string
    urgency?: $Enums.UrgencyLevel
    status?: $Enums.ServiceRequestStatus
    completionScore?: number
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserProfileCreateNestedOneWithoutServiceRequestsInput
    motorcycle: MotorcycleCreateNestedOneWithoutServiceRequestsInput
    category: CategoryCreateNestedOneWithoutServiceRequestsInput
    media?: RequestMediaCreateNestedManyWithoutRequestInput
    guideAnswers?: GuideAnswerCreateNestedManyWithoutRequestInput
    statusHistory?: RequestStatusHistoryCreateNestedManyWithoutRequestInput
    notifications?: NotificationCreateNestedManyWithoutRequestInput
    workOrder?: WorkOrderCreateNestedOneWithoutRequestInput
    chatMessages?: ChatMessageCreateNestedManyWithoutRequestInput
    aiSuggestions?: AiSuggestionCreateNestedManyWithoutRequestInput
  }

  export type ServiceRequestUncheckedCreateWithoutQuotesInput = {
    id?: string
    userId: string
    motorcycleId: string
    categoryId: string
    description: string
    district: string
    urgency?: $Enums.UrgencyLevel
    status?: $Enums.ServiceRequestStatus
    completionScore?: number
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    media?: RequestMediaUncheckedCreateNestedManyWithoutRequestInput
    guideAnswers?: GuideAnswerUncheckedCreateNestedManyWithoutRequestInput
    statusHistory?: RequestStatusHistoryUncheckedCreateNestedManyWithoutRequestInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutRequestInput
    workOrder?: WorkOrderUncheckedCreateNestedOneWithoutRequestInput
    chatMessages?: ChatMessageUncheckedCreateNestedManyWithoutRequestInput
    aiSuggestions?: AiSuggestionUncheckedCreateNestedManyWithoutRequestInput
  }

  export type ServiceRequestCreateOrConnectWithoutQuotesInput = {
    where: ServiceRequestWhereUniqueInput
    create: XOR<ServiceRequestCreateWithoutQuotesInput, ServiceRequestUncheckedCreateWithoutQuotesInput>
  }

  export type WorkshopCreateWithoutQuotesInput = {
    id?: string
    name: string
    address: string
    district: string
    phone: string
    ruc?: string | null
    description?: string | null
    photoUrl?: string | null
    status?: $Enums.WorkshopStatus
    transparencyAccepted?: boolean
    guaranteePolicy?: string | null
    latitude?: number | null
    longitude?: number | null
    rating?: number
    totalServices?: number
    evidenceRate?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserProfileCreateNestedOneWithoutWorkshopInput
    categories?: WorkshopCategoryCreateNestedManyWithoutWorkshopInput
    workOrders?: WorkOrderCreateNestedManyWithoutWorkshopInput
    reviews?: ReviewCreateNestedManyWithoutWorkshopInput
    incidentReports?: IncidentReportCreateNestedManyWithoutWorkshopInput
    verifications?: WorkshopVerificationCreateNestedManyWithoutWorkshopInput
  }

  export type WorkshopUncheckedCreateWithoutQuotesInput = {
    id?: string
    userId: string
    name: string
    address: string
    district: string
    phone: string
    ruc?: string | null
    description?: string | null
    photoUrl?: string | null
    status?: $Enums.WorkshopStatus
    transparencyAccepted?: boolean
    guaranteePolicy?: string | null
    latitude?: number | null
    longitude?: number | null
    rating?: number
    totalServices?: number
    evidenceRate?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    categories?: WorkshopCategoryUncheckedCreateNestedManyWithoutWorkshopInput
    workOrders?: WorkOrderUncheckedCreateNestedManyWithoutWorkshopInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutWorkshopInput
    incidentReports?: IncidentReportUncheckedCreateNestedManyWithoutWorkshopInput
    verifications?: WorkshopVerificationUncheckedCreateNestedManyWithoutWorkshopInput
  }

  export type WorkshopCreateOrConnectWithoutQuotesInput = {
    where: WorkshopWhereUniqueInput
    create: XOR<WorkshopCreateWithoutQuotesInput, WorkshopUncheckedCreateWithoutQuotesInput>
  }

  export type QuotePartItemCreateWithoutQuoteInput = {
    id?: string
    name: string
    quantity?: number
    unitPrice: number
    partType?: $Enums.PartType
    notes?: string | null
    alternativeName?: string | null
    alternativePrice?: number | null
    alternativeType?: $Enums.PartType | null
    alternativeNotes?: string | null
    selectedAlternative?: boolean
    createdAt?: Date | string
  }

  export type QuotePartItemUncheckedCreateWithoutQuoteInput = {
    id?: string
    name: string
    quantity?: number
    unitPrice: number
    partType?: $Enums.PartType
    notes?: string | null
    alternativeName?: string | null
    alternativePrice?: number | null
    alternativeType?: $Enums.PartType | null
    alternativeNotes?: string | null
    selectedAlternative?: boolean
    createdAt?: Date | string
  }

  export type QuotePartItemCreateOrConnectWithoutQuoteInput = {
    where: QuotePartItemWhereUniqueInput
    create: XOR<QuotePartItemCreateWithoutQuoteInput, QuotePartItemUncheckedCreateWithoutQuoteInput>
  }

  export type QuotePartItemCreateManyQuoteInputEnvelope = {
    data: QuotePartItemCreateManyQuoteInput | QuotePartItemCreateManyQuoteInput[]
    skipDuplicates?: boolean
  }

  export type WorkOrderCreateWithoutQuoteInput = {
    id?: string
    orderNumber: string
    diagnosis: string
    totalAgreed: number
    totalFinal?: number | null
    status?: $Enums.WorkOrderStatus
    userAcceptedAt?: Date | string | null
    workshopAcceptedAt?: Date | string | null
    startedAt?: Date | string | null
    startNote?: string | null
    completedAt?: Date | string | null
    closedAt?: Date | string | null
    closureChecklist?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    request: ServiceRequestCreateNestedOneWithoutWorkOrderInput
    workshop: WorkshopCreateNestedOneWithoutWorkOrdersInput
    changeRequests?: ChangeRequestCreateNestedManyWithoutWorkOrderInput
    evidences?: EvidenceCreateNestedManyWithoutWorkOrderInput
    review?: ReviewCreateNestedOneWithoutWorkOrderInput
    receipt?: ReceiptCreateNestedOneWithoutWorkOrderInput
  }

  export type WorkOrderUncheckedCreateWithoutQuoteInput = {
    id?: string
    orderNumber: string
    requestId: string
    workshopId: string
    diagnosis: string
    totalAgreed: number
    totalFinal?: number | null
    status?: $Enums.WorkOrderStatus
    userAcceptedAt?: Date | string | null
    workshopAcceptedAt?: Date | string | null
    startedAt?: Date | string | null
    startNote?: string | null
    completedAt?: Date | string | null
    closedAt?: Date | string | null
    closureChecklist?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    changeRequests?: ChangeRequestUncheckedCreateNestedManyWithoutWorkOrderInput
    evidences?: EvidenceUncheckedCreateNestedManyWithoutWorkOrderInput
    review?: ReviewUncheckedCreateNestedOneWithoutWorkOrderInput
    receipt?: ReceiptUncheckedCreateNestedOneWithoutWorkOrderInput
  }

  export type WorkOrderCreateOrConnectWithoutQuoteInput = {
    where: WorkOrderWhereUniqueInput
    create: XOR<WorkOrderCreateWithoutQuoteInput, WorkOrderUncheckedCreateWithoutQuoteInput>
  }

  export type AiQuoteAnalysisCreateWithoutQuoteInput = {
    id?: string
    type: string
    input?: string | null
    output?: string | null
    traceability?: string | null
    modelVersion?: string | null
    createdAt?: Date | string
  }

  export type AiQuoteAnalysisUncheckedCreateWithoutQuoteInput = {
    id?: string
    type: string
    input?: string | null
    output?: string | null
    traceability?: string | null
    modelVersion?: string | null
    createdAt?: Date | string
  }

  export type AiQuoteAnalysisCreateOrConnectWithoutQuoteInput = {
    where: AiQuoteAnalysisWhereUniqueInput
    create: XOR<AiQuoteAnalysisCreateWithoutQuoteInput, AiQuoteAnalysisUncheckedCreateWithoutQuoteInput>
  }

  export type AiQuoteAnalysisCreateManyQuoteInputEnvelope = {
    data: AiQuoteAnalysisCreateManyQuoteInput | AiQuoteAnalysisCreateManyQuoteInput[]
    skipDuplicates?: boolean
  }

  export type ServiceRequestUpsertWithoutQuotesInput = {
    update: XOR<ServiceRequestUpdateWithoutQuotesInput, ServiceRequestUncheckedUpdateWithoutQuotesInput>
    create: XOR<ServiceRequestCreateWithoutQuotesInput, ServiceRequestUncheckedCreateWithoutQuotesInput>
    where?: ServiceRequestWhereInput
  }

  export type ServiceRequestUpdateToOneWithWhereWithoutQuotesInput = {
    where?: ServiceRequestWhereInput
    data: XOR<ServiceRequestUpdateWithoutQuotesInput, ServiceRequestUncheckedUpdateWithoutQuotesInput>
  }

  export type ServiceRequestUpdateWithoutQuotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    district?: StringFieldUpdateOperationsInput | string
    urgency?: EnumUrgencyLevelFieldUpdateOperationsInput | $Enums.UrgencyLevel
    status?: EnumServiceRequestStatusFieldUpdateOperationsInput | $Enums.ServiceRequestStatus
    completionScore?: IntFieldUpdateOperationsInput | number
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserProfileUpdateOneRequiredWithoutServiceRequestsNestedInput
    motorcycle?: MotorcycleUpdateOneRequiredWithoutServiceRequestsNestedInput
    category?: CategoryUpdateOneRequiredWithoutServiceRequestsNestedInput
    media?: RequestMediaUpdateManyWithoutRequestNestedInput
    guideAnswers?: GuideAnswerUpdateManyWithoutRequestNestedInput
    statusHistory?: RequestStatusHistoryUpdateManyWithoutRequestNestedInput
    notifications?: NotificationUpdateManyWithoutRequestNestedInput
    workOrder?: WorkOrderUpdateOneWithoutRequestNestedInput
    chatMessages?: ChatMessageUpdateManyWithoutRequestNestedInput
    aiSuggestions?: AiSuggestionUpdateManyWithoutRequestNestedInput
  }

  export type ServiceRequestUncheckedUpdateWithoutQuotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    motorcycleId?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    district?: StringFieldUpdateOperationsInput | string
    urgency?: EnumUrgencyLevelFieldUpdateOperationsInput | $Enums.UrgencyLevel
    status?: EnumServiceRequestStatusFieldUpdateOperationsInput | $Enums.ServiceRequestStatus
    completionScore?: IntFieldUpdateOperationsInput | number
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    media?: RequestMediaUncheckedUpdateManyWithoutRequestNestedInput
    guideAnswers?: GuideAnswerUncheckedUpdateManyWithoutRequestNestedInput
    statusHistory?: RequestStatusHistoryUncheckedUpdateManyWithoutRequestNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutRequestNestedInput
    workOrder?: WorkOrderUncheckedUpdateOneWithoutRequestNestedInput
    chatMessages?: ChatMessageUncheckedUpdateManyWithoutRequestNestedInput
    aiSuggestions?: AiSuggestionUncheckedUpdateManyWithoutRequestNestedInput
  }

  export type WorkshopUpsertWithoutQuotesInput = {
    update: XOR<WorkshopUpdateWithoutQuotesInput, WorkshopUncheckedUpdateWithoutQuotesInput>
    create: XOR<WorkshopCreateWithoutQuotesInput, WorkshopUncheckedCreateWithoutQuotesInput>
    where?: WorkshopWhereInput
  }

  export type WorkshopUpdateToOneWithWhereWithoutQuotesInput = {
    where?: WorkshopWhereInput
    data: XOR<WorkshopUpdateWithoutQuotesInput, WorkshopUncheckedUpdateWithoutQuotesInput>
  }

  export type WorkshopUpdateWithoutQuotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    district?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    ruc?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumWorkshopStatusFieldUpdateOperationsInput | $Enums.WorkshopStatus
    transparencyAccepted?: BoolFieldUpdateOperationsInput | boolean
    guaranteePolicy?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    rating?: FloatFieldUpdateOperationsInput | number
    totalServices?: IntFieldUpdateOperationsInput | number
    evidenceRate?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserProfileUpdateOneRequiredWithoutWorkshopNestedInput
    categories?: WorkshopCategoryUpdateManyWithoutWorkshopNestedInput
    workOrders?: WorkOrderUpdateManyWithoutWorkshopNestedInput
    reviews?: ReviewUpdateManyWithoutWorkshopNestedInput
    incidentReports?: IncidentReportUpdateManyWithoutWorkshopNestedInput
    verifications?: WorkshopVerificationUpdateManyWithoutWorkshopNestedInput
  }

  export type WorkshopUncheckedUpdateWithoutQuotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    district?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    ruc?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumWorkshopStatusFieldUpdateOperationsInput | $Enums.WorkshopStatus
    transparencyAccepted?: BoolFieldUpdateOperationsInput | boolean
    guaranteePolicy?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    rating?: FloatFieldUpdateOperationsInput | number
    totalServices?: IntFieldUpdateOperationsInput | number
    evidenceRate?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    categories?: WorkshopCategoryUncheckedUpdateManyWithoutWorkshopNestedInput
    workOrders?: WorkOrderUncheckedUpdateManyWithoutWorkshopNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutWorkshopNestedInput
    incidentReports?: IncidentReportUncheckedUpdateManyWithoutWorkshopNestedInput
    verifications?: WorkshopVerificationUncheckedUpdateManyWithoutWorkshopNestedInput
  }

  export type QuotePartItemUpsertWithWhereUniqueWithoutQuoteInput = {
    where: QuotePartItemWhereUniqueInput
    update: XOR<QuotePartItemUpdateWithoutQuoteInput, QuotePartItemUncheckedUpdateWithoutQuoteInput>
    create: XOR<QuotePartItemCreateWithoutQuoteInput, QuotePartItemUncheckedCreateWithoutQuoteInput>
  }

  export type QuotePartItemUpdateWithWhereUniqueWithoutQuoteInput = {
    where: QuotePartItemWhereUniqueInput
    data: XOR<QuotePartItemUpdateWithoutQuoteInput, QuotePartItemUncheckedUpdateWithoutQuoteInput>
  }

  export type QuotePartItemUpdateManyWithWhereWithoutQuoteInput = {
    where: QuotePartItemScalarWhereInput
    data: XOR<QuotePartItemUpdateManyMutationInput, QuotePartItemUncheckedUpdateManyWithoutQuoteInput>
  }

  export type QuotePartItemScalarWhereInput = {
    AND?: QuotePartItemScalarWhereInput | QuotePartItemScalarWhereInput[]
    OR?: QuotePartItemScalarWhereInput[]
    NOT?: QuotePartItemScalarWhereInput | QuotePartItemScalarWhereInput[]
    id?: StringFilter<"QuotePartItem"> | string
    quoteId?: StringFilter<"QuotePartItem"> | string
    name?: StringFilter<"QuotePartItem"> | string
    quantity?: IntFilter<"QuotePartItem"> | number
    unitPrice?: FloatFilter<"QuotePartItem"> | number
    partType?: EnumPartTypeFilter<"QuotePartItem"> | $Enums.PartType
    notes?: StringNullableFilter<"QuotePartItem"> | string | null
    alternativeName?: StringNullableFilter<"QuotePartItem"> | string | null
    alternativePrice?: FloatNullableFilter<"QuotePartItem"> | number | null
    alternativeType?: EnumPartTypeNullableFilter<"QuotePartItem"> | $Enums.PartType | null
    alternativeNotes?: StringNullableFilter<"QuotePartItem"> | string | null
    selectedAlternative?: BoolFilter<"QuotePartItem"> | boolean
    createdAt?: DateTimeFilter<"QuotePartItem"> | Date | string
  }

  export type WorkOrderUpsertWithoutQuoteInput = {
    update: XOR<WorkOrderUpdateWithoutQuoteInput, WorkOrderUncheckedUpdateWithoutQuoteInput>
    create: XOR<WorkOrderCreateWithoutQuoteInput, WorkOrderUncheckedCreateWithoutQuoteInput>
    where?: WorkOrderWhereInput
  }

  export type WorkOrderUpdateToOneWithWhereWithoutQuoteInput = {
    where?: WorkOrderWhereInput
    data: XOR<WorkOrderUpdateWithoutQuoteInput, WorkOrderUncheckedUpdateWithoutQuoteInput>
  }

  export type WorkOrderUpdateWithoutQuoteInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    diagnosis?: StringFieldUpdateOperationsInput | string
    totalAgreed?: FloatFieldUpdateOperationsInput | number
    totalFinal?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumWorkOrderStatusFieldUpdateOperationsInput | $Enums.WorkOrderStatus
    userAcceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    workshopAcceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startNote?: NullableStringFieldUpdateOperationsInput | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closureChecklist?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    request?: ServiceRequestUpdateOneRequiredWithoutWorkOrderNestedInput
    workshop?: WorkshopUpdateOneRequiredWithoutWorkOrdersNestedInput
    changeRequests?: ChangeRequestUpdateManyWithoutWorkOrderNestedInput
    evidences?: EvidenceUpdateManyWithoutWorkOrderNestedInput
    review?: ReviewUpdateOneWithoutWorkOrderNestedInput
    receipt?: ReceiptUpdateOneWithoutWorkOrderNestedInput
  }

  export type WorkOrderUncheckedUpdateWithoutQuoteInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    requestId?: StringFieldUpdateOperationsInput | string
    workshopId?: StringFieldUpdateOperationsInput | string
    diagnosis?: StringFieldUpdateOperationsInput | string
    totalAgreed?: FloatFieldUpdateOperationsInput | number
    totalFinal?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumWorkOrderStatusFieldUpdateOperationsInput | $Enums.WorkOrderStatus
    userAcceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    workshopAcceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startNote?: NullableStringFieldUpdateOperationsInput | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closureChecklist?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    changeRequests?: ChangeRequestUncheckedUpdateManyWithoutWorkOrderNestedInput
    evidences?: EvidenceUncheckedUpdateManyWithoutWorkOrderNestedInput
    review?: ReviewUncheckedUpdateOneWithoutWorkOrderNestedInput
    receipt?: ReceiptUncheckedUpdateOneWithoutWorkOrderNestedInput
  }

  export type AiQuoteAnalysisUpsertWithWhereUniqueWithoutQuoteInput = {
    where: AiQuoteAnalysisWhereUniqueInput
    update: XOR<AiQuoteAnalysisUpdateWithoutQuoteInput, AiQuoteAnalysisUncheckedUpdateWithoutQuoteInput>
    create: XOR<AiQuoteAnalysisCreateWithoutQuoteInput, AiQuoteAnalysisUncheckedCreateWithoutQuoteInput>
  }

  export type AiQuoteAnalysisUpdateWithWhereUniqueWithoutQuoteInput = {
    where: AiQuoteAnalysisWhereUniqueInput
    data: XOR<AiQuoteAnalysisUpdateWithoutQuoteInput, AiQuoteAnalysisUncheckedUpdateWithoutQuoteInput>
  }

  export type AiQuoteAnalysisUpdateManyWithWhereWithoutQuoteInput = {
    where: AiQuoteAnalysisScalarWhereInput
    data: XOR<AiQuoteAnalysisUpdateManyMutationInput, AiQuoteAnalysisUncheckedUpdateManyWithoutQuoteInput>
  }

  export type AiQuoteAnalysisScalarWhereInput = {
    AND?: AiQuoteAnalysisScalarWhereInput | AiQuoteAnalysisScalarWhereInput[]
    OR?: AiQuoteAnalysisScalarWhereInput[]
    NOT?: AiQuoteAnalysisScalarWhereInput | AiQuoteAnalysisScalarWhereInput[]
    id?: StringFilter<"AiQuoteAnalysis"> | string
    quoteId?: StringFilter<"AiQuoteAnalysis"> | string
    type?: StringFilter<"AiQuoteAnalysis"> | string
    input?: StringNullableFilter<"AiQuoteAnalysis"> | string | null
    output?: StringNullableFilter<"AiQuoteAnalysis"> | string | null
    traceability?: StringNullableFilter<"AiQuoteAnalysis"> | string | null
    modelVersion?: StringNullableFilter<"AiQuoteAnalysis"> | string | null
    createdAt?: DateTimeFilter<"AiQuoteAnalysis"> | Date | string
  }

  export type QuoteCreateWithoutPartsInput = {
    id?: string
    version?: number
    diagnosis: string
    laborCost: number
    totalParts?: number
    totalCost: number
    estimatedTime: string
    validUntil: Date | string
    notes?: string | null
    status?: $Enums.QuoteStatus
    rejectionReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    request: ServiceRequestCreateNestedOneWithoutQuotesInput
    workshop: WorkshopCreateNestedOneWithoutQuotesInput
    workOrder?: WorkOrderCreateNestedOneWithoutQuoteInput
    aiAnalysis?: AiQuoteAnalysisCreateNestedManyWithoutQuoteInput
  }

  export type QuoteUncheckedCreateWithoutPartsInput = {
    id?: string
    requestId: string
    workshopId: string
    version?: number
    diagnosis: string
    laborCost: number
    totalParts?: number
    totalCost: number
    estimatedTime: string
    validUntil: Date | string
    notes?: string | null
    status?: $Enums.QuoteStatus
    rejectionReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    workOrder?: WorkOrderUncheckedCreateNestedOneWithoutQuoteInput
    aiAnalysis?: AiQuoteAnalysisUncheckedCreateNestedManyWithoutQuoteInput
  }

  export type QuoteCreateOrConnectWithoutPartsInput = {
    where: QuoteWhereUniqueInput
    create: XOR<QuoteCreateWithoutPartsInput, QuoteUncheckedCreateWithoutPartsInput>
  }

  export type QuoteUpsertWithoutPartsInput = {
    update: XOR<QuoteUpdateWithoutPartsInput, QuoteUncheckedUpdateWithoutPartsInput>
    create: XOR<QuoteCreateWithoutPartsInput, QuoteUncheckedCreateWithoutPartsInput>
    where?: QuoteWhereInput
  }

  export type QuoteUpdateToOneWithWhereWithoutPartsInput = {
    where?: QuoteWhereInput
    data: XOR<QuoteUpdateWithoutPartsInput, QuoteUncheckedUpdateWithoutPartsInput>
  }

  export type QuoteUpdateWithoutPartsInput = {
    id?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    diagnosis?: StringFieldUpdateOperationsInput | string
    laborCost?: FloatFieldUpdateOperationsInput | number
    totalParts?: FloatFieldUpdateOperationsInput | number
    totalCost?: FloatFieldUpdateOperationsInput | number
    estimatedTime?: StringFieldUpdateOperationsInput | string
    validUntil?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumQuoteStatusFieldUpdateOperationsInput | $Enums.QuoteStatus
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    request?: ServiceRequestUpdateOneRequiredWithoutQuotesNestedInput
    workshop?: WorkshopUpdateOneRequiredWithoutQuotesNestedInput
    workOrder?: WorkOrderUpdateOneWithoutQuoteNestedInput
    aiAnalysis?: AiQuoteAnalysisUpdateManyWithoutQuoteNestedInput
  }

  export type QuoteUncheckedUpdateWithoutPartsInput = {
    id?: StringFieldUpdateOperationsInput | string
    requestId?: StringFieldUpdateOperationsInput | string
    workshopId?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    diagnosis?: StringFieldUpdateOperationsInput | string
    laborCost?: FloatFieldUpdateOperationsInput | number
    totalParts?: FloatFieldUpdateOperationsInput | number
    totalCost?: FloatFieldUpdateOperationsInput | number
    estimatedTime?: StringFieldUpdateOperationsInput | string
    validUntil?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumQuoteStatusFieldUpdateOperationsInput | $Enums.QuoteStatus
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workOrder?: WorkOrderUncheckedUpdateOneWithoutQuoteNestedInput
    aiAnalysis?: AiQuoteAnalysisUncheckedUpdateManyWithoutQuoteNestedInput
  }

  export type ServiceRequestCreateWithoutWorkOrderInput = {
    id?: string
    description: string
    district: string
    urgency?: $Enums.UrgencyLevel
    status?: $Enums.ServiceRequestStatus
    completionScore?: number
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserProfileCreateNestedOneWithoutServiceRequestsInput
    motorcycle: MotorcycleCreateNestedOneWithoutServiceRequestsInput
    category: CategoryCreateNestedOneWithoutServiceRequestsInput
    media?: RequestMediaCreateNestedManyWithoutRequestInput
    guideAnswers?: GuideAnswerCreateNestedManyWithoutRequestInput
    quotes?: QuoteCreateNestedManyWithoutRequestInput
    statusHistory?: RequestStatusHistoryCreateNestedManyWithoutRequestInput
    notifications?: NotificationCreateNestedManyWithoutRequestInput
    chatMessages?: ChatMessageCreateNestedManyWithoutRequestInput
    aiSuggestions?: AiSuggestionCreateNestedManyWithoutRequestInput
  }

  export type ServiceRequestUncheckedCreateWithoutWorkOrderInput = {
    id?: string
    userId: string
    motorcycleId: string
    categoryId: string
    description: string
    district: string
    urgency?: $Enums.UrgencyLevel
    status?: $Enums.ServiceRequestStatus
    completionScore?: number
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    media?: RequestMediaUncheckedCreateNestedManyWithoutRequestInput
    guideAnswers?: GuideAnswerUncheckedCreateNestedManyWithoutRequestInput
    quotes?: QuoteUncheckedCreateNestedManyWithoutRequestInput
    statusHistory?: RequestStatusHistoryUncheckedCreateNestedManyWithoutRequestInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutRequestInput
    chatMessages?: ChatMessageUncheckedCreateNestedManyWithoutRequestInput
    aiSuggestions?: AiSuggestionUncheckedCreateNestedManyWithoutRequestInput
  }

  export type ServiceRequestCreateOrConnectWithoutWorkOrderInput = {
    where: ServiceRequestWhereUniqueInput
    create: XOR<ServiceRequestCreateWithoutWorkOrderInput, ServiceRequestUncheckedCreateWithoutWorkOrderInput>
  }

  export type QuoteCreateWithoutWorkOrderInput = {
    id?: string
    version?: number
    diagnosis: string
    laborCost: number
    totalParts?: number
    totalCost: number
    estimatedTime: string
    validUntil: Date | string
    notes?: string | null
    status?: $Enums.QuoteStatus
    rejectionReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    request: ServiceRequestCreateNestedOneWithoutQuotesInput
    workshop: WorkshopCreateNestedOneWithoutQuotesInput
    parts?: QuotePartItemCreateNestedManyWithoutQuoteInput
    aiAnalysis?: AiQuoteAnalysisCreateNestedManyWithoutQuoteInput
  }

  export type QuoteUncheckedCreateWithoutWorkOrderInput = {
    id?: string
    requestId: string
    workshopId: string
    version?: number
    diagnosis: string
    laborCost: number
    totalParts?: number
    totalCost: number
    estimatedTime: string
    validUntil: Date | string
    notes?: string | null
    status?: $Enums.QuoteStatus
    rejectionReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    parts?: QuotePartItemUncheckedCreateNestedManyWithoutQuoteInput
    aiAnalysis?: AiQuoteAnalysisUncheckedCreateNestedManyWithoutQuoteInput
  }

  export type QuoteCreateOrConnectWithoutWorkOrderInput = {
    where: QuoteWhereUniqueInput
    create: XOR<QuoteCreateWithoutWorkOrderInput, QuoteUncheckedCreateWithoutWorkOrderInput>
  }

  export type WorkshopCreateWithoutWorkOrdersInput = {
    id?: string
    name: string
    address: string
    district: string
    phone: string
    ruc?: string | null
    description?: string | null
    photoUrl?: string | null
    status?: $Enums.WorkshopStatus
    transparencyAccepted?: boolean
    guaranteePolicy?: string | null
    latitude?: number | null
    longitude?: number | null
    rating?: number
    totalServices?: number
    evidenceRate?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserProfileCreateNestedOneWithoutWorkshopInput
    categories?: WorkshopCategoryCreateNestedManyWithoutWorkshopInput
    quotes?: QuoteCreateNestedManyWithoutWorkshopInput
    reviews?: ReviewCreateNestedManyWithoutWorkshopInput
    incidentReports?: IncidentReportCreateNestedManyWithoutWorkshopInput
    verifications?: WorkshopVerificationCreateNestedManyWithoutWorkshopInput
  }

  export type WorkshopUncheckedCreateWithoutWorkOrdersInput = {
    id?: string
    userId: string
    name: string
    address: string
    district: string
    phone: string
    ruc?: string | null
    description?: string | null
    photoUrl?: string | null
    status?: $Enums.WorkshopStatus
    transparencyAccepted?: boolean
    guaranteePolicy?: string | null
    latitude?: number | null
    longitude?: number | null
    rating?: number
    totalServices?: number
    evidenceRate?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    categories?: WorkshopCategoryUncheckedCreateNestedManyWithoutWorkshopInput
    quotes?: QuoteUncheckedCreateNestedManyWithoutWorkshopInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutWorkshopInput
    incidentReports?: IncidentReportUncheckedCreateNestedManyWithoutWorkshopInput
    verifications?: WorkshopVerificationUncheckedCreateNestedManyWithoutWorkshopInput
  }

  export type WorkshopCreateOrConnectWithoutWorkOrdersInput = {
    where: WorkshopWhereUniqueInput
    create: XOR<WorkshopCreateWithoutWorkOrdersInput, WorkshopUncheckedCreateWithoutWorkOrdersInput>
  }

  export type ChangeRequestCreateWithoutWorkOrderInput = {
    id?: string
    description: string
    justification: string
    additionalCost: number
    additionalTime?: string | null
    status?: $Enums.ChangeRequestStatus
    decidedAt?: Date | string | null
    decidedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ChangeRequestUncheckedCreateWithoutWorkOrderInput = {
    id?: string
    description: string
    justification: string
    additionalCost: number
    additionalTime?: string | null
    status?: $Enums.ChangeRequestStatus
    decidedAt?: Date | string | null
    decidedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ChangeRequestCreateOrConnectWithoutWorkOrderInput = {
    where: ChangeRequestWhereUniqueInput
    create: XOR<ChangeRequestCreateWithoutWorkOrderInput, ChangeRequestUncheckedCreateWithoutWorkOrderInput>
  }

  export type ChangeRequestCreateManyWorkOrderInputEnvelope = {
    data: ChangeRequestCreateManyWorkOrderInput | ChangeRequestCreateManyWorkOrderInput[]
    skipDuplicates?: boolean
  }

  export type EvidenceCreateWithoutWorkOrderInput = {
    id?: string
    stage: $Enums.EvidenceStage
    url: string
    mediaType: $Enums.MediaType
    fileName?: string | null
    description?: string | null
    flagged?: boolean
    createdAt?: Date | string
  }

  export type EvidenceUncheckedCreateWithoutWorkOrderInput = {
    id?: string
    stage: $Enums.EvidenceStage
    url: string
    mediaType: $Enums.MediaType
    fileName?: string | null
    description?: string | null
    flagged?: boolean
    createdAt?: Date | string
  }

  export type EvidenceCreateOrConnectWithoutWorkOrderInput = {
    where: EvidenceWhereUniqueInput
    create: XOR<EvidenceCreateWithoutWorkOrderInput, EvidenceUncheckedCreateWithoutWorkOrderInput>
  }

  export type EvidenceCreateManyWorkOrderInputEnvelope = {
    data: EvidenceCreateManyWorkOrderInput | EvidenceCreateManyWorkOrderInput[]
    skipDuplicates?: boolean
  }

  export type ReviewCreateWithoutWorkOrderInput = {
    id?: string
    rating: number
    comment?: string | null
    editableUntil: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    workshop: WorkshopCreateNestedOneWithoutReviewsInput
    user: UserProfileCreateNestedOneWithoutReviewsInput
  }

  export type ReviewUncheckedCreateWithoutWorkOrderInput = {
    id?: string
    workshopId: string
    userId: string
    rating: number
    comment?: string | null
    editableUntil: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReviewCreateOrConnectWithoutWorkOrderInput = {
    where: ReviewWhereUniqueInput
    create: XOR<ReviewCreateWithoutWorkOrderInput, ReviewUncheckedCreateWithoutWorkOrderInput>
  }

  export type ReceiptCreateWithoutWorkOrderInput = {
    id?: string
    totalOriginal: number
    totalChanges: number
    totalFinal: number
    pdfUrl?: string | null
    createdAt?: Date | string
  }

  export type ReceiptUncheckedCreateWithoutWorkOrderInput = {
    id?: string
    totalOriginal: number
    totalChanges: number
    totalFinal: number
    pdfUrl?: string | null
    createdAt?: Date | string
  }

  export type ReceiptCreateOrConnectWithoutWorkOrderInput = {
    where: ReceiptWhereUniqueInput
    create: XOR<ReceiptCreateWithoutWorkOrderInput, ReceiptUncheckedCreateWithoutWorkOrderInput>
  }

  export type ServiceRequestUpsertWithoutWorkOrderInput = {
    update: XOR<ServiceRequestUpdateWithoutWorkOrderInput, ServiceRequestUncheckedUpdateWithoutWorkOrderInput>
    create: XOR<ServiceRequestCreateWithoutWorkOrderInput, ServiceRequestUncheckedCreateWithoutWorkOrderInput>
    where?: ServiceRequestWhereInput
  }

  export type ServiceRequestUpdateToOneWithWhereWithoutWorkOrderInput = {
    where?: ServiceRequestWhereInput
    data: XOR<ServiceRequestUpdateWithoutWorkOrderInput, ServiceRequestUncheckedUpdateWithoutWorkOrderInput>
  }

  export type ServiceRequestUpdateWithoutWorkOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    district?: StringFieldUpdateOperationsInput | string
    urgency?: EnumUrgencyLevelFieldUpdateOperationsInput | $Enums.UrgencyLevel
    status?: EnumServiceRequestStatusFieldUpdateOperationsInput | $Enums.ServiceRequestStatus
    completionScore?: IntFieldUpdateOperationsInput | number
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserProfileUpdateOneRequiredWithoutServiceRequestsNestedInput
    motorcycle?: MotorcycleUpdateOneRequiredWithoutServiceRequestsNestedInput
    category?: CategoryUpdateOneRequiredWithoutServiceRequestsNestedInput
    media?: RequestMediaUpdateManyWithoutRequestNestedInput
    guideAnswers?: GuideAnswerUpdateManyWithoutRequestNestedInput
    quotes?: QuoteUpdateManyWithoutRequestNestedInput
    statusHistory?: RequestStatusHistoryUpdateManyWithoutRequestNestedInput
    notifications?: NotificationUpdateManyWithoutRequestNestedInput
    chatMessages?: ChatMessageUpdateManyWithoutRequestNestedInput
    aiSuggestions?: AiSuggestionUpdateManyWithoutRequestNestedInput
  }

  export type ServiceRequestUncheckedUpdateWithoutWorkOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    motorcycleId?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    district?: StringFieldUpdateOperationsInput | string
    urgency?: EnumUrgencyLevelFieldUpdateOperationsInput | $Enums.UrgencyLevel
    status?: EnumServiceRequestStatusFieldUpdateOperationsInput | $Enums.ServiceRequestStatus
    completionScore?: IntFieldUpdateOperationsInput | number
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    media?: RequestMediaUncheckedUpdateManyWithoutRequestNestedInput
    guideAnswers?: GuideAnswerUncheckedUpdateManyWithoutRequestNestedInput
    quotes?: QuoteUncheckedUpdateManyWithoutRequestNestedInput
    statusHistory?: RequestStatusHistoryUncheckedUpdateManyWithoutRequestNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutRequestNestedInput
    chatMessages?: ChatMessageUncheckedUpdateManyWithoutRequestNestedInput
    aiSuggestions?: AiSuggestionUncheckedUpdateManyWithoutRequestNestedInput
  }

  export type QuoteUpsertWithoutWorkOrderInput = {
    update: XOR<QuoteUpdateWithoutWorkOrderInput, QuoteUncheckedUpdateWithoutWorkOrderInput>
    create: XOR<QuoteCreateWithoutWorkOrderInput, QuoteUncheckedCreateWithoutWorkOrderInput>
    where?: QuoteWhereInput
  }

  export type QuoteUpdateToOneWithWhereWithoutWorkOrderInput = {
    where?: QuoteWhereInput
    data: XOR<QuoteUpdateWithoutWorkOrderInput, QuoteUncheckedUpdateWithoutWorkOrderInput>
  }

  export type QuoteUpdateWithoutWorkOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    diagnosis?: StringFieldUpdateOperationsInput | string
    laborCost?: FloatFieldUpdateOperationsInput | number
    totalParts?: FloatFieldUpdateOperationsInput | number
    totalCost?: FloatFieldUpdateOperationsInput | number
    estimatedTime?: StringFieldUpdateOperationsInput | string
    validUntil?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumQuoteStatusFieldUpdateOperationsInput | $Enums.QuoteStatus
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    request?: ServiceRequestUpdateOneRequiredWithoutQuotesNestedInput
    workshop?: WorkshopUpdateOneRequiredWithoutQuotesNestedInput
    parts?: QuotePartItemUpdateManyWithoutQuoteNestedInput
    aiAnalysis?: AiQuoteAnalysisUpdateManyWithoutQuoteNestedInput
  }

  export type QuoteUncheckedUpdateWithoutWorkOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    requestId?: StringFieldUpdateOperationsInput | string
    workshopId?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    diagnosis?: StringFieldUpdateOperationsInput | string
    laborCost?: FloatFieldUpdateOperationsInput | number
    totalParts?: FloatFieldUpdateOperationsInput | number
    totalCost?: FloatFieldUpdateOperationsInput | number
    estimatedTime?: StringFieldUpdateOperationsInput | string
    validUntil?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumQuoteStatusFieldUpdateOperationsInput | $Enums.QuoteStatus
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parts?: QuotePartItemUncheckedUpdateManyWithoutQuoteNestedInput
    aiAnalysis?: AiQuoteAnalysisUncheckedUpdateManyWithoutQuoteNestedInput
  }

  export type WorkshopUpsertWithoutWorkOrdersInput = {
    update: XOR<WorkshopUpdateWithoutWorkOrdersInput, WorkshopUncheckedUpdateWithoutWorkOrdersInput>
    create: XOR<WorkshopCreateWithoutWorkOrdersInput, WorkshopUncheckedCreateWithoutWorkOrdersInput>
    where?: WorkshopWhereInput
  }

  export type WorkshopUpdateToOneWithWhereWithoutWorkOrdersInput = {
    where?: WorkshopWhereInput
    data: XOR<WorkshopUpdateWithoutWorkOrdersInput, WorkshopUncheckedUpdateWithoutWorkOrdersInput>
  }

  export type WorkshopUpdateWithoutWorkOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    district?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    ruc?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumWorkshopStatusFieldUpdateOperationsInput | $Enums.WorkshopStatus
    transparencyAccepted?: BoolFieldUpdateOperationsInput | boolean
    guaranteePolicy?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    rating?: FloatFieldUpdateOperationsInput | number
    totalServices?: IntFieldUpdateOperationsInput | number
    evidenceRate?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserProfileUpdateOneRequiredWithoutWorkshopNestedInput
    categories?: WorkshopCategoryUpdateManyWithoutWorkshopNestedInput
    quotes?: QuoteUpdateManyWithoutWorkshopNestedInput
    reviews?: ReviewUpdateManyWithoutWorkshopNestedInput
    incidentReports?: IncidentReportUpdateManyWithoutWorkshopNestedInput
    verifications?: WorkshopVerificationUpdateManyWithoutWorkshopNestedInput
  }

  export type WorkshopUncheckedUpdateWithoutWorkOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    district?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    ruc?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumWorkshopStatusFieldUpdateOperationsInput | $Enums.WorkshopStatus
    transparencyAccepted?: BoolFieldUpdateOperationsInput | boolean
    guaranteePolicy?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    rating?: FloatFieldUpdateOperationsInput | number
    totalServices?: IntFieldUpdateOperationsInput | number
    evidenceRate?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    categories?: WorkshopCategoryUncheckedUpdateManyWithoutWorkshopNestedInput
    quotes?: QuoteUncheckedUpdateManyWithoutWorkshopNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutWorkshopNestedInput
    incidentReports?: IncidentReportUncheckedUpdateManyWithoutWorkshopNestedInput
    verifications?: WorkshopVerificationUncheckedUpdateManyWithoutWorkshopNestedInput
  }

  export type ChangeRequestUpsertWithWhereUniqueWithoutWorkOrderInput = {
    where: ChangeRequestWhereUniqueInput
    update: XOR<ChangeRequestUpdateWithoutWorkOrderInput, ChangeRequestUncheckedUpdateWithoutWorkOrderInput>
    create: XOR<ChangeRequestCreateWithoutWorkOrderInput, ChangeRequestUncheckedCreateWithoutWorkOrderInput>
  }

  export type ChangeRequestUpdateWithWhereUniqueWithoutWorkOrderInput = {
    where: ChangeRequestWhereUniqueInput
    data: XOR<ChangeRequestUpdateWithoutWorkOrderInput, ChangeRequestUncheckedUpdateWithoutWorkOrderInput>
  }

  export type ChangeRequestUpdateManyWithWhereWithoutWorkOrderInput = {
    where: ChangeRequestScalarWhereInput
    data: XOR<ChangeRequestUpdateManyMutationInput, ChangeRequestUncheckedUpdateManyWithoutWorkOrderInput>
  }

  export type ChangeRequestScalarWhereInput = {
    AND?: ChangeRequestScalarWhereInput | ChangeRequestScalarWhereInput[]
    OR?: ChangeRequestScalarWhereInput[]
    NOT?: ChangeRequestScalarWhereInput | ChangeRequestScalarWhereInput[]
    id?: StringFilter<"ChangeRequest"> | string
    workOrderId?: StringFilter<"ChangeRequest"> | string
    description?: StringFilter<"ChangeRequest"> | string
    justification?: StringFilter<"ChangeRequest"> | string
    additionalCost?: FloatFilter<"ChangeRequest"> | number
    additionalTime?: StringNullableFilter<"ChangeRequest"> | string | null
    status?: EnumChangeRequestStatusFilter<"ChangeRequest"> | $Enums.ChangeRequestStatus
    decidedAt?: DateTimeNullableFilter<"ChangeRequest"> | Date | string | null
    decidedBy?: StringNullableFilter<"ChangeRequest"> | string | null
    createdAt?: DateTimeFilter<"ChangeRequest"> | Date | string
    updatedAt?: DateTimeFilter<"ChangeRequest"> | Date | string
  }

  export type EvidenceUpsertWithWhereUniqueWithoutWorkOrderInput = {
    where: EvidenceWhereUniqueInput
    update: XOR<EvidenceUpdateWithoutWorkOrderInput, EvidenceUncheckedUpdateWithoutWorkOrderInput>
    create: XOR<EvidenceCreateWithoutWorkOrderInput, EvidenceUncheckedCreateWithoutWorkOrderInput>
  }

  export type EvidenceUpdateWithWhereUniqueWithoutWorkOrderInput = {
    where: EvidenceWhereUniqueInput
    data: XOR<EvidenceUpdateWithoutWorkOrderInput, EvidenceUncheckedUpdateWithoutWorkOrderInput>
  }

  export type EvidenceUpdateManyWithWhereWithoutWorkOrderInput = {
    where: EvidenceScalarWhereInput
    data: XOR<EvidenceUpdateManyMutationInput, EvidenceUncheckedUpdateManyWithoutWorkOrderInput>
  }

  export type EvidenceScalarWhereInput = {
    AND?: EvidenceScalarWhereInput | EvidenceScalarWhereInput[]
    OR?: EvidenceScalarWhereInput[]
    NOT?: EvidenceScalarWhereInput | EvidenceScalarWhereInput[]
    id?: StringFilter<"Evidence"> | string
    workOrderId?: StringFilter<"Evidence"> | string
    stage?: EnumEvidenceStageFilter<"Evidence"> | $Enums.EvidenceStage
    url?: StringFilter<"Evidence"> | string
    mediaType?: EnumMediaTypeFilter<"Evidence"> | $Enums.MediaType
    fileName?: StringNullableFilter<"Evidence"> | string | null
    description?: StringNullableFilter<"Evidence"> | string | null
    flagged?: BoolFilter<"Evidence"> | boolean
    createdAt?: DateTimeFilter<"Evidence"> | Date | string
  }

  export type ReviewUpsertWithoutWorkOrderInput = {
    update: XOR<ReviewUpdateWithoutWorkOrderInput, ReviewUncheckedUpdateWithoutWorkOrderInput>
    create: XOR<ReviewCreateWithoutWorkOrderInput, ReviewUncheckedCreateWithoutWorkOrderInput>
    where?: ReviewWhereInput
  }

  export type ReviewUpdateToOneWithWhereWithoutWorkOrderInput = {
    where?: ReviewWhereInput
    data: XOR<ReviewUpdateWithoutWorkOrderInput, ReviewUncheckedUpdateWithoutWorkOrderInput>
  }

  export type ReviewUpdateWithoutWorkOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    editableUntil?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workshop?: WorkshopUpdateOneRequiredWithoutReviewsNestedInput
    user?: UserProfileUpdateOneRequiredWithoutReviewsNestedInput
  }

  export type ReviewUncheckedUpdateWithoutWorkOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    workshopId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    editableUntil?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReceiptUpsertWithoutWorkOrderInput = {
    update: XOR<ReceiptUpdateWithoutWorkOrderInput, ReceiptUncheckedUpdateWithoutWorkOrderInput>
    create: XOR<ReceiptCreateWithoutWorkOrderInput, ReceiptUncheckedCreateWithoutWorkOrderInput>
    where?: ReceiptWhereInput
  }

  export type ReceiptUpdateToOneWithWhereWithoutWorkOrderInput = {
    where?: ReceiptWhereInput
    data: XOR<ReceiptUpdateWithoutWorkOrderInput, ReceiptUncheckedUpdateWithoutWorkOrderInput>
  }

  export type ReceiptUpdateWithoutWorkOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalOriginal?: FloatFieldUpdateOperationsInput | number
    totalChanges?: FloatFieldUpdateOperationsInput | number
    totalFinal?: FloatFieldUpdateOperationsInput | number
    pdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReceiptUncheckedUpdateWithoutWorkOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalOriginal?: FloatFieldUpdateOperationsInput | number
    totalChanges?: FloatFieldUpdateOperationsInput | number
    totalFinal?: FloatFieldUpdateOperationsInput | number
    pdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkOrderCreateWithoutChangeRequestsInput = {
    id?: string
    orderNumber: string
    diagnosis: string
    totalAgreed: number
    totalFinal?: number | null
    status?: $Enums.WorkOrderStatus
    userAcceptedAt?: Date | string | null
    workshopAcceptedAt?: Date | string | null
    startedAt?: Date | string | null
    startNote?: string | null
    completedAt?: Date | string | null
    closedAt?: Date | string | null
    closureChecklist?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    request: ServiceRequestCreateNestedOneWithoutWorkOrderInput
    quote: QuoteCreateNestedOneWithoutWorkOrderInput
    workshop: WorkshopCreateNestedOneWithoutWorkOrdersInput
    evidences?: EvidenceCreateNestedManyWithoutWorkOrderInput
    review?: ReviewCreateNestedOneWithoutWorkOrderInput
    receipt?: ReceiptCreateNestedOneWithoutWorkOrderInput
  }

  export type WorkOrderUncheckedCreateWithoutChangeRequestsInput = {
    id?: string
    orderNumber: string
    requestId: string
    quoteId: string
    workshopId: string
    diagnosis: string
    totalAgreed: number
    totalFinal?: number | null
    status?: $Enums.WorkOrderStatus
    userAcceptedAt?: Date | string | null
    workshopAcceptedAt?: Date | string | null
    startedAt?: Date | string | null
    startNote?: string | null
    completedAt?: Date | string | null
    closedAt?: Date | string | null
    closureChecklist?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    evidences?: EvidenceUncheckedCreateNestedManyWithoutWorkOrderInput
    review?: ReviewUncheckedCreateNestedOneWithoutWorkOrderInput
    receipt?: ReceiptUncheckedCreateNestedOneWithoutWorkOrderInput
  }

  export type WorkOrderCreateOrConnectWithoutChangeRequestsInput = {
    where: WorkOrderWhereUniqueInput
    create: XOR<WorkOrderCreateWithoutChangeRequestsInput, WorkOrderUncheckedCreateWithoutChangeRequestsInput>
  }

  export type WorkOrderUpsertWithoutChangeRequestsInput = {
    update: XOR<WorkOrderUpdateWithoutChangeRequestsInput, WorkOrderUncheckedUpdateWithoutChangeRequestsInput>
    create: XOR<WorkOrderCreateWithoutChangeRequestsInput, WorkOrderUncheckedCreateWithoutChangeRequestsInput>
    where?: WorkOrderWhereInput
  }

  export type WorkOrderUpdateToOneWithWhereWithoutChangeRequestsInput = {
    where?: WorkOrderWhereInput
    data: XOR<WorkOrderUpdateWithoutChangeRequestsInput, WorkOrderUncheckedUpdateWithoutChangeRequestsInput>
  }

  export type WorkOrderUpdateWithoutChangeRequestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    diagnosis?: StringFieldUpdateOperationsInput | string
    totalAgreed?: FloatFieldUpdateOperationsInput | number
    totalFinal?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumWorkOrderStatusFieldUpdateOperationsInput | $Enums.WorkOrderStatus
    userAcceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    workshopAcceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startNote?: NullableStringFieldUpdateOperationsInput | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closureChecklist?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    request?: ServiceRequestUpdateOneRequiredWithoutWorkOrderNestedInput
    quote?: QuoteUpdateOneRequiredWithoutWorkOrderNestedInput
    workshop?: WorkshopUpdateOneRequiredWithoutWorkOrdersNestedInput
    evidences?: EvidenceUpdateManyWithoutWorkOrderNestedInput
    review?: ReviewUpdateOneWithoutWorkOrderNestedInput
    receipt?: ReceiptUpdateOneWithoutWorkOrderNestedInput
  }

  export type WorkOrderUncheckedUpdateWithoutChangeRequestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    requestId?: StringFieldUpdateOperationsInput | string
    quoteId?: StringFieldUpdateOperationsInput | string
    workshopId?: StringFieldUpdateOperationsInput | string
    diagnosis?: StringFieldUpdateOperationsInput | string
    totalAgreed?: FloatFieldUpdateOperationsInput | number
    totalFinal?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumWorkOrderStatusFieldUpdateOperationsInput | $Enums.WorkOrderStatus
    userAcceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    workshopAcceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startNote?: NullableStringFieldUpdateOperationsInput | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closureChecklist?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    evidences?: EvidenceUncheckedUpdateManyWithoutWorkOrderNestedInput
    review?: ReviewUncheckedUpdateOneWithoutWorkOrderNestedInput
    receipt?: ReceiptUncheckedUpdateOneWithoutWorkOrderNestedInput
  }

  export type WorkOrderCreateWithoutEvidencesInput = {
    id?: string
    orderNumber: string
    diagnosis: string
    totalAgreed: number
    totalFinal?: number | null
    status?: $Enums.WorkOrderStatus
    userAcceptedAt?: Date | string | null
    workshopAcceptedAt?: Date | string | null
    startedAt?: Date | string | null
    startNote?: string | null
    completedAt?: Date | string | null
    closedAt?: Date | string | null
    closureChecklist?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    request: ServiceRequestCreateNestedOneWithoutWorkOrderInput
    quote: QuoteCreateNestedOneWithoutWorkOrderInput
    workshop: WorkshopCreateNestedOneWithoutWorkOrdersInput
    changeRequests?: ChangeRequestCreateNestedManyWithoutWorkOrderInput
    review?: ReviewCreateNestedOneWithoutWorkOrderInput
    receipt?: ReceiptCreateNestedOneWithoutWorkOrderInput
  }

  export type WorkOrderUncheckedCreateWithoutEvidencesInput = {
    id?: string
    orderNumber: string
    requestId: string
    quoteId: string
    workshopId: string
    diagnosis: string
    totalAgreed: number
    totalFinal?: number | null
    status?: $Enums.WorkOrderStatus
    userAcceptedAt?: Date | string | null
    workshopAcceptedAt?: Date | string | null
    startedAt?: Date | string | null
    startNote?: string | null
    completedAt?: Date | string | null
    closedAt?: Date | string | null
    closureChecklist?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    changeRequests?: ChangeRequestUncheckedCreateNestedManyWithoutWorkOrderInput
    review?: ReviewUncheckedCreateNestedOneWithoutWorkOrderInput
    receipt?: ReceiptUncheckedCreateNestedOneWithoutWorkOrderInput
  }

  export type WorkOrderCreateOrConnectWithoutEvidencesInput = {
    where: WorkOrderWhereUniqueInput
    create: XOR<WorkOrderCreateWithoutEvidencesInput, WorkOrderUncheckedCreateWithoutEvidencesInput>
  }

  export type WorkOrderUpsertWithoutEvidencesInput = {
    update: XOR<WorkOrderUpdateWithoutEvidencesInput, WorkOrderUncheckedUpdateWithoutEvidencesInput>
    create: XOR<WorkOrderCreateWithoutEvidencesInput, WorkOrderUncheckedCreateWithoutEvidencesInput>
    where?: WorkOrderWhereInput
  }

  export type WorkOrderUpdateToOneWithWhereWithoutEvidencesInput = {
    where?: WorkOrderWhereInput
    data: XOR<WorkOrderUpdateWithoutEvidencesInput, WorkOrderUncheckedUpdateWithoutEvidencesInput>
  }

  export type WorkOrderUpdateWithoutEvidencesInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    diagnosis?: StringFieldUpdateOperationsInput | string
    totalAgreed?: FloatFieldUpdateOperationsInput | number
    totalFinal?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumWorkOrderStatusFieldUpdateOperationsInput | $Enums.WorkOrderStatus
    userAcceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    workshopAcceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startNote?: NullableStringFieldUpdateOperationsInput | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closureChecklist?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    request?: ServiceRequestUpdateOneRequiredWithoutWorkOrderNestedInput
    quote?: QuoteUpdateOneRequiredWithoutWorkOrderNestedInput
    workshop?: WorkshopUpdateOneRequiredWithoutWorkOrdersNestedInput
    changeRequests?: ChangeRequestUpdateManyWithoutWorkOrderNestedInput
    review?: ReviewUpdateOneWithoutWorkOrderNestedInput
    receipt?: ReceiptUpdateOneWithoutWorkOrderNestedInput
  }

  export type WorkOrderUncheckedUpdateWithoutEvidencesInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    requestId?: StringFieldUpdateOperationsInput | string
    quoteId?: StringFieldUpdateOperationsInput | string
    workshopId?: StringFieldUpdateOperationsInput | string
    diagnosis?: StringFieldUpdateOperationsInput | string
    totalAgreed?: FloatFieldUpdateOperationsInput | number
    totalFinal?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumWorkOrderStatusFieldUpdateOperationsInput | $Enums.WorkOrderStatus
    userAcceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    workshopAcceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startNote?: NullableStringFieldUpdateOperationsInput | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closureChecklist?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    changeRequests?: ChangeRequestUncheckedUpdateManyWithoutWorkOrderNestedInput
    review?: ReviewUncheckedUpdateOneWithoutWorkOrderNestedInput
    receipt?: ReceiptUncheckedUpdateOneWithoutWorkOrderNestedInput
  }

  export type WorkOrderCreateWithoutReviewInput = {
    id?: string
    orderNumber: string
    diagnosis: string
    totalAgreed: number
    totalFinal?: number | null
    status?: $Enums.WorkOrderStatus
    userAcceptedAt?: Date | string | null
    workshopAcceptedAt?: Date | string | null
    startedAt?: Date | string | null
    startNote?: string | null
    completedAt?: Date | string | null
    closedAt?: Date | string | null
    closureChecklist?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    request: ServiceRequestCreateNestedOneWithoutWorkOrderInput
    quote: QuoteCreateNestedOneWithoutWorkOrderInput
    workshop: WorkshopCreateNestedOneWithoutWorkOrdersInput
    changeRequests?: ChangeRequestCreateNestedManyWithoutWorkOrderInput
    evidences?: EvidenceCreateNestedManyWithoutWorkOrderInput
    receipt?: ReceiptCreateNestedOneWithoutWorkOrderInput
  }

  export type WorkOrderUncheckedCreateWithoutReviewInput = {
    id?: string
    orderNumber: string
    requestId: string
    quoteId: string
    workshopId: string
    diagnosis: string
    totalAgreed: number
    totalFinal?: number | null
    status?: $Enums.WorkOrderStatus
    userAcceptedAt?: Date | string | null
    workshopAcceptedAt?: Date | string | null
    startedAt?: Date | string | null
    startNote?: string | null
    completedAt?: Date | string | null
    closedAt?: Date | string | null
    closureChecklist?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    changeRequests?: ChangeRequestUncheckedCreateNestedManyWithoutWorkOrderInput
    evidences?: EvidenceUncheckedCreateNestedManyWithoutWorkOrderInput
    receipt?: ReceiptUncheckedCreateNestedOneWithoutWorkOrderInput
  }

  export type WorkOrderCreateOrConnectWithoutReviewInput = {
    where: WorkOrderWhereUniqueInput
    create: XOR<WorkOrderCreateWithoutReviewInput, WorkOrderUncheckedCreateWithoutReviewInput>
  }

  export type WorkshopCreateWithoutReviewsInput = {
    id?: string
    name: string
    address: string
    district: string
    phone: string
    ruc?: string | null
    description?: string | null
    photoUrl?: string | null
    status?: $Enums.WorkshopStatus
    transparencyAccepted?: boolean
    guaranteePolicy?: string | null
    latitude?: number | null
    longitude?: number | null
    rating?: number
    totalServices?: number
    evidenceRate?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserProfileCreateNestedOneWithoutWorkshopInput
    categories?: WorkshopCategoryCreateNestedManyWithoutWorkshopInput
    quotes?: QuoteCreateNestedManyWithoutWorkshopInput
    workOrders?: WorkOrderCreateNestedManyWithoutWorkshopInput
    incidentReports?: IncidentReportCreateNestedManyWithoutWorkshopInput
    verifications?: WorkshopVerificationCreateNestedManyWithoutWorkshopInput
  }

  export type WorkshopUncheckedCreateWithoutReviewsInput = {
    id?: string
    userId: string
    name: string
    address: string
    district: string
    phone: string
    ruc?: string | null
    description?: string | null
    photoUrl?: string | null
    status?: $Enums.WorkshopStatus
    transparencyAccepted?: boolean
    guaranteePolicy?: string | null
    latitude?: number | null
    longitude?: number | null
    rating?: number
    totalServices?: number
    evidenceRate?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    categories?: WorkshopCategoryUncheckedCreateNestedManyWithoutWorkshopInput
    quotes?: QuoteUncheckedCreateNestedManyWithoutWorkshopInput
    workOrders?: WorkOrderUncheckedCreateNestedManyWithoutWorkshopInput
    incidentReports?: IncidentReportUncheckedCreateNestedManyWithoutWorkshopInput
    verifications?: WorkshopVerificationUncheckedCreateNestedManyWithoutWorkshopInput
  }

  export type WorkshopCreateOrConnectWithoutReviewsInput = {
    where: WorkshopWhereUniqueInput
    create: XOR<WorkshopCreateWithoutReviewsInput, WorkshopUncheckedCreateWithoutReviewsInput>
  }

  export type UserProfileCreateWithoutReviewsInput = {
    id?: string
    clerkUserId: string
    role?: $Enums.UserRole
    email?: string | null
    phone?: string | null
    name?: string | null
    district?: string | null
    avatarUrl?: string | null
    notifChannel?: $Enums.NotificationChannel
    phoneVisible?: boolean
    termsAccepted?: boolean
    termsVersion?: string | null
    termsAcceptedAt?: Date | string | null
    privacyAccepted?: boolean
    privacyVersion?: string | null
    privacyAcceptedAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    motorcycles?: MotorcycleCreateNestedManyWithoutUserInput
    serviceRequests?: ServiceRequestCreateNestedManyWithoutUserInput
    incidentReports?: IncidentReportCreateNestedManyWithoutReporterInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    chatMessages?: ChatMessageCreateNestedManyWithoutSenderInput
    workshop?: WorkshopCreateNestedOneWithoutUserInput
  }

  export type UserProfileUncheckedCreateWithoutReviewsInput = {
    id?: string
    clerkUserId: string
    role?: $Enums.UserRole
    email?: string | null
    phone?: string | null
    name?: string | null
    district?: string | null
    avatarUrl?: string | null
    notifChannel?: $Enums.NotificationChannel
    phoneVisible?: boolean
    termsAccepted?: boolean
    termsVersion?: string | null
    termsAcceptedAt?: Date | string | null
    privacyAccepted?: boolean
    privacyVersion?: string | null
    privacyAcceptedAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    motorcycles?: MotorcycleUncheckedCreateNestedManyWithoutUserInput
    serviceRequests?: ServiceRequestUncheckedCreateNestedManyWithoutUserInput
    incidentReports?: IncidentReportUncheckedCreateNestedManyWithoutReporterInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    chatMessages?: ChatMessageUncheckedCreateNestedManyWithoutSenderInput
    workshop?: WorkshopUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserProfileCreateOrConnectWithoutReviewsInput = {
    where: UserProfileWhereUniqueInput
    create: XOR<UserProfileCreateWithoutReviewsInput, UserProfileUncheckedCreateWithoutReviewsInput>
  }

  export type WorkOrderUpsertWithoutReviewInput = {
    update: XOR<WorkOrderUpdateWithoutReviewInput, WorkOrderUncheckedUpdateWithoutReviewInput>
    create: XOR<WorkOrderCreateWithoutReviewInput, WorkOrderUncheckedCreateWithoutReviewInput>
    where?: WorkOrderWhereInput
  }

  export type WorkOrderUpdateToOneWithWhereWithoutReviewInput = {
    where?: WorkOrderWhereInput
    data: XOR<WorkOrderUpdateWithoutReviewInput, WorkOrderUncheckedUpdateWithoutReviewInput>
  }

  export type WorkOrderUpdateWithoutReviewInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    diagnosis?: StringFieldUpdateOperationsInput | string
    totalAgreed?: FloatFieldUpdateOperationsInput | number
    totalFinal?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumWorkOrderStatusFieldUpdateOperationsInput | $Enums.WorkOrderStatus
    userAcceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    workshopAcceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startNote?: NullableStringFieldUpdateOperationsInput | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closureChecklist?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    request?: ServiceRequestUpdateOneRequiredWithoutWorkOrderNestedInput
    quote?: QuoteUpdateOneRequiredWithoutWorkOrderNestedInput
    workshop?: WorkshopUpdateOneRequiredWithoutWorkOrdersNestedInput
    changeRequests?: ChangeRequestUpdateManyWithoutWorkOrderNestedInput
    evidences?: EvidenceUpdateManyWithoutWorkOrderNestedInput
    receipt?: ReceiptUpdateOneWithoutWorkOrderNestedInput
  }

  export type WorkOrderUncheckedUpdateWithoutReviewInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    requestId?: StringFieldUpdateOperationsInput | string
    quoteId?: StringFieldUpdateOperationsInput | string
    workshopId?: StringFieldUpdateOperationsInput | string
    diagnosis?: StringFieldUpdateOperationsInput | string
    totalAgreed?: FloatFieldUpdateOperationsInput | number
    totalFinal?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumWorkOrderStatusFieldUpdateOperationsInput | $Enums.WorkOrderStatus
    userAcceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    workshopAcceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startNote?: NullableStringFieldUpdateOperationsInput | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closureChecklist?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    changeRequests?: ChangeRequestUncheckedUpdateManyWithoutWorkOrderNestedInput
    evidences?: EvidenceUncheckedUpdateManyWithoutWorkOrderNestedInput
    receipt?: ReceiptUncheckedUpdateOneWithoutWorkOrderNestedInput
  }

  export type WorkshopUpsertWithoutReviewsInput = {
    update: XOR<WorkshopUpdateWithoutReviewsInput, WorkshopUncheckedUpdateWithoutReviewsInput>
    create: XOR<WorkshopCreateWithoutReviewsInput, WorkshopUncheckedCreateWithoutReviewsInput>
    where?: WorkshopWhereInput
  }

  export type WorkshopUpdateToOneWithWhereWithoutReviewsInput = {
    where?: WorkshopWhereInput
    data: XOR<WorkshopUpdateWithoutReviewsInput, WorkshopUncheckedUpdateWithoutReviewsInput>
  }

  export type WorkshopUpdateWithoutReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    district?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    ruc?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumWorkshopStatusFieldUpdateOperationsInput | $Enums.WorkshopStatus
    transparencyAccepted?: BoolFieldUpdateOperationsInput | boolean
    guaranteePolicy?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    rating?: FloatFieldUpdateOperationsInput | number
    totalServices?: IntFieldUpdateOperationsInput | number
    evidenceRate?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserProfileUpdateOneRequiredWithoutWorkshopNestedInput
    categories?: WorkshopCategoryUpdateManyWithoutWorkshopNestedInput
    quotes?: QuoteUpdateManyWithoutWorkshopNestedInput
    workOrders?: WorkOrderUpdateManyWithoutWorkshopNestedInput
    incidentReports?: IncidentReportUpdateManyWithoutWorkshopNestedInput
    verifications?: WorkshopVerificationUpdateManyWithoutWorkshopNestedInput
  }

  export type WorkshopUncheckedUpdateWithoutReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    district?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    ruc?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumWorkshopStatusFieldUpdateOperationsInput | $Enums.WorkshopStatus
    transparencyAccepted?: BoolFieldUpdateOperationsInput | boolean
    guaranteePolicy?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    rating?: FloatFieldUpdateOperationsInput | number
    totalServices?: IntFieldUpdateOperationsInput | number
    evidenceRate?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    categories?: WorkshopCategoryUncheckedUpdateManyWithoutWorkshopNestedInput
    quotes?: QuoteUncheckedUpdateManyWithoutWorkshopNestedInput
    workOrders?: WorkOrderUncheckedUpdateManyWithoutWorkshopNestedInput
    incidentReports?: IncidentReportUncheckedUpdateManyWithoutWorkshopNestedInput
    verifications?: WorkshopVerificationUncheckedUpdateManyWithoutWorkshopNestedInput
  }

  export type UserProfileUpsertWithoutReviewsInput = {
    update: XOR<UserProfileUpdateWithoutReviewsInput, UserProfileUncheckedUpdateWithoutReviewsInput>
    create: XOR<UserProfileCreateWithoutReviewsInput, UserProfileUncheckedCreateWithoutReviewsInput>
    where?: UserProfileWhereInput
  }

  export type UserProfileUpdateToOneWithWhereWithoutReviewsInput = {
    where?: UserProfileWhereInput
    data: XOR<UserProfileUpdateWithoutReviewsInput, UserProfileUncheckedUpdateWithoutReviewsInput>
  }

  export type UserProfileUpdateWithoutReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    clerkUserId?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    notifChannel?: EnumNotificationChannelFieldUpdateOperationsInput | $Enums.NotificationChannel
    phoneVisible?: BoolFieldUpdateOperationsInput | boolean
    termsAccepted?: BoolFieldUpdateOperationsInput | boolean
    termsVersion?: NullableStringFieldUpdateOperationsInput | string | null
    termsAcceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    privacyAccepted?: BoolFieldUpdateOperationsInput | boolean
    privacyVersion?: NullableStringFieldUpdateOperationsInput | string | null
    privacyAcceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    motorcycles?: MotorcycleUpdateManyWithoutUserNestedInput
    serviceRequests?: ServiceRequestUpdateManyWithoutUserNestedInput
    incidentReports?: IncidentReportUpdateManyWithoutReporterNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    chatMessages?: ChatMessageUpdateManyWithoutSenderNestedInput
    workshop?: WorkshopUpdateOneWithoutUserNestedInput
  }

  export type UserProfileUncheckedUpdateWithoutReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    clerkUserId?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    notifChannel?: EnumNotificationChannelFieldUpdateOperationsInput | $Enums.NotificationChannel
    phoneVisible?: BoolFieldUpdateOperationsInput | boolean
    termsAccepted?: BoolFieldUpdateOperationsInput | boolean
    termsVersion?: NullableStringFieldUpdateOperationsInput | string | null
    termsAcceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    privacyAccepted?: BoolFieldUpdateOperationsInput | boolean
    privacyVersion?: NullableStringFieldUpdateOperationsInput | string | null
    privacyAcceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    motorcycles?: MotorcycleUncheckedUpdateManyWithoutUserNestedInput
    serviceRequests?: ServiceRequestUncheckedUpdateManyWithoutUserNestedInput
    incidentReports?: IncidentReportUncheckedUpdateManyWithoutReporterNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    chatMessages?: ChatMessageUncheckedUpdateManyWithoutSenderNestedInput
    workshop?: WorkshopUncheckedUpdateOneWithoutUserNestedInput
  }

  export type WorkOrderCreateWithoutReceiptInput = {
    id?: string
    orderNumber: string
    diagnosis: string
    totalAgreed: number
    totalFinal?: number | null
    status?: $Enums.WorkOrderStatus
    userAcceptedAt?: Date | string | null
    workshopAcceptedAt?: Date | string | null
    startedAt?: Date | string | null
    startNote?: string | null
    completedAt?: Date | string | null
    closedAt?: Date | string | null
    closureChecklist?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    request: ServiceRequestCreateNestedOneWithoutWorkOrderInput
    quote: QuoteCreateNestedOneWithoutWorkOrderInput
    workshop: WorkshopCreateNestedOneWithoutWorkOrdersInput
    changeRequests?: ChangeRequestCreateNestedManyWithoutWorkOrderInput
    evidences?: EvidenceCreateNestedManyWithoutWorkOrderInput
    review?: ReviewCreateNestedOneWithoutWorkOrderInput
  }

  export type WorkOrderUncheckedCreateWithoutReceiptInput = {
    id?: string
    orderNumber: string
    requestId: string
    quoteId: string
    workshopId: string
    diagnosis: string
    totalAgreed: number
    totalFinal?: number | null
    status?: $Enums.WorkOrderStatus
    userAcceptedAt?: Date | string | null
    workshopAcceptedAt?: Date | string | null
    startedAt?: Date | string | null
    startNote?: string | null
    completedAt?: Date | string | null
    closedAt?: Date | string | null
    closureChecklist?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    changeRequests?: ChangeRequestUncheckedCreateNestedManyWithoutWorkOrderInput
    evidences?: EvidenceUncheckedCreateNestedManyWithoutWorkOrderInput
    review?: ReviewUncheckedCreateNestedOneWithoutWorkOrderInput
  }

  export type WorkOrderCreateOrConnectWithoutReceiptInput = {
    where: WorkOrderWhereUniqueInput
    create: XOR<WorkOrderCreateWithoutReceiptInput, WorkOrderUncheckedCreateWithoutReceiptInput>
  }

  export type WorkOrderUpsertWithoutReceiptInput = {
    update: XOR<WorkOrderUpdateWithoutReceiptInput, WorkOrderUncheckedUpdateWithoutReceiptInput>
    create: XOR<WorkOrderCreateWithoutReceiptInput, WorkOrderUncheckedCreateWithoutReceiptInput>
    where?: WorkOrderWhereInput
  }

  export type WorkOrderUpdateToOneWithWhereWithoutReceiptInput = {
    where?: WorkOrderWhereInput
    data: XOR<WorkOrderUpdateWithoutReceiptInput, WorkOrderUncheckedUpdateWithoutReceiptInput>
  }

  export type WorkOrderUpdateWithoutReceiptInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    diagnosis?: StringFieldUpdateOperationsInput | string
    totalAgreed?: FloatFieldUpdateOperationsInput | number
    totalFinal?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumWorkOrderStatusFieldUpdateOperationsInput | $Enums.WorkOrderStatus
    userAcceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    workshopAcceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startNote?: NullableStringFieldUpdateOperationsInput | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closureChecklist?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    request?: ServiceRequestUpdateOneRequiredWithoutWorkOrderNestedInput
    quote?: QuoteUpdateOneRequiredWithoutWorkOrderNestedInput
    workshop?: WorkshopUpdateOneRequiredWithoutWorkOrdersNestedInput
    changeRequests?: ChangeRequestUpdateManyWithoutWorkOrderNestedInput
    evidences?: EvidenceUpdateManyWithoutWorkOrderNestedInput
    review?: ReviewUpdateOneWithoutWorkOrderNestedInput
  }

  export type WorkOrderUncheckedUpdateWithoutReceiptInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    requestId?: StringFieldUpdateOperationsInput | string
    quoteId?: StringFieldUpdateOperationsInput | string
    workshopId?: StringFieldUpdateOperationsInput | string
    diagnosis?: StringFieldUpdateOperationsInput | string
    totalAgreed?: FloatFieldUpdateOperationsInput | number
    totalFinal?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumWorkOrderStatusFieldUpdateOperationsInput | $Enums.WorkOrderStatus
    userAcceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    workshopAcceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startNote?: NullableStringFieldUpdateOperationsInput | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closureChecklist?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    changeRequests?: ChangeRequestUncheckedUpdateManyWithoutWorkOrderNestedInput
    evidences?: EvidenceUncheckedUpdateManyWithoutWorkOrderNestedInput
    review?: ReviewUncheckedUpdateOneWithoutWorkOrderNestedInput
  }

  export type UserProfileCreateWithoutIncidentReportsInput = {
    id?: string
    clerkUserId: string
    role?: $Enums.UserRole
    email?: string | null
    phone?: string | null
    name?: string | null
    district?: string | null
    avatarUrl?: string | null
    notifChannel?: $Enums.NotificationChannel
    phoneVisible?: boolean
    termsAccepted?: boolean
    termsVersion?: string | null
    termsAcceptedAt?: Date | string | null
    privacyAccepted?: boolean
    privacyVersion?: string | null
    privacyAcceptedAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    motorcycles?: MotorcycleCreateNestedManyWithoutUserInput
    serviceRequests?: ServiceRequestCreateNestedManyWithoutUserInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    chatMessages?: ChatMessageCreateNestedManyWithoutSenderInput
    workshop?: WorkshopCreateNestedOneWithoutUserInput
  }

  export type UserProfileUncheckedCreateWithoutIncidentReportsInput = {
    id?: string
    clerkUserId: string
    role?: $Enums.UserRole
    email?: string | null
    phone?: string | null
    name?: string | null
    district?: string | null
    avatarUrl?: string | null
    notifChannel?: $Enums.NotificationChannel
    phoneVisible?: boolean
    termsAccepted?: boolean
    termsVersion?: string | null
    termsAcceptedAt?: Date | string | null
    privacyAccepted?: boolean
    privacyVersion?: string | null
    privacyAcceptedAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    motorcycles?: MotorcycleUncheckedCreateNestedManyWithoutUserInput
    serviceRequests?: ServiceRequestUncheckedCreateNestedManyWithoutUserInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    chatMessages?: ChatMessageUncheckedCreateNestedManyWithoutSenderInput
    workshop?: WorkshopUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserProfileCreateOrConnectWithoutIncidentReportsInput = {
    where: UserProfileWhereUniqueInput
    create: XOR<UserProfileCreateWithoutIncidentReportsInput, UserProfileUncheckedCreateWithoutIncidentReportsInput>
  }

  export type WorkshopCreateWithoutIncidentReportsInput = {
    id?: string
    name: string
    address: string
    district: string
    phone: string
    ruc?: string | null
    description?: string | null
    photoUrl?: string | null
    status?: $Enums.WorkshopStatus
    transparencyAccepted?: boolean
    guaranteePolicy?: string | null
    latitude?: number | null
    longitude?: number | null
    rating?: number
    totalServices?: number
    evidenceRate?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserProfileCreateNestedOneWithoutWorkshopInput
    categories?: WorkshopCategoryCreateNestedManyWithoutWorkshopInput
    quotes?: QuoteCreateNestedManyWithoutWorkshopInput
    workOrders?: WorkOrderCreateNestedManyWithoutWorkshopInput
    reviews?: ReviewCreateNestedManyWithoutWorkshopInput
    verifications?: WorkshopVerificationCreateNestedManyWithoutWorkshopInput
  }

  export type WorkshopUncheckedCreateWithoutIncidentReportsInput = {
    id?: string
    userId: string
    name: string
    address: string
    district: string
    phone: string
    ruc?: string | null
    description?: string | null
    photoUrl?: string | null
    status?: $Enums.WorkshopStatus
    transparencyAccepted?: boolean
    guaranteePolicy?: string | null
    latitude?: number | null
    longitude?: number | null
    rating?: number
    totalServices?: number
    evidenceRate?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    categories?: WorkshopCategoryUncheckedCreateNestedManyWithoutWorkshopInput
    quotes?: QuoteUncheckedCreateNestedManyWithoutWorkshopInput
    workOrders?: WorkOrderUncheckedCreateNestedManyWithoutWorkshopInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutWorkshopInput
    verifications?: WorkshopVerificationUncheckedCreateNestedManyWithoutWorkshopInput
  }

  export type WorkshopCreateOrConnectWithoutIncidentReportsInput = {
    where: WorkshopWhereUniqueInput
    create: XOR<WorkshopCreateWithoutIncidentReportsInput, WorkshopUncheckedCreateWithoutIncidentReportsInput>
  }

  export type UserProfileUpsertWithoutIncidentReportsInput = {
    update: XOR<UserProfileUpdateWithoutIncidentReportsInput, UserProfileUncheckedUpdateWithoutIncidentReportsInput>
    create: XOR<UserProfileCreateWithoutIncidentReportsInput, UserProfileUncheckedCreateWithoutIncidentReportsInput>
    where?: UserProfileWhereInput
  }

  export type UserProfileUpdateToOneWithWhereWithoutIncidentReportsInput = {
    where?: UserProfileWhereInput
    data: XOR<UserProfileUpdateWithoutIncidentReportsInput, UserProfileUncheckedUpdateWithoutIncidentReportsInput>
  }

  export type UserProfileUpdateWithoutIncidentReportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    clerkUserId?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    notifChannel?: EnumNotificationChannelFieldUpdateOperationsInput | $Enums.NotificationChannel
    phoneVisible?: BoolFieldUpdateOperationsInput | boolean
    termsAccepted?: BoolFieldUpdateOperationsInput | boolean
    termsVersion?: NullableStringFieldUpdateOperationsInput | string | null
    termsAcceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    privacyAccepted?: BoolFieldUpdateOperationsInput | boolean
    privacyVersion?: NullableStringFieldUpdateOperationsInput | string | null
    privacyAcceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    motorcycles?: MotorcycleUpdateManyWithoutUserNestedInput
    serviceRequests?: ServiceRequestUpdateManyWithoutUserNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    chatMessages?: ChatMessageUpdateManyWithoutSenderNestedInput
    workshop?: WorkshopUpdateOneWithoutUserNestedInput
  }

  export type UserProfileUncheckedUpdateWithoutIncidentReportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    clerkUserId?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    notifChannel?: EnumNotificationChannelFieldUpdateOperationsInput | $Enums.NotificationChannel
    phoneVisible?: BoolFieldUpdateOperationsInput | boolean
    termsAccepted?: BoolFieldUpdateOperationsInput | boolean
    termsVersion?: NullableStringFieldUpdateOperationsInput | string | null
    termsAcceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    privacyAccepted?: BoolFieldUpdateOperationsInput | boolean
    privacyVersion?: NullableStringFieldUpdateOperationsInput | string | null
    privacyAcceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    motorcycles?: MotorcycleUncheckedUpdateManyWithoutUserNestedInput
    serviceRequests?: ServiceRequestUncheckedUpdateManyWithoutUserNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    chatMessages?: ChatMessageUncheckedUpdateManyWithoutSenderNestedInput
    workshop?: WorkshopUncheckedUpdateOneWithoutUserNestedInput
  }

  export type WorkshopUpsertWithoutIncidentReportsInput = {
    update: XOR<WorkshopUpdateWithoutIncidentReportsInput, WorkshopUncheckedUpdateWithoutIncidentReportsInput>
    create: XOR<WorkshopCreateWithoutIncidentReportsInput, WorkshopUncheckedCreateWithoutIncidentReportsInput>
    where?: WorkshopWhereInput
  }

  export type WorkshopUpdateToOneWithWhereWithoutIncidentReportsInput = {
    where?: WorkshopWhereInput
    data: XOR<WorkshopUpdateWithoutIncidentReportsInput, WorkshopUncheckedUpdateWithoutIncidentReportsInput>
  }

  export type WorkshopUpdateWithoutIncidentReportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    district?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    ruc?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumWorkshopStatusFieldUpdateOperationsInput | $Enums.WorkshopStatus
    transparencyAccepted?: BoolFieldUpdateOperationsInput | boolean
    guaranteePolicy?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    rating?: FloatFieldUpdateOperationsInput | number
    totalServices?: IntFieldUpdateOperationsInput | number
    evidenceRate?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserProfileUpdateOneRequiredWithoutWorkshopNestedInput
    categories?: WorkshopCategoryUpdateManyWithoutWorkshopNestedInput
    quotes?: QuoteUpdateManyWithoutWorkshopNestedInput
    workOrders?: WorkOrderUpdateManyWithoutWorkshopNestedInput
    reviews?: ReviewUpdateManyWithoutWorkshopNestedInput
    verifications?: WorkshopVerificationUpdateManyWithoutWorkshopNestedInput
  }

  export type WorkshopUncheckedUpdateWithoutIncidentReportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    district?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    ruc?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumWorkshopStatusFieldUpdateOperationsInput | $Enums.WorkshopStatus
    transparencyAccepted?: BoolFieldUpdateOperationsInput | boolean
    guaranteePolicy?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    rating?: FloatFieldUpdateOperationsInput | number
    totalServices?: IntFieldUpdateOperationsInput | number
    evidenceRate?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    categories?: WorkshopCategoryUncheckedUpdateManyWithoutWorkshopNestedInput
    quotes?: QuoteUncheckedUpdateManyWithoutWorkshopNestedInput
    workOrders?: WorkOrderUncheckedUpdateManyWithoutWorkshopNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutWorkshopNestedInput
    verifications?: WorkshopVerificationUncheckedUpdateManyWithoutWorkshopNestedInput
  }

  export type ServiceRequestCreateWithoutChatMessagesInput = {
    id?: string
    description: string
    district: string
    urgency?: $Enums.UrgencyLevel
    status?: $Enums.ServiceRequestStatus
    completionScore?: number
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserProfileCreateNestedOneWithoutServiceRequestsInput
    motorcycle: MotorcycleCreateNestedOneWithoutServiceRequestsInput
    category: CategoryCreateNestedOneWithoutServiceRequestsInput
    media?: RequestMediaCreateNestedManyWithoutRequestInput
    guideAnswers?: GuideAnswerCreateNestedManyWithoutRequestInput
    quotes?: QuoteCreateNestedManyWithoutRequestInput
    statusHistory?: RequestStatusHistoryCreateNestedManyWithoutRequestInput
    notifications?: NotificationCreateNestedManyWithoutRequestInput
    workOrder?: WorkOrderCreateNestedOneWithoutRequestInput
    aiSuggestions?: AiSuggestionCreateNestedManyWithoutRequestInput
  }

  export type ServiceRequestUncheckedCreateWithoutChatMessagesInput = {
    id?: string
    userId: string
    motorcycleId: string
    categoryId: string
    description: string
    district: string
    urgency?: $Enums.UrgencyLevel
    status?: $Enums.ServiceRequestStatus
    completionScore?: number
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    media?: RequestMediaUncheckedCreateNestedManyWithoutRequestInput
    guideAnswers?: GuideAnswerUncheckedCreateNestedManyWithoutRequestInput
    quotes?: QuoteUncheckedCreateNestedManyWithoutRequestInput
    statusHistory?: RequestStatusHistoryUncheckedCreateNestedManyWithoutRequestInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutRequestInput
    workOrder?: WorkOrderUncheckedCreateNestedOneWithoutRequestInput
    aiSuggestions?: AiSuggestionUncheckedCreateNestedManyWithoutRequestInput
  }

  export type ServiceRequestCreateOrConnectWithoutChatMessagesInput = {
    where: ServiceRequestWhereUniqueInput
    create: XOR<ServiceRequestCreateWithoutChatMessagesInput, ServiceRequestUncheckedCreateWithoutChatMessagesInput>
  }

  export type UserProfileCreateWithoutChatMessagesInput = {
    id?: string
    clerkUserId: string
    role?: $Enums.UserRole
    email?: string | null
    phone?: string | null
    name?: string | null
    district?: string | null
    avatarUrl?: string | null
    notifChannel?: $Enums.NotificationChannel
    phoneVisible?: boolean
    termsAccepted?: boolean
    termsVersion?: string | null
    termsAcceptedAt?: Date | string | null
    privacyAccepted?: boolean
    privacyVersion?: string | null
    privacyAcceptedAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    motorcycles?: MotorcycleCreateNestedManyWithoutUserInput
    serviceRequests?: ServiceRequestCreateNestedManyWithoutUserInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
    incidentReports?: IncidentReportCreateNestedManyWithoutReporterInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    workshop?: WorkshopCreateNestedOneWithoutUserInput
  }

  export type UserProfileUncheckedCreateWithoutChatMessagesInput = {
    id?: string
    clerkUserId: string
    role?: $Enums.UserRole
    email?: string | null
    phone?: string | null
    name?: string | null
    district?: string | null
    avatarUrl?: string | null
    notifChannel?: $Enums.NotificationChannel
    phoneVisible?: boolean
    termsAccepted?: boolean
    termsVersion?: string | null
    termsAcceptedAt?: Date | string | null
    privacyAccepted?: boolean
    privacyVersion?: string | null
    privacyAcceptedAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    motorcycles?: MotorcycleUncheckedCreateNestedManyWithoutUserInput
    serviceRequests?: ServiceRequestUncheckedCreateNestedManyWithoutUserInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
    incidentReports?: IncidentReportUncheckedCreateNestedManyWithoutReporterInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    workshop?: WorkshopUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserProfileCreateOrConnectWithoutChatMessagesInput = {
    where: UserProfileWhereUniqueInput
    create: XOR<UserProfileCreateWithoutChatMessagesInput, UserProfileUncheckedCreateWithoutChatMessagesInput>
  }

  export type ServiceRequestUpsertWithoutChatMessagesInput = {
    update: XOR<ServiceRequestUpdateWithoutChatMessagesInput, ServiceRequestUncheckedUpdateWithoutChatMessagesInput>
    create: XOR<ServiceRequestCreateWithoutChatMessagesInput, ServiceRequestUncheckedCreateWithoutChatMessagesInput>
    where?: ServiceRequestWhereInput
  }

  export type ServiceRequestUpdateToOneWithWhereWithoutChatMessagesInput = {
    where?: ServiceRequestWhereInput
    data: XOR<ServiceRequestUpdateWithoutChatMessagesInput, ServiceRequestUncheckedUpdateWithoutChatMessagesInput>
  }

  export type ServiceRequestUpdateWithoutChatMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    district?: StringFieldUpdateOperationsInput | string
    urgency?: EnumUrgencyLevelFieldUpdateOperationsInput | $Enums.UrgencyLevel
    status?: EnumServiceRequestStatusFieldUpdateOperationsInput | $Enums.ServiceRequestStatus
    completionScore?: IntFieldUpdateOperationsInput | number
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserProfileUpdateOneRequiredWithoutServiceRequestsNestedInput
    motorcycle?: MotorcycleUpdateOneRequiredWithoutServiceRequestsNestedInput
    category?: CategoryUpdateOneRequiredWithoutServiceRequestsNestedInput
    media?: RequestMediaUpdateManyWithoutRequestNestedInput
    guideAnswers?: GuideAnswerUpdateManyWithoutRequestNestedInput
    quotes?: QuoteUpdateManyWithoutRequestNestedInput
    statusHistory?: RequestStatusHistoryUpdateManyWithoutRequestNestedInput
    notifications?: NotificationUpdateManyWithoutRequestNestedInput
    workOrder?: WorkOrderUpdateOneWithoutRequestNestedInput
    aiSuggestions?: AiSuggestionUpdateManyWithoutRequestNestedInput
  }

  export type ServiceRequestUncheckedUpdateWithoutChatMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    motorcycleId?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    district?: StringFieldUpdateOperationsInput | string
    urgency?: EnumUrgencyLevelFieldUpdateOperationsInput | $Enums.UrgencyLevel
    status?: EnumServiceRequestStatusFieldUpdateOperationsInput | $Enums.ServiceRequestStatus
    completionScore?: IntFieldUpdateOperationsInput | number
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    media?: RequestMediaUncheckedUpdateManyWithoutRequestNestedInput
    guideAnswers?: GuideAnswerUncheckedUpdateManyWithoutRequestNestedInput
    quotes?: QuoteUncheckedUpdateManyWithoutRequestNestedInput
    statusHistory?: RequestStatusHistoryUncheckedUpdateManyWithoutRequestNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutRequestNestedInput
    workOrder?: WorkOrderUncheckedUpdateOneWithoutRequestNestedInput
    aiSuggestions?: AiSuggestionUncheckedUpdateManyWithoutRequestNestedInput
  }

  export type UserProfileUpsertWithoutChatMessagesInput = {
    update: XOR<UserProfileUpdateWithoutChatMessagesInput, UserProfileUncheckedUpdateWithoutChatMessagesInput>
    create: XOR<UserProfileCreateWithoutChatMessagesInput, UserProfileUncheckedCreateWithoutChatMessagesInput>
    where?: UserProfileWhereInput
  }

  export type UserProfileUpdateToOneWithWhereWithoutChatMessagesInput = {
    where?: UserProfileWhereInput
    data: XOR<UserProfileUpdateWithoutChatMessagesInput, UserProfileUncheckedUpdateWithoutChatMessagesInput>
  }

  export type UserProfileUpdateWithoutChatMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    clerkUserId?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    notifChannel?: EnumNotificationChannelFieldUpdateOperationsInput | $Enums.NotificationChannel
    phoneVisible?: BoolFieldUpdateOperationsInput | boolean
    termsAccepted?: BoolFieldUpdateOperationsInput | boolean
    termsVersion?: NullableStringFieldUpdateOperationsInput | string | null
    termsAcceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    privacyAccepted?: BoolFieldUpdateOperationsInput | boolean
    privacyVersion?: NullableStringFieldUpdateOperationsInput | string | null
    privacyAcceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    motorcycles?: MotorcycleUpdateManyWithoutUserNestedInput
    serviceRequests?: ServiceRequestUpdateManyWithoutUserNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
    incidentReports?: IncidentReportUpdateManyWithoutReporterNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    workshop?: WorkshopUpdateOneWithoutUserNestedInput
  }

  export type UserProfileUncheckedUpdateWithoutChatMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    clerkUserId?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    notifChannel?: EnumNotificationChannelFieldUpdateOperationsInput | $Enums.NotificationChannel
    phoneVisible?: BoolFieldUpdateOperationsInput | boolean
    termsAccepted?: BoolFieldUpdateOperationsInput | boolean
    termsVersion?: NullableStringFieldUpdateOperationsInput | string | null
    termsAcceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    privacyAccepted?: BoolFieldUpdateOperationsInput | boolean
    privacyVersion?: NullableStringFieldUpdateOperationsInput | string | null
    privacyAcceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    motorcycles?: MotorcycleUncheckedUpdateManyWithoutUserNestedInput
    serviceRequests?: ServiceRequestUncheckedUpdateManyWithoutUserNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
    incidentReports?: IncidentReportUncheckedUpdateManyWithoutReporterNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    workshop?: WorkshopUncheckedUpdateOneWithoutUserNestedInput
  }

  export type UserProfileCreateWithoutNotificationsInput = {
    id?: string
    clerkUserId: string
    role?: $Enums.UserRole
    email?: string | null
    phone?: string | null
    name?: string | null
    district?: string | null
    avatarUrl?: string | null
    notifChannel?: $Enums.NotificationChannel
    phoneVisible?: boolean
    termsAccepted?: boolean
    termsVersion?: string | null
    termsAcceptedAt?: Date | string | null
    privacyAccepted?: boolean
    privacyVersion?: string | null
    privacyAcceptedAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    motorcycles?: MotorcycleCreateNestedManyWithoutUserInput
    serviceRequests?: ServiceRequestCreateNestedManyWithoutUserInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
    incidentReports?: IncidentReportCreateNestedManyWithoutReporterInput
    chatMessages?: ChatMessageCreateNestedManyWithoutSenderInput
    workshop?: WorkshopCreateNestedOneWithoutUserInput
  }

  export type UserProfileUncheckedCreateWithoutNotificationsInput = {
    id?: string
    clerkUserId: string
    role?: $Enums.UserRole
    email?: string | null
    phone?: string | null
    name?: string | null
    district?: string | null
    avatarUrl?: string | null
    notifChannel?: $Enums.NotificationChannel
    phoneVisible?: boolean
    termsAccepted?: boolean
    termsVersion?: string | null
    termsAcceptedAt?: Date | string | null
    privacyAccepted?: boolean
    privacyVersion?: string | null
    privacyAcceptedAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    motorcycles?: MotorcycleUncheckedCreateNestedManyWithoutUserInput
    serviceRequests?: ServiceRequestUncheckedCreateNestedManyWithoutUserInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
    incidentReports?: IncidentReportUncheckedCreateNestedManyWithoutReporterInput
    chatMessages?: ChatMessageUncheckedCreateNestedManyWithoutSenderInput
    workshop?: WorkshopUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserProfileCreateOrConnectWithoutNotificationsInput = {
    where: UserProfileWhereUniqueInput
    create: XOR<UserProfileCreateWithoutNotificationsInput, UserProfileUncheckedCreateWithoutNotificationsInput>
  }

  export type ServiceRequestCreateWithoutNotificationsInput = {
    id?: string
    description: string
    district: string
    urgency?: $Enums.UrgencyLevel
    status?: $Enums.ServiceRequestStatus
    completionScore?: number
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserProfileCreateNestedOneWithoutServiceRequestsInput
    motorcycle: MotorcycleCreateNestedOneWithoutServiceRequestsInput
    category: CategoryCreateNestedOneWithoutServiceRequestsInput
    media?: RequestMediaCreateNestedManyWithoutRequestInput
    guideAnswers?: GuideAnswerCreateNestedManyWithoutRequestInput
    quotes?: QuoteCreateNestedManyWithoutRequestInput
    statusHistory?: RequestStatusHistoryCreateNestedManyWithoutRequestInput
    workOrder?: WorkOrderCreateNestedOneWithoutRequestInput
    chatMessages?: ChatMessageCreateNestedManyWithoutRequestInput
    aiSuggestions?: AiSuggestionCreateNestedManyWithoutRequestInput
  }

  export type ServiceRequestUncheckedCreateWithoutNotificationsInput = {
    id?: string
    userId: string
    motorcycleId: string
    categoryId: string
    description: string
    district: string
    urgency?: $Enums.UrgencyLevel
    status?: $Enums.ServiceRequestStatus
    completionScore?: number
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    media?: RequestMediaUncheckedCreateNestedManyWithoutRequestInput
    guideAnswers?: GuideAnswerUncheckedCreateNestedManyWithoutRequestInput
    quotes?: QuoteUncheckedCreateNestedManyWithoutRequestInput
    statusHistory?: RequestStatusHistoryUncheckedCreateNestedManyWithoutRequestInput
    workOrder?: WorkOrderUncheckedCreateNestedOneWithoutRequestInput
    chatMessages?: ChatMessageUncheckedCreateNestedManyWithoutRequestInput
    aiSuggestions?: AiSuggestionUncheckedCreateNestedManyWithoutRequestInput
  }

  export type ServiceRequestCreateOrConnectWithoutNotificationsInput = {
    where: ServiceRequestWhereUniqueInput
    create: XOR<ServiceRequestCreateWithoutNotificationsInput, ServiceRequestUncheckedCreateWithoutNotificationsInput>
  }

  export type UserProfileUpsertWithoutNotificationsInput = {
    update: XOR<UserProfileUpdateWithoutNotificationsInput, UserProfileUncheckedUpdateWithoutNotificationsInput>
    create: XOR<UserProfileCreateWithoutNotificationsInput, UserProfileUncheckedCreateWithoutNotificationsInput>
    where?: UserProfileWhereInput
  }

  export type UserProfileUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: UserProfileWhereInput
    data: XOR<UserProfileUpdateWithoutNotificationsInput, UserProfileUncheckedUpdateWithoutNotificationsInput>
  }

  export type UserProfileUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    clerkUserId?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    notifChannel?: EnumNotificationChannelFieldUpdateOperationsInput | $Enums.NotificationChannel
    phoneVisible?: BoolFieldUpdateOperationsInput | boolean
    termsAccepted?: BoolFieldUpdateOperationsInput | boolean
    termsVersion?: NullableStringFieldUpdateOperationsInput | string | null
    termsAcceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    privacyAccepted?: BoolFieldUpdateOperationsInput | boolean
    privacyVersion?: NullableStringFieldUpdateOperationsInput | string | null
    privacyAcceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    motorcycles?: MotorcycleUpdateManyWithoutUserNestedInput
    serviceRequests?: ServiceRequestUpdateManyWithoutUserNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
    incidentReports?: IncidentReportUpdateManyWithoutReporterNestedInput
    chatMessages?: ChatMessageUpdateManyWithoutSenderNestedInput
    workshop?: WorkshopUpdateOneWithoutUserNestedInput
  }

  export type UserProfileUncheckedUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    clerkUserId?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    notifChannel?: EnumNotificationChannelFieldUpdateOperationsInput | $Enums.NotificationChannel
    phoneVisible?: BoolFieldUpdateOperationsInput | boolean
    termsAccepted?: BoolFieldUpdateOperationsInput | boolean
    termsVersion?: NullableStringFieldUpdateOperationsInput | string | null
    termsAcceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    privacyAccepted?: BoolFieldUpdateOperationsInput | boolean
    privacyVersion?: NullableStringFieldUpdateOperationsInput | string | null
    privacyAcceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    motorcycles?: MotorcycleUncheckedUpdateManyWithoutUserNestedInput
    serviceRequests?: ServiceRequestUncheckedUpdateManyWithoutUserNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
    incidentReports?: IncidentReportUncheckedUpdateManyWithoutReporterNestedInput
    chatMessages?: ChatMessageUncheckedUpdateManyWithoutSenderNestedInput
    workshop?: WorkshopUncheckedUpdateOneWithoutUserNestedInput
  }

  export type ServiceRequestUpsertWithoutNotificationsInput = {
    update: XOR<ServiceRequestUpdateWithoutNotificationsInput, ServiceRequestUncheckedUpdateWithoutNotificationsInput>
    create: XOR<ServiceRequestCreateWithoutNotificationsInput, ServiceRequestUncheckedCreateWithoutNotificationsInput>
    where?: ServiceRequestWhereInput
  }

  export type ServiceRequestUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: ServiceRequestWhereInput
    data: XOR<ServiceRequestUpdateWithoutNotificationsInput, ServiceRequestUncheckedUpdateWithoutNotificationsInput>
  }

  export type ServiceRequestUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    district?: StringFieldUpdateOperationsInput | string
    urgency?: EnumUrgencyLevelFieldUpdateOperationsInput | $Enums.UrgencyLevel
    status?: EnumServiceRequestStatusFieldUpdateOperationsInput | $Enums.ServiceRequestStatus
    completionScore?: IntFieldUpdateOperationsInput | number
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserProfileUpdateOneRequiredWithoutServiceRequestsNestedInput
    motorcycle?: MotorcycleUpdateOneRequiredWithoutServiceRequestsNestedInput
    category?: CategoryUpdateOneRequiredWithoutServiceRequestsNestedInput
    media?: RequestMediaUpdateManyWithoutRequestNestedInput
    guideAnswers?: GuideAnswerUpdateManyWithoutRequestNestedInput
    quotes?: QuoteUpdateManyWithoutRequestNestedInput
    statusHistory?: RequestStatusHistoryUpdateManyWithoutRequestNestedInput
    workOrder?: WorkOrderUpdateOneWithoutRequestNestedInput
    chatMessages?: ChatMessageUpdateManyWithoutRequestNestedInput
    aiSuggestions?: AiSuggestionUpdateManyWithoutRequestNestedInput
  }

  export type ServiceRequestUncheckedUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    motorcycleId?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    district?: StringFieldUpdateOperationsInput | string
    urgency?: EnumUrgencyLevelFieldUpdateOperationsInput | $Enums.UrgencyLevel
    status?: EnumServiceRequestStatusFieldUpdateOperationsInput | $Enums.ServiceRequestStatus
    completionScore?: IntFieldUpdateOperationsInput | number
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    media?: RequestMediaUncheckedUpdateManyWithoutRequestNestedInput
    guideAnswers?: GuideAnswerUncheckedUpdateManyWithoutRequestNestedInput
    quotes?: QuoteUncheckedUpdateManyWithoutRequestNestedInput
    statusHistory?: RequestStatusHistoryUncheckedUpdateManyWithoutRequestNestedInput
    workOrder?: WorkOrderUncheckedUpdateOneWithoutRequestNestedInput
    chatMessages?: ChatMessageUncheckedUpdateManyWithoutRequestNestedInput
    aiSuggestions?: AiSuggestionUncheckedUpdateManyWithoutRequestNestedInput
  }

  export type ServiceRequestCreateWithoutAiSuggestionsInput = {
    id?: string
    description: string
    district: string
    urgency?: $Enums.UrgencyLevel
    status?: $Enums.ServiceRequestStatus
    completionScore?: number
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserProfileCreateNestedOneWithoutServiceRequestsInput
    motorcycle: MotorcycleCreateNestedOneWithoutServiceRequestsInput
    category: CategoryCreateNestedOneWithoutServiceRequestsInput
    media?: RequestMediaCreateNestedManyWithoutRequestInput
    guideAnswers?: GuideAnswerCreateNestedManyWithoutRequestInput
    quotes?: QuoteCreateNestedManyWithoutRequestInput
    statusHistory?: RequestStatusHistoryCreateNestedManyWithoutRequestInput
    notifications?: NotificationCreateNestedManyWithoutRequestInput
    workOrder?: WorkOrderCreateNestedOneWithoutRequestInput
    chatMessages?: ChatMessageCreateNestedManyWithoutRequestInput
  }

  export type ServiceRequestUncheckedCreateWithoutAiSuggestionsInput = {
    id?: string
    userId: string
    motorcycleId: string
    categoryId: string
    description: string
    district: string
    urgency?: $Enums.UrgencyLevel
    status?: $Enums.ServiceRequestStatus
    completionScore?: number
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    media?: RequestMediaUncheckedCreateNestedManyWithoutRequestInput
    guideAnswers?: GuideAnswerUncheckedCreateNestedManyWithoutRequestInput
    quotes?: QuoteUncheckedCreateNestedManyWithoutRequestInput
    statusHistory?: RequestStatusHistoryUncheckedCreateNestedManyWithoutRequestInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutRequestInput
    workOrder?: WorkOrderUncheckedCreateNestedOneWithoutRequestInput
    chatMessages?: ChatMessageUncheckedCreateNestedManyWithoutRequestInput
  }

  export type ServiceRequestCreateOrConnectWithoutAiSuggestionsInput = {
    where: ServiceRequestWhereUniqueInput
    create: XOR<ServiceRequestCreateWithoutAiSuggestionsInput, ServiceRequestUncheckedCreateWithoutAiSuggestionsInput>
  }

  export type ServiceRequestUpsertWithoutAiSuggestionsInput = {
    update: XOR<ServiceRequestUpdateWithoutAiSuggestionsInput, ServiceRequestUncheckedUpdateWithoutAiSuggestionsInput>
    create: XOR<ServiceRequestCreateWithoutAiSuggestionsInput, ServiceRequestUncheckedCreateWithoutAiSuggestionsInput>
    where?: ServiceRequestWhereInput
  }

  export type ServiceRequestUpdateToOneWithWhereWithoutAiSuggestionsInput = {
    where?: ServiceRequestWhereInput
    data: XOR<ServiceRequestUpdateWithoutAiSuggestionsInput, ServiceRequestUncheckedUpdateWithoutAiSuggestionsInput>
  }

  export type ServiceRequestUpdateWithoutAiSuggestionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    district?: StringFieldUpdateOperationsInput | string
    urgency?: EnumUrgencyLevelFieldUpdateOperationsInput | $Enums.UrgencyLevel
    status?: EnumServiceRequestStatusFieldUpdateOperationsInput | $Enums.ServiceRequestStatus
    completionScore?: IntFieldUpdateOperationsInput | number
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserProfileUpdateOneRequiredWithoutServiceRequestsNestedInput
    motorcycle?: MotorcycleUpdateOneRequiredWithoutServiceRequestsNestedInput
    category?: CategoryUpdateOneRequiredWithoutServiceRequestsNestedInput
    media?: RequestMediaUpdateManyWithoutRequestNestedInput
    guideAnswers?: GuideAnswerUpdateManyWithoutRequestNestedInput
    quotes?: QuoteUpdateManyWithoutRequestNestedInput
    statusHistory?: RequestStatusHistoryUpdateManyWithoutRequestNestedInput
    notifications?: NotificationUpdateManyWithoutRequestNestedInput
    workOrder?: WorkOrderUpdateOneWithoutRequestNestedInput
    chatMessages?: ChatMessageUpdateManyWithoutRequestNestedInput
  }

  export type ServiceRequestUncheckedUpdateWithoutAiSuggestionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    motorcycleId?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    district?: StringFieldUpdateOperationsInput | string
    urgency?: EnumUrgencyLevelFieldUpdateOperationsInput | $Enums.UrgencyLevel
    status?: EnumServiceRequestStatusFieldUpdateOperationsInput | $Enums.ServiceRequestStatus
    completionScore?: IntFieldUpdateOperationsInput | number
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    media?: RequestMediaUncheckedUpdateManyWithoutRequestNestedInput
    guideAnswers?: GuideAnswerUncheckedUpdateManyWithoutRequestNestedInput
    quotes?: QuoteUncheckedUpdateManyWithoutRequestNestedInput
    statusHistory?: RequestStatusHistoryUncheckedUpdateManyWithoutRequestNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutRequestNestedInput
    workOrder?: WorkOrderUncheckedUpdateOneWithoutRequestNestedInput
    chatMessages?: ChatMessageUncheckedUpdateManyWithoutRequestNestedInput
  }

  export type QuoteCreateWithoutAiAnalysisInput = {
    id?: string
    version?: number
    diagnosis: string
    laborCost: number
    totalParts?: number
    totalCost: number
    estimatedTime: string
    validUntil: Date | string
    notes?: string | null
    status?: $Enums.QuoteStatus
    rejectionReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    request: ServiceRequestCreateNestedOneWithoutQuotesInput
    workshop: WorkshopCreateNestedOneWithoutQuotesInput
    parts?: QuotePartItemCreateNestedManyWithoutQuoteInput
    workOrder?: WorkOrderCreateNestedOneWithoutQuoteInput
  }

  export type QuoteUncheckedCreateWithoutAiAnalysisInput = {
    id?: string
    requestId: string
    workshopId: string
    version?: number
    diagnosis: string
    laborCost: number
    totalParts?: number
    totalCost: number
    estimatedTime: string
    validUntil: Date | string
    notes?: string | null
    status?: $Enums.QuoteStatus
    rejectionReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    parts?: QuotePartItemUncheckedCreateNestedManyWithoutQuoteInput
    workOrder?: WorkOrderUncheckedCreateNestedOneWithoutQuoteInput
  }

  export type QuoteCreateOrConnectWithoutAiAnalysisInput = {
    where: QuoteWhereUniqueInput
    create: XOR<QuoteCreateWithoutAiAnalysisInput, QuoteUncheckedCreateWithoutAiAnalysisInput>
  }

  export type QuoteUpsertWithoutAiAnalysisInput = {
    update: XOR<QuoteUpdateWithoutAiAnalysisInput, QuoteUncheckedUpdateWithoutAiAnalysisInput>
    create: XOR<QuoteCreateWithoutAiAnalysisInput, QuoteUncheckedCreateWithoutAiAnalysisInput>
    where?: QuoteWhereInput
  }

  export type QuoteUpdateToOneWithWhereWithoutAiAnalysisInput = {
    where?: QuoteWhereInput
    data: XOR<QuoteUpdateWithoutAiAnalysisInput, QuoteUncheckedUpdateWithoutAiAnalysisInput>
  }

  export type QuoteUpdateWithoutAiAnalysisInput = {
    id?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    diagnosis?: StringFieldUpdateOperationsInput | string
    laborCost?: FloatFieldUpdateOperationsInput | number
    totalParts?: FloatFieldUpdateOperationsInput | number
    totalCost?: FloatFieldUpdateOperationsInput | number
    estimatedTime?: StringFieldUpdateOperationsInput | string
    validUntil?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumQuoteStatusFieldUpdateOperationsInput | $Enums.QuoteStatus
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    request?: ServiceRequestUpdateOneRequiredWithoutQuotesNestedInput
    workshop?: WorkshopUpdateOneRequiredWithoutQuotesNestedInput
    parts?: QuotePartItemUpdateManyWithoutQuoteNestedInput
    workOrder?: WorkOrderUpdateOneWithoutQuoteNestedInput
  }

  export type QuoteUncheckedUpdateWithoutAiAnalysisInput = {
    id?: StringFieldUpdateOperationsInput | string
    requestId?: StringFieldUpdateOperationsInput | string
    workshopId?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    diagnosis?: StringFieldUpdateOperationsInput | string
    laborCost?: FloatFieldUpdateOperationsInput | number
    totalParts?: FloatFieldUpdateOperationsInput | number
    totalCost?: FloatFieldUpdateOperationsInput | number
    estimatedTime?: StringFieldUpdateOperationsInput | string
    validUntil?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumQuoteStatusFieldUpdateOperationsInput | $Enums.QuoteStatus
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parts?: QuotePartItemUncheckedUpdateManyWithoutQuoteNestedInput
    workOrder?: WorkOrderUncheckedUpdateOneWithoutQuoteNestedInput
  }

  export type MotorcycleCreateManyUserInput = {
    id?: string
    brand: string
    model: string
    year: number
    displacement?: number | null
    use?: $Enums.MotorcycleUse | null
    kmApprox?: number | null
    placa?: string | null
    alias?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ServiceRequestCreateManyUserInput = {
    id?: string
    motorcycleId: string
    categoryId: string
    description: string
    district: string
    urgency?: $Enums.UrgencyLevel
    status?: $Enums.ServiceRequestStatus
    completionScore?: number
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReviewCreateManyUserInput = {
    id?: string
    workOrderId: string
    workshopId: string
    rating: number
    comment?: string | null
    editableUntil: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IncidentReportCreateManyReporterInput = {
    id?: string
    workshopId: string
    type: $Enums.IncidentType
    description: string
    evidenceUrl?: string | null
    status?: $Enums.IncidentStatus
    resolution?: string | null
    resolvedAt?: Date | string | null
    resolvedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationCreateManyUserInput = {
    id?: string
    requestId?: string | null
    title: string
    body: string
    channel?: $Enums.NotificationChannel
    isRead?: boolean
    link?: string | null
    createdAt?: Date | string
  }

  export type ChatMessageCreateManySenderInput = {
    id?: string
    requestId: string
    content: string
    imageUrl?: string | null
    isRead?: boolean
    createdAt?: Date | string
  }

  export type MotorcycleUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    brand?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    displacement?: NullableIntFieldUpdateOperationsInput | number | null
    use?: NullableEnumMotorcycleUseFieldUpdateOperationsInput | $Enums.MotorcycleUse | null
    kmApprox?: NullableIntFieldUpdateOperationsInput | number | null
    placa?: NullableStringFieldUpdateOperationsInput | string | null
    alias?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    serviceRequests?: ServiceRequestUpdateManyWithoutMotorcycleNestedInput
  }

  export type MotorcycleUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    brand?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    displacement?: NullableIntFieldUpdateOperationsInput | number | null
    use?: NullableEnumMotorcycleUseFieldUpdateOperationsInput | $Enums.MotorcycleUse | null
    kmApprox?: NullableIntFieldUpdateOperationsInput | number | null
    placa?: NullableStringFieldUpdateOperationsInput | string | null
    alias?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    serviceRequests?: ServiceRequestUncheckedUpdateManyWithoutMotorcycleNestedInput
  }

  export type MotorcycleUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    brand?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    displacement?: NullableIntFieldUpdateOperationsInput | number | null
    use?: NullableEnumMotorcycleUseFieldUpdateOperationsInput | $Enums.MotorcycleUse | null
    kmApprox?: NullableIntFieldUpdateOperationsInput | number | null
    placa?: NullableStringFieldUpdateOperationsInput | string | null
    alias?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceRequestUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    district?: StringFieldUpdateOperationsInput | string
    urgency?: EnumUrgencyLevelFieldUpdateOperationsInput | $Enums.UrgencyLevel
    status?: EnumServiceRequestStatusFieldUpdateOperationsInput | $Enums.ServiceRequestStatus
    completionScore?: IntFieldUpdateOperationsInput | number
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    motorcycle?: MotorcycleUpdateOneRequiredWithoutServiceRequestsNestedInput
    category?: CategoryUpdateOneRequiredWithoutServiceRequestsNestedInput
    media?: RequestMediaUpdateManyWithoutRequestNestedInput
    guideAnswers?: GuideAnswerUpdateManyWithoutRequestNestedInput
    quotes?: QuoteUpdateManyWithoutRequestNestedInput
    statusHistory?: RequestStatusHistoryUpdateManyWithoutRequestNestedInput
    notifications?: NotificationUpdateManyWithoutRequestNestedInput
    workOrder?: WorkOrderUpdateOneWithoutRequestNestedInput
    chatMessages?: ChatMessageUpdateManyWithoutRequestNestedInput
    aiSuggestions?: AiSuggestionUpdateManyWithoutRequestNestedInput
  }

  export type ServiceRequestUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    motorcycleId?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    district?: StringFieldUpdateOperationsInput | string
    urgency?: EnumUrgencyLevelFieldUpdateOperationsInput | $Enums.UrgencyLevel
    status?: EnumServiceRequestStatusFieldUpdateOperationsInput | $Enums.ServiceRequestStatus
    completionScore?: IntFieldUpdateOperationsInput | number
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    media?: RequestMediaUncheckedUpdateManyWithoutRequestNestedInput
    guideAnswers?: GuideAnswerUncheckedUpdateManyWithoutRequestNestedInput
    quotes?: QuoteUncheckedUpdateManyWithoutRequestNestedInput
    statusHistory?: RequestStatusHistoryUncheckedUpdateManyWithoutRequestNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutRequestNestedInput
    workOrder?: WorkOrderUncheckedUpdateOneWithoutRequestNestedInput
    chatMessages?: ChatMessageUncheckedUpdateManyWithoutRequestNestedInput
    aiSuggestions?: AiSuggestionUncheckedUpdateManyWithoutRequestNestedInput
  }

  export type ServiceRequestUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    motorcycleId?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    district?: StringFieldUpdateOperationsInput | string
    urgency?: EnumUrgencyLevelFieldUpdateOperationsInput | $Enums.UrgencyLevel
    status?: EnumServiceRequestStatusFieldUpdateOperationsInput | $Enums.ServiceRequestStatus
    completionScore?: IntFieldUpdateOperationsInput | number
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    editableUntil?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workOrder?: WorkOrderUpdateOneRequiredWithoutReviewNestedInput
    workshop?: WorkshopUpdateOneRequiredWithoutReviewsNestedInput
  }

  export type ReviewUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    workOrderId?: StringFieldUpdateOperationsInput | string
    workshopId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    editableUntil?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    workOrderId?: StringFieldUpdateOperationsInput | string
    workshopId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    editableUntil?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IncidentReportUpdateWithoutReporterInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumIncidentTypeFieldUpdateOperationsInput | $Enums.IncidentType
    description?: StringFieldUpdateOperationsInput | string
    evidenceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumIncidentStatusFieldUpdateOperationsInput | $Enums.IncidentStatus
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workshop?: WorkshopUpdateOneRequiredWithoutIncidentReportsNestedInput
  }

  export type IncidentReportUncheckedUpdateWithoutReporterInput = {
    id?: StringFieldUpdateOperationsInput | string
    workshopId?: StringFieldUpdateOperationsInput | string
    type?: EnumIncidentTypeFieldUpdateOperationsInput | $Enums.IncidentType
    description?: StringFieldUpdateOperationsInput | string
    evidenceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumIncidentStatusFieldUpdateOperationsInput | $Enums.IncidentStatus
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IncidentReportUncheckedUpdateManyWithoutReporterInput = {
    id?: StringFieldUpdateOperationsInput | string
    workshopId?: StringFieldUpdateOperationsInput | string
    type?: EnumIncidentTypeFieldUpdateOperationsInput | $Enums.IncidentType
    description?: StringFieldUpdateOperationsInput | string
    evidenceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumIncidentStatusFieldUpdateOperationsInput | $Enums.IncidentStatus
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    channel?: EnumNotificationChannelFieldUpdateOperationsInput | $Enums.NotificationChannel
    isRead?: BoolFieldUpdateOperationsInput | boolean
    link?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    request?: ServiceRequestUpdateOneWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    requestId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    channel?: EnumNotificationChannelFieldUpdateOperationsInput | $Enums.NotificationChannel
    isRead?: BoolFieldUpdateOperationsInput | boolean
    link?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    requestId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    channel?: EnumNotificationChannelFieldUpdateOperationsInput | $Enums.NotificationChannel
    isRead?: BoolFieldUpdateOperationsInput | boolean
    link?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatMessageUpdateWithoutSenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    request?: ServiceRequestUpdateOneRequiredWithoutChatMessagesNestedInput
  }

  export type ChatMessageUncheckedUpdateWithoutSenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    requestId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatMessageUncheckedUpdateManyWithoutSenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    requestId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceRequestCreateManyMotorcycleInput = {
    id?: string
    userId: string
    categoryId: string
    description: string
    district: string
    urgency?: $Enums.UrgencyLevel
    status?: $Enums.ServiceRequestStatus
    completionScore?: number
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ServiceRequestUpdateWithoutMotorcycleInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    district?: StringFieldUpdateOperationsInput | string
    urgency?: EnumUrgencyLevelFieldUpdateOperationsInput | $Enums.UrgencyLevel
    status?: EnumServiceRequestStatusFieldUpdateOperationsInput | $Enums.ServiceRequestStatus
    completionScore?: IntFieldUpdateOperationsInput | number
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserProfileUpdateOneRequiredWithoutServiceRequestsNestedInput
    category?: CategoryUpdateOneRequiredWithoutServiceRequestsNestedInput
    media?: RequestMediaUpdateManyWithoutRequestNestedInput
    guideAnswers?: GuideAnswerUpdateManyWithoutRequestNestedInput
    quotes?: QuoteUpdateManyWithoutRequestNestedInput
    statusHistory?: RequestStatusHistoryUpdateManyWithoutRequestNestedInput
    notifications?: NotificationUpdateManyWithoutRequestNestedInput
    workOrder?: WorkOrderUpdateOneWithoutRequestNestedInput
    chatMessages?: ChatMessageUpdateManyWithoutRequestNestedInput
    aiSuggestions?: AiSuggestionUpdateManyWithoutRequestNestedInput
  }

  export type ServiceRequestUncheckedUpdateWithoutMotorcycleInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    district?: StringFieldUpdateOperationsInput | string
    urgency?: EnumUrgencyLevelFieldUpdateOperationsInput | $Enums.UrgencyLevel
    status?: EnumServiceRequestStatusFieldUpdateOperationsInput | $Enums.ServiceRequestStatus
    completionScore?: IntFieldUpdateOperationsInput | number
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    media?: RequestMediaUncheckedUpdateManyWithoutRequestNestedInput
    guideAnswers?: GuideAnswerUncheckedUpdateManyWithoutRequestNestedInput
    quotes?: QuoteUncheckedUpdateManyWithoutRequestNestedInput
    statusHistory?: RequestStatusHistoryUncheckedUpdateManyWithoutRequestNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutRequestNestedInput
    workOrder?: WorkOrderUncheckedUpdateOneWithoutRequestNestedInput
    chatMessages?: ChatMessageUncheckedUpdateManyWithoutRequestNestedInput
    aiSuggestions?: AiSuggestionUncheckedUpdateManyWithoutRequestNestedInput
  }

  export type ServiceRequestUncheckedUpdateManyWithoutMotorcycleInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    district?: StringFieldUpdateOperationsInput | string
    urgency?: EnumUrgencyLevelFieldUpdateOperationsInput | $Enums.UrgencyLevel
    status?: EnumServiceRequestStatusFieldUpdateOperationsInput | $Enums.ServiceRequestStatus
    completionScore?: IntFieldUpdateOperationsInput | number
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CategoryCreateManyParentInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    version?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GuideQuestionCreateManyCategoryInput = {
    id?: string
    question: string
    inputType?: string
    options?: string | null
    order?: number
    isActive?: boolean
    createdAt?: Date | string
  }

  export type ServiceRequestCreateManyCategoryInput = {
    id?: string
    userId: string
    motorcycleId: string
    description: string
    district: string
    urgency?: $Enums.UrgencyLevel
    status?: $Enums.ServiceRequestStatus
    completionScore?: number
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WorkshopCategoryCreateManyCategoryInput = {
    id?: string
    workshopId: string
  }

  export type CategoryUpdateWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: CategoryUpdateManyWithoutParentNestedInput
    guideQuestions?: GuideQuestionUpdateManyWithoutCategoryNestedInput
    serviceRequests?: ServiceRequestUpdateManyWithoutCategoryNestedInput
    workshopCategories?: WorkshopCategoryUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryUncheckedUpdateWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: CategoryUncheckedUpdateManyWithoutParentNestedInput
    guideQuestions?: GuideQuestionUncheckedUpdateManyWithoutCategoryNestedInput
    serviceRequests?: ServiceRequestUncheckedUpdateManyWithoutCategoryNestedInput
    workshopCategories?: WorkshopCategoryUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryUncheckedUpdateManyWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GuideQuestionUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    inputType?: StringFieldUpdateOperationsInput | string
    options?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    answers?: GuideAnswerUpdateManyWithoutQuestionNestedInput
  }

  export type GuideQuestionUncheckedUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    inputType?: StringFieldUpdateOperationsInput | string
    options?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    answers?: GuideAnswerUncheckedUpdateManyWithoutQuestionNestedInput
  }

  export type GuideQuestionUncheckedUpdateManyWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    inputType?: StringFieldUpdateOperationsInput | string
    options?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceRequestUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    district?: StringFieldUpdateOperationsInput | string
    urgency?: EnumUrgencyLevelFieldUpdateOperationsInput | $Enums.UrgencyLevel
    status?: EnumServiceRequestStatusFieldUpdateOperationsInput | $Enums.ServiceRequestStatus
    completionScore?: IntFieldUpdateOperationsInput | number
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserProfileUpdateOneRequiredWithoutServiceRequestsNestedInput
    motorcycle?: MotorcycleUpdateOneRequiredWithoutServiceRequestsNestedInput
    media?: RequestMediaUpdateManyWithoutRequestNestedInput
    guideAnswers?: GuideAnswerUpdateManyWithoutRequestNestedInput
    quotes?: QuoteUpdateManyWithoutRequestNestedInput
    statusHistory?: RequestStatusHistoryUpdateManyWithoutRequestNestedInput
    notifications?: NotificationUpdateManyWithoutRequestNestedInput
    workOrder?: WorkOrderUpdateOneWithoutRequestNestedInput
    chatMessages?: ChatMessageUpdateManyWithoutRequestNestedInput
    aiSuggestions?: AiSuggestionUpdateManyWithoutRequestNestedInput
  }

  export type ServiceRequestUncheckedUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    motorcycleId?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    district?: StringFieldUpdateOperationsInput | string
    urgency?: EnumUrgencyLevelFieldUpdateOperationsInput | $Enums.UrgencyLevel
    status?: EnumServiceRequestStatusFieldUpdateOperationsInput | $Enums.ServiceRequestStatus
    completionScore?: IntFieldUpdateOperationsInput | number
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    media?: RequestMediaUncheckedUpdateManyWithoutRequestNestedInput
    guideAnswers?: GuideAnswerUncheckedUpdateManyWithoutRequestNestedInput
    quotes?: QuoteUncheckedUpdateManyWithoutRequestNestedInput
    statusHistory?: RequestStatusHistoryUncheckedUpdateManyWithoutRequestNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutRequestNestedInput
    workOrder?: WorkOrderUncheckedUpdateOneWithoutRequestNestedInput
    chatMessages?: ChatMessageUncheckedUpdateManyWithoutRequestNestedInput
    aiSuggestions?: AiSuggestionUncheckedUpdateManyWithoutRequestNestedInput
  }

  export type ServiceRequestUncheckedUpdateManyWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    motorcycleId?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    district?: StringFieldUpdateOperationsInput | string
    urgency?: EnumUrgencyLevelFieldUpdateOperationsInput | $Enums.UrgencyLevel
    status?: EnumServiceRequestStatusFieldUpdateOperationsInput | $Enums.ServiceRequestStatus
    completionScore?: IntFieldUpdateOperationsInput | number
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkshopCategoryUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    workshop?: WorkshopUpdateOneRequiredWithoutCategoriesNestedInput
  }

  export type WorkshopCategoryUncheckedUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    workshopId?: StringFieldUpdateOperationsInput | string
  }

  export type WorkshopCategoryUncheckedUpdateManyWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    workshopId?: StringFieldUpdateOperationsInput | string
  }

  export type GuideAnswerCreateManyQuestionInput = {
    id?: string
    requestId: string
    answer: string
    createdAt?: Date | string
  }

  export type GuideAnswerUpdateWithoutQuestionInput = {
    id?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    request?: ServiceRequestUpdateOneRequiredWithoutGuideAnswersNestedInput
  }

  export type GuideAnswerUncheckedUpdateWithoutQuestionInput = {
    id?: StringFieldUpdateOperationsInput | string
    requestId?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GuideAnswerUncheckedUpdateManyWithoutQuestionInput = {
    id?: StringFieldUpdateOperationsInput | string
    requestId?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RequestMediaCreateManyRequestInput = {
    id?: string
    url: string
    mediaType: $Enums.MediaType
    fileName?: string | null
    fileSize?: number | null
    createdAt?: Date | string
  }

  export type GuideAnswerCreateManyRequestInput = {
    id?: string
    questionId: string
    answer: string
    createdAt?: Date | string
  }

  export type QuoteCreateManyRequestInput = {
    id?: string
    workshopId: string
    version?: number
    diagnosis: string
    laborCost: number
    totalParts?: number
    totalCost: number
    estimatedTime: string
    validUntil: Date | string
    notes?: string | null
    status?: $Enums.QuoteStatus
    rejectionReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RequestStatusHistoryCreateManyRequestInput = {
    id?: string
    fromStatus?: $Enums.ServiceRequestStatus | null
    toStatus: $Enums.ServiceRequestStatus
    actorId?: string | null
    reason?: string | null
    createdAt?: Date | string
  }

  export type NotificationCreateManyRequestInput = {
    id?: string
    userId: string
    title: string
    body: string
    channel?: $Enums.NotificationChannel
    isRead?: boolean
    link?: string | null
    createdAt?: Date | string
  }

  export type ChatMessageCreateManyRequestInput = {
    id?: string
    senderId: string
    content: string
    imageUrl?: string | null
    isRead?: boolean
    createdAt?: Date | string
  }

  export type AiSuggestionCreateManyRequestInput = {
    id?: string
    type: string
    input?: string | null
    output?: string | null
    confidence?: number | null
    modelVersion?: string | null
    isConclusive?: boolean
    disclaimer?: string | null
    createdAt?: Date | string
  }

  export type RequestMediaUpdateWithoutRequestInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    mediaType?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    fileName?: NullableStringFieldUpdateOperationsInput | string | null
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RequestMediaUncheckedUpdateWithoutRequestInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    mediaType?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    fileName?: NullableStringFieldUpdateOperationsInput | string | null
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RequestMediaUncheckedUpdateManyWithoutRequestInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    mediaType?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    fileName?: NullableStringFieldUpdateOperationsInput | string | null
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GuideAnswerUpdateWithoutRequestInput = {
    id?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    question?: GuideQuestionUpdateOneRequiredWithoutAnswersNestedInput
  }

  export type GuideAnswerUncheckedUpdateWithoutRequestInput = {
    id?: StringFieldUpdateOperationsInput | string
    questionId?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GuideAnswerUncheckedUpdateManyWithoutRequestInput = {
    id?: StringFieldUpdateOperationsInput | string
    questionId?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuoteUpdateWithoutRequestInput = {
    id?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    diagnosis?: StringFieldUpdateOperationsInput | string
    laborCost?: FloatFieldUpdateOperationsInput | number
    totalParts?: FloatFieldUpdateOperationsInput | number
    totalCost?: FloatFieldUpdateOperationsInput | number
    estimatedTime?: StringFieldUpdateOperationsInput | string
    validUntil?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumQuoteStatusFieldUpdateOperationsInput | $Enums.QuoteStatus
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workshop?: WorkshopUpdateOneRequiredWithoutQuotesNestedInput
    parts?: QuotePartItemUpdateManyWithoutQuoteNestedInput
    workOrder?: WorkOrderUpdateOneWithoutQuoteNestedInput
    aiAnalysis?: AiQuoteAnalysisUpdateManyWithoutQuoteNestedInput
  }

  export type QuoteUncheckedUpdateWithoutRequestInput = {
    id?: StringFieldUpdateOperationsInput | string
    workshopId?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    diagnosis?: StringFieldUpdateOperationsInput | string
    laborCost?: FloatFieldUpdateOperationsInput | number
    totalParts?: FloatFieldUpdateOperationsInput | number
    totalCost?: FloatFieldUpdateOperationsInput | number
    estimatedTime?: StringFieldUpdateOperationsInput | string
    validUntil?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumQuoteStatusFieldUpdateOperationsInput | $Enums.QuoteStatus
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parts?: QuotePartItemUncheckedUpdateManyWithoutQuoteNestedInput
    workOrder?: WorkOrderUncheckedUpdateOneWithoutQuoteNestedInput
    aiAnalysis?: AiQuoteAnalysisUncheckedUpdateManyWithoutQuoteNestedInput
  }

  export type QuoteUncheckedUpdateManyWithoutRequestInput = {
    id?: StringFieldUpdateOperationsInput | string
    workshopId?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    diagnosis?: StringFieldUpdateOperationsInput | string
    laborCost?: FloatFieldUpdateOperationsInput | number
    totalParts?: FloatFieldUpdateOperationsInput | number
    totalCost?: FloatFieldUpdateOperationsInput | number
    estimatedTime?: StringFieldUpdateOperationsInput | string
    validUntil?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumQuoteStatusFieldUpdateOperationsInput | $Enums.QuoteStatus
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RequestStatusHistoryUpdateWithoutRequestInput = {
    id?: StringFieldUpdateOperationsInput | string
    fromStatus?: NullableEnumServiceRequestStatusFieldUpdateOperationsInput | $Enums.ServiceRequestStatus | null
    toStatus?: EnumServiceRequestStatusFieldUpdateOperationsInput | $Enums.ServiceRequestStatus
    actorId?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RequestStatusHistoryUncheckedUpdateWithoutRequestInput = {
    id?: StringFieldUpdateOperationsInput | string
    fromStatus?: NullableEnumServiceRequestStatusFieldUpdateOperationsInput | $Enums.ServiceRequestStatus | null
    toStatus?: EnumServiceRequestStatusFieldUpdateOperationsInput | $Enums.ServiceRequestStatus
    actorId?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RequestStatusHistoryUncheckedUpdateManyWithoutRequestInput = {
    id?: StringFieldUpdateOperationsInput | string
    fromStatus?: NullableEnumServiceRequestStatusFieldUpdateOperationsInput | $Enums.ServiceRequestStatus | null
    toStatus?: EnumServiceRequestStatusFieldUpdateOperationsInput | $Enums.ServiceRequestStatus
    actorId?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUpdateWithoutRequestInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    channel?: EnumNotificationChannelFieldUpdateOperationsInput | $Enums.NotificationChannel
    isRead?: BoolFieldUpdateOperationsInput | boolean
    link?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserProfileUpdateOneRequiredWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateWithoutRequestInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    channel?: EnumNotificationChannelFieldUpdateOperationsInput | $Enums.NotificationChannel
    isRead?: BoolFieldUpdateOperationsInput | boolean
    link?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyWithoutRequestInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    channel?: EnumNotificationChannelFieldUpdateOperationsInput | $Enums.NotificationChannel
    isRead?: BoolFieldUpdateOperationsInput | boolean
    link?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatMessageUpdateWithoutRequestInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sender?: UserProfileUpdateOneRequiredWithoutChatMessagesNestedInput
  }

  export type ChatMessageUncheckedUpdateWithoutRequestInput = {
    id?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatMessageUncheckedUpdateManyWithoutRequestInput = {
    id?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AiSuggestionUpdateWithoutRequestInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    input?: NullableStringFieldUpdateOperationsInput | string | null
    output?: NullableStringFieldUpdateOperationsInput | string | null
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    modelVersion?: NullableStringFieldUpdateOperationsInput | string | null
    isConclusive?: BoolFieldUpdateOperationsInput | boolean
    disclaimer?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AiSuggestionUncheckedUpdateWithoutRequestInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    input?: NullableStringFieldUpdateOperationsInput | string | null
    output?: NullableStringFieldUpdateOperationsInput | string | null
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    modelVersion?: NullableStringFieldUpdateOperationsInput | string | null
    isConclusive?: BoolFieldUpdateOperationsInput | boolean
    disclaimer?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AiSuggestionUncheckedUpdateManyWithoutRequestInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    input?: NullableStringFieldUpdateOperationsInput | string | null
    output?: NullableStringFieldUpdateOperationsInput | string | null
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    modelVersion?: NullableStringFieldUpdateOperationsInput | string | null
    isConclusive?: BoolFieldUpdateOperationsInput | boolean
    disclaimer?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkshopCategoryCreateManyWorkshopInput = {
    id?: string
    categoryId: string
  }

  export type QuoteCreateManyWorkshopInput = {
    id?: string
    requestId: string
    version?: number
    diagnosis: string
    laborCost: number
    totalParts?: number
    totalCost: number
    estimatedTime: string
    validUntil: Date | string
    notes?: string | null
    status?: $Enums.QuoteStatus
    rejectionReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WorkOrderCreateManyWorkshopInput = {
    id?: string
    orderNumber: string
    requestId: string
    quoteId: string
    diagnosis: string
    totalAgreed: number
    totalFinal?: number | null
    status?: $Enums.WorkOrderStatus
    userAcceptedAt?: Date | string | null
    workshopAcceptedAt?: Date | string | null
    startedAt?: Date | string | null
    startNote?: string | null
    completedAt?: Date | string | null
    closedAt?: Date | string | null
    closureChecklist?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReviewCreateManyWorkshopInput = {
    id?: string
    workOrderId: string
    userId: string
    rating: number
    comment?: string | null
    editableUntil: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IncidentReportCreateManyWorkshopInput = {
    id?: string
    reporterId: string
    type: $Enums.IncidentType
    description: string
    evidenceUrl?: string | null
    status?: $Enums.IncidentStatus
    resolution?: string | null
    resolvedAt?: Date | string | null
    resolvedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WorkshopVerificationCreateManyWorkshopInput = {
    id?: string
    adminId: string
    decision: $Enums.WorkshopStatus
    reason: string
    createdAt?: Date | string
  }

  export type WorkshopCategoryUpdateWithoutWorkshopInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: CategoryUpdateOneRequiredWithoutWorkshopCategoriesNestedInput
  }

  export type WorkshopCategoryUncheckedUpdateWithoutWorkshopInput = {
    id?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
  }

  export type WorkshopCategoryUncheckedUpdateManyWithoutWorkshopInput = {
    id?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
  }

  export type QuoteUpdateWithoutWorkshopInput = {
    id?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    diagnosis?: StringFieldUpdateOperationsInput | string
    laborCost?: FloatFieldUpdateOperationsInput | number
    totalParts?: FloatFieldUpdateOperationsInput | number
    totalCost?: FloatFieldUpdateOperationsInput | number
    estimatedTime?: StringFieldUpdateOperationsInput | string
    validUntil?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumQuoteStatusFieldUpdateOperationsInput | $Enums.QuoteStatus
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    request?: ServiceRequestUpdateOneRequiredWithoutQuotesNestedInput
    parts?: QuotePartItemUpdateManyWithoutQuoteNestedInput
    workOrder?: WorkOrderUpdateOneWithoutQuoteNestedInput
    aiAnalysis?: AiQuoteAnalysisUpdateManyWithoutQuoteNestedInput
  }

  export type QuoteUncheckedUpdateWithoutWorkshopInput = {
    id?: StringFieldUpdateOperationsInput | string
    requestId?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    diagnosis?: StringFieldUpdateOperationsInput | string
    laborCost?: FloatFieldUpdateOperationsInput | number
    totalParts?: FloatFieldUpdateOperationsInput | number
    totalCost?: FloatFieldUpdateOperationsInput | number
    estimatedTime?: StringFieldUpdateOperationsInput | string
    validUntil?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumQuoteStatusFieldUpdateOperationsInput | $Enums.QuoteStatus
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parts?: QuotePartItemUncheckedUpdateManyWithoutQuoteNestedInput
    workOrder?: WorkOrderUncheckedUpdateOneWithoutQuoteNestedInput
    aiAnalysis?: AiQuoteAnalysisUncheckedUpdateManyWithoutQuoteNestedInput
  }

  export type QuoteUncheckedUpdateManyWithoutWorkshopInput = {
    id?: StringFieldUpdateOperationsInput | string
    requestId?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    diagnosis?: StringFieldUpdateOperationsInput | string
    laborCost?: FloatFieldUpdateOperationsInput | number
    totalParts?: FloatFieldUpdateOperationsInput | number
    totalCost?: FloatFieldUpdateOperationsInput | number
    estimatedTime?: StringFieldUpdateOperationsInput | string
    validUntil?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumQuoteStatusFieldUpdateOperationsInput | $Enums.QuoteStatus
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkOrderUpdateWithoutWorkshopInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    diagnosis?: StringFieldUpdateOperationsInput | string
    totalAgreed?: FloatFieldUpdateOperationsInput | number
    totalFinal?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumWorkOrderStatusFieldUpdateOperationsInput | $Enums.WorkOrderStatus
    userAcceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    workshopAcceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startNote?: NullableStringFieldUpdateOperationsInput | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closureChecklist?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    request?: ServiceRequestUpdateOneRequiredWithoutWorkOrderNestedInput
    quote?: QuoteUpdateOneRequiredWithoutWorkOrderNestedInput
    changeRequests?: ChangeRequestUpdateManyWithoutWorkOrderNestedInput
    evidences?: EvidenceUpdateManyWithoutWorkOrderNestedInput
    review?: ReviewUpdateOneWithoutWorkOrderNestedInput
    receipt?: ReceiptUpdateOneWithoutWorkOrderNestedInput
  }

  export type WorkOrderUncheckedUpdateWithoutWorkshopInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    requestId?: StringFieldUpdateOperationsInput | string
    quoteId?: StringFieldUpdateOperationsInput | string
    diagnosis?: StringFieldUpdateOperationsInput | string
    totalAgreed?: FloatFieldUpdateOperationsInput | number
    totalFinal?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumWorkOrderStatusFieldUpdateOperationsInput | $Enums.WorkOrderStatus
    userAcceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    workshopAcceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startNote?: NullableStringFieldUpdateOperationsInput | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closureChecklist?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    changeRequests?: ChangeRequestUncheckedUpdateManyWithoutWorkOrderNestedInput
    evidences?: EvidenceUncheckedUpdateManyWithoutWorkOrderNestedInput
    review?: ReviewUncheckedUpdateOneWithoutWorkOrderNestedInput
    receipt?: ReceiptUncheckedUpdateOneWithoutWorkOrderNestedInput
  }

  export type WorkOrderUncheckedUpdateManyWithoutWorkshopInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    requestId?: StringFieldUpdateOperationsInput | string
    quoteId?: StringFieldUpdateOperationsInput | string
    diagnosis?: StringFieldUpdateOperationsInput | string
    totalAgreed?: FloatFieldUpdateOperationsInput | number
    totalFinal?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumWorkOrderStatusFieldUpdateOperationsInput | $Enums.WorkOrderStatus
    userAcceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    workshopAcceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startNote?: NullableStringFieldUpdateOperationsInput | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closureChecklist?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewUpdateWithoutWorkshopInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    editableUntil?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workOrder?: WorkOrderUpdateOneRequiredWithoutReviewNestedInput
    user?: UserProfileUpdateOneRequiredWithoutReviewsNestedInput
  }

  export type ReviewUncheckedUpdateWithoutWorkshopInput = {
    id?: StringFieldUpdateOperationsInput | string
    workOrderId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    editableUntil?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewUncheckedUpdateManyWithoutWorkshopInput = {
    id?: StringFieldUpdateOperationsInput | string
    workOrderId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    editableUntil?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IncidentReportUpdateWithoutWorkshopInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumIncidentTypeFieldUpdateOperationsInput | $Enums.IncidentType
    description?: StringFieldUpdateOperationsInput | string
    evidenceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumIncidentStatusFieldUpdateOperationsInput | $Enums.IncidentStatus
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reporter?: UserProfileUpdateOneRequiredWithoutIncidentReportsNestedInput
  }

  export type IncidentReportUncheckedUpdateWithoutWorkshopInput = {
    id?: StringFieldUpdateOperationsInput | string
    reporterId?: StringFieldUpdateOperationsInput | string
    type?: EnumIncidentTypeFieldUpdateOperationsInput | $Enums.IncidentType
    description?: StringFieldUpdateOperationsInput | string
    evidenceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumIncidentStatusFieldUpdateOperationsInput | $Enums.IncidentStatus
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IncidentReportUncheckedUpdateManyWithoutWorkshopInput = {
    id?: StringFieldUpdateOperationsInput | string
    reporterId?: StringFieldUpdateOperationsInput | string
    type?: EnumIncidentTypeFieldUpdateOperationsInput | $Enums.IncidentType
    description?: StringFieldUpdateOperationsInput | string
    evidenceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumIncidentStatusFieldUpdateOperationsInput | $Enums.IncidentStatus
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkshopVerificationUpdateWithoutWorkshopInput = {
    id?: StringFieldUpdateOperationsInput | string
    adminId?: StringFieldUpdateOperationsInput | string
    decision?: EnumWorkshopStatusFieldUpdateOperationsInput | $Enums.WorkshopStatus
    reason?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkshopVerificationUncheckedUpdateWithoutWorkshopInput = {
    id?: StringFieldUpdateOperationsInput | string
    adminId?: StringFieldUpdateOperationsInput | string
    decision?: EnumWorkshopStatusFieldUpdateOperationsInput | $Enums.WorkshopStatus
    reason?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkshopVerificationUncheckedUpdateManyWithoutWorkshopInput = {
    id?: StringFieldUpdateOperationsInput | string
    adminId?: StringFieldUpdateOperationsInput | string
    decision?: EnumWorkshopStatusFieldUpdateOperationsInput | $Enums.WorkshopStatus
    reason?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuotePartItemCreateManyQuoteInput = {
    id?: string
    name: string
    quantity?: number
    unitPrice: number
    partType?: $Enums.PartType
    notes?: string | null
    alternativeName?: string | null
    alternativePrice?: number | null
    alternativeType?: $Enums.PartType | null
    alternativeNotes?: string | null
    selectedAlternative?: boolean
    createdAt?: Date | string
  }

  export type AiQuoteAnalysisCreateManyQuoteInput = {
    id?: string
    type: string
    input?: string | null
    output?: string | null
    traceability?: string | null
    modelVersion?: string | null
    createdAt?: Date | string
  }

  export type QuotePartItemUpdateWithoutQuoteInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    partType?: EnumPartTypeFieldUpdateOperationsInput | $Enums.PartType
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    alternativeName?: NullableStringFieldUpdateOperationsInput | string | null
    alternativePrice?: NullableFloatFieldUpdateOperationsInput | number | null
    alternativeType?: NullableEnumPartTypeFieldUpdateOperationsInput | $Enums.PartType | null
    alternativeNotes?: NullableStringFieldUpdateOperationsInput | string | null
    selectedAlternative?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuotePartItemUncheckedUpdateWithoutQuoteInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    partType?: EnumPartTypeFieldUpdateOperationsInput | $Enums.PartType
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    alternativeName?: NullableStringFieldUpdateOperationsInput | string | null
    alternativePrice?: NullableFloatFieldUpdateOperationsInput | number | null
    alternativeType?: NullableEnumPartTypeFieldUpdateOperationsInput | $Enums.PartType | null
    alternativeNotes?: NullableStringFieldUpdateOperationsInput | string | null
    selectedAlternative?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuotePartItemUncheckedUpdateManyWithoutQuoteInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    partType?: EnumPartTypeFieldUpdateOperationsInput | $Enums.PartType
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    alternativeName?: NullableStringFieldUpdateOperationsInput | string | null
    alternativePrice?: NullableFloatFieldUpdateOperationsInput | number | null
    alternativeType?: NullableEnumPartTypeFieldUpdateOperationsInput | $Enums.PartType | null
    alternativeNotes?: NullableStringFieldUpdateOperationsInput | string | null
    selectedAlternative?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AiQuoteAnalysisUpdateWithoutQuoteInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    input?: NullableStringFieldUpdateOperationsInput | string | null
    output?: NullableStringFieldUpdateOperationsInput | string | null
    traceability?: NullableStringFieldUpdateOperationsInput | string | null
    modelVersion?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AiQuoteAnalysisUncheckedUpdateWithoutQuoteInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    input?: NullableStringFieldUpdateOperationsInput | string | null
    output?: NullableStringFieldUpdateOperationsInput | string | null
    traceability?: NullableStringFieldUpdateOperationsInput | string | null
    modelVersion?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AiQuoteAnalysisUncheckedUpdateManyWithoutQuoteInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    input?: NullableStringFieldUpdateOperationsInput | string | null
    output?: NullableStringFieldUpdateOperationsInput | string | null
    traceability?: NullableStringFieldUpdateOperationsInput | string | null
    modelVersion?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChangeRequestCreateManyWorkOrderInput = {
    id?: string
    description: string
    justification: string
    additionalCost: number
    additionalTime?: string | null
    status?: $Enums.ChangeRequestStatus
    decidedAt?: Date | string | null
    decidedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EvidenceCreateManyWorkOrderInput = {
    id?: string
    stage: $Enums.EvidenceStage
    url: string
    mediaType: $Enums.MediaType
    fileName?: string | null
    description?: string | null
    flagged?: boolean
    createdAt?: Date | string
  }

  export type ChangeRequestUpdateWithoutWorkOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    justification?: StringFieldUpdateOperationsInput | string
    additionalCost?: FloatFieldUpdateOperationsInput | number
    additionalTime?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumChangeRequestStatusFieldUpdateOperationsInput | $Enums.ChangeRequestStatus
    decidedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    decidedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChangeRequestUncheckedUpdateWithoutWorkOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    justification?: StringFieldUpdateOperationsInput | string
    additionalCost?: FloatFieldUpdateOperationsInput | number
    additionalTime?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumChangeRequestStatusFieldUpdateOperationsInput | $Enums.ChangeRequestStatus
    decidedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    decidedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChangeRequestUncheckedUpdateManyWithoutWorkOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    justification?: StringFieldUpdateOperationsInput | string
    additionalCost?: FloatFieldUpdateOperationsInput | number
    additionalTime?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumChangeRequestStatusFieldUpdateOperationsInput | $Enums.ChangeRequestStatus
    decidedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    decidedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EvidenceUpdateWithoutWorkOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    stage?: EnumEvidenceStageFieldUpdateOperationsInput | $Enums.EvidenceStage
    url?: StringFieldUpdateOperationsInput | string
    mediaType?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    fileName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    flagged?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EvidenceUncheckedUpdateWithoutWorkOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    stage?: EnumEvidenceStageFieldUpdateOperationsInput | $Enums.EvidenceStage
    url?: StringFieldUpdateOperationsInput | string
    mediaType?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    fileName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    flagged?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EvidenceUncheckedUpdateManyWithoutWorkOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    stage?: EnumEvidenceStageFieldUpdateOperationsInput | $Enums.EvidenceStage
    url?: StringFieldUpdateOperationsInput | string
    mediaType?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    fileName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    flagged?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}